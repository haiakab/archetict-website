const e=Symbol(),t=Symbol(),r=Symbol(),n=Object.getPrototypeOf,o=new WeakMap,s=e=>e&&(o.has(e)?o.get(e):n(e)===Object.prototype||n(e)===Array.prototype),c=e=>"object"==typeof e&&null!==e,l=(n,o)=>{let s=!1;const c=(e,t)=>{if(!s){let r=e.a.get(n);r||(r=new Set,e.a.set(n,r)),r.add(t)}},l={f:o,get(e,t){return t===r?n:(c(this,t),i(e[t],this.a,this.c))},has(e,r){return r===t?(s=!0,this.a.delete(n),!0):(c(this,r),r in e)},ownKeys(t){return c(this,e),Reflect.ownKeys(t)}};return o&&(l.set=l.deleteProperty=()=>!1),l},i=(e,t,o)=>{if(!s(e))return e;const c=e[r]||e,i=(e=>Object.isFrozen(e)||Object.values(Object.getOwnPropertyDescriptors(e)).some(e=>!e.writable))(c);let u=o&&o.get(c);return u&&u.f===i||(u=l(c,i),u.p=new Proxy(i?(e=>{if(Array.isArray(e))return Array.from(e);const t=Object.getOwnPropertyDescriptors(e);return Object.values(t).forEach(e=>{e.configurable=!0}),Object.create(n(e),t)})(c):c,u),o&&o.set(c,u)),u.a=t,u.c=o,u.p},u=(e,t)=>{const r=Reflect.ownKeys(e),n=Reflect.ownKeys(t);return r.length!==n.length||r.some((e,t)=>e!==n[t])},a=1,f=2,y=4,b=8,g=(t,r,n,o,s=0)=>{if(Object.is(t,r)&&(!c(t)||0==(2&s)))return!1;if(!c(t)||!c(r))return!0;const l=n.get(t);if(!l)return 0==(1&s);if(o&&0==(2&s)){const e=o.get(t);if(e&&e.n===r)return e.g;o.set(t,{n:r,g:!1})}let i=null;for(const c of l){const l=c===e?u(t,r):g(t[c],r[c],n,o,s>>>2<<2|s>>>2);if(!0!==l&&!1!==l||(i=l),i)break}return null===i&&(i=0==(1&s)),o&&0==(2&s)&&o.set(t,{n:r,g:i}),i},p=e=>!!s(e)&&t in e,h=e=>s(e)&&e[r]||null,O=(e,t=!0)=>{o.set(e,t)},j=(e,t)=>{const r=[],n=(e,o)=>{const s=t.get(e);s?s.forEach(t=>{n(e[t],o?[...o,t]:[t])}):o&&r.push(o)};return n(e),r};export{a as MODE_ASSUME_UNCHANGED_IF_UNAFFECTED,y as MODE_ASSUME_UNCHANGED_IF_UNAFFECTED_IN_DEEP,f as MODE_IGNORE_REF_EQUALITY,b as MODE_IGNORE_REF_EQUALITY_IN_DEEP,j as affectedToPathList,i as createDeepProxy,h as getUntrackedObject,g as isDeepChanged,O as markToTrack,p as trackMemo};
//# sourceMappingURL=index.modern.js.map
