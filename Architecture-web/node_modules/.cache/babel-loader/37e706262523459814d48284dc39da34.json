{"ast":null,"code":"import { useContext, useRef, useState, createElement, createContext } from 'react';\nimport { Object3D, Matrix4, Quaternion, Vector3, Scene } from 'three';\nimport { useThree, useFrame, createPortal } from '@react-three/fiber';\nimport { OrthographicCamera } from './OrthographicCamera.js';\nimport { useCamera } from './useCamera.js';\nconst Context = /*#__PURE__*/createContext({});\n\nconst useGizmoContext = () => {\n  return useContext(Context);\n};\n\nconst turnRate = 2 * Math.PI; // turn rate in angles per second\n\nconst dummy = new Object3D();\nconst matrix = new Matrix4();\nconst [q1, q2] = [new Quaternion(), new Quaternion()];\nconst target = new Vector3();\nconst targetPosition = new Vector3();\nconst targetQuaternion = new Quaternion();\n\nconst GizmoHelper = ({\n  alignment = 'bottom-right',\n  margin = [80, 80],\n  onUpdate,\n  onTarget,\n  children: GizmoHelperComponent\n}) => {\n  const size = useThree(({\n    size\n  }) => size);\n  const mainCamera = useThree(({\n    camera\n  }) => camera);\n  const gl = useThree(({\n    gl\n  }) => gl);\n  const gizmoRef = useRef();\n  const virtualCam = useRef(null);\n  const [virtualScene] = useState(() => new Scene());\n  const animating = useRef(false);\n  const radius = useRef(0);\n  const focusPoint = useRef(new Vector3(0, 0, 0));\n\n  const tweenCamera = direction => {\n    animating.current = true;\n    focusPoint.current = onTarget();\n    radius.current = mainCamera.position.distanceTo(target); // Rotate from current camera orientation\n\n    dummy.position.copy(target);\n    dummy.lookAt(mainCamera.position);\n    q1.copy(dummy.quaternion); // To new current camera orientation\n\n    targetPosition.copy(direction).multiplyScalar(radius.current).add(target);\n    dummy.lookAt(targetPosition);\n    q2.copy(dummy.quaternion);\n  };\n\n  const animateStep = delta => {\n    if (!animating.current) return;\n    const step = delta * turnRate; // animate position by doing a slerp and then scaling the position on the unit sphere\n\n    q1.rotateTowards(q2, step);\n    mainCamera.position.set(0, 0, 1).applyQuaternion(q1).multiplyScalar(radius.current).add(focusPoint.current); // animate orientation\n\n    mainCamera.quaternion.rotateTowards(targetQuaternion, step);\n    mainCamera.updateProjectionMatrix();\n    onUpdate && onUpdate();\n\n    if (q1.angleTo(q2) < 0.01) {\n      animating.current = false;\n    }\n  };\n\n  const beforeRender = () => {\n    var _gizmoRef$current; // Sync gizmo with main camera orientation\n\n\n    matrix.copy(mainCamera.matrix).invert();\n    (_gizmoRef$current = gizmoRef.current) == null ? void 0 : _gizmoRef$current.quaternion.setFromRotationMatrix(matrix);\n  };\n\n  useFrame((_, delta) => {\n    if (virtualCam.current && gizmoRef.current) {\n      animateStep(delta);\n      beforeRender();\n      gl.autoClear = false;\n      gl.clearDepth();\n      gl.render(virtualScene, virtualCam.current);\n    }\n  });\n  const gizmoHelperContext = {\n    tweenCamera,\n    raycast: useCamera(virtualCam)\n  }; // Position gizmo component within scene\n\n  const [marginX, marginY] = margin;\n  const x = alignment.endsWith('-left') ? -size.width / 2 + marginX : size.width / 2 - marginX;\n  const y = alignment.startsWith('top-') ? size.height / 2 - marginY : -size.height / 2 + marginY;\n  return createPortal( /*#__PURE__*/createElement(Context.Provider, {\n    value: gizmoHelperContext\n  }, /*#__PURE__*/createElement(OrthographicCamera, {\n    ref: virtualCam,\n    makeDefault: false,\n    position: [0, 0, 100]\n  }), /*#__PURE__*/createElement(\"group\", {\n    ref: gizmoRef,\n    position: [x, y, 0]\n  }, GizmoHelperComponent)), virtualScene);\n};\n\nexport { GizmoHelper, useGizmoContext };","map":{"version":3,"sources":["/Users/haiakablan/Documents/לוטוס/קורס/Architecture-web/node_modules/@react-three/drei/core/GizmoHelper.js"],"names":["useContext","useRef","useState","createElement","createContext","Object3D","Matrix4","Quaternion","Vector3","Scene","useThree","useFrame","createPortal","OrthographicCamera","useCamera","Context","useGizmoContext","turnRate","Math","PI","dummy","matrix","q1","q2","target","targetPosition","targetQuaternion","GizmoHelper","alignment","margin","onUpdate","onTarget","children","GizmoHelperComponent","size","mainCamera","camera","gl","gizmoRef","virtualCam","virtualScene","animating","radius","focusPoint","tweenCamera","direction","current","position","distanceTo","copy","lookAt","quaternion","multiplyScalar","add","animateStep","delta","step","rotateTowards","set","applyQuaternion","updateProjectionMatrix","angleTo","beforeRender","_gizmoRef$current","invert","setFromRotationMatrix","_","autoClear","clearDepth","render","gizmoHelperContext","raycast","marginX","marginY","x","endsWith","width","y","startsWith","height","Provider","value","ref","makeDefault"],"mappings":"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","sourcesContent":["import { useContext, useRef, useState, createElement, createContext } from 'react';\nimport { Object3D, Matrix4, Quaternion, Vector3, Scene } from 'three';\nimport { useThree, useFrame, createPortal } from '@react-three/fiber';\nimport { OrthographicCamera } from './OrthographicCamera.js';\nimport { useCamera } from './useCamera.js';\n\nconst Context = /*#__PURE__*/createContext({});\nconst useGizmoContext = () => {\n  return useContext(Context);\n};\nconst turnRate = 2 * Math.PI; // turn rate in angles per second\n\nconst dummy = new Object3D();\nconst matrix = new Matrix4();\nconst [q1, q2] = [new Quaternion(), new Quaternion()];\nconst target = new Vector3();\nconst targetPosition = new Vector3();\nconst targetQuaternion = new Quaternion();\nconst GizmoHelper = ({\n  alignment = 'bottom-right',\n  margin = [80, 80],\n  onUpdate,\n  onTarget,\n  children: GizmoHelperComponent\n}) => {\n  const size = useThree(({\n    size\n  }) => size);\n  const mainCamera = useThree(({\n    camera\n  }) => camera);\n  const gl = useThree(({\n    gl\n  }) => gl);\n  const gizmoRef = useRef();\n  const virtualCam = useRef(null);\n  const [virtualScene] = useState(() => new Scene());\n  const animating = useRef(false);\n  const radius = useRef(0);\n  const focusPoint = useRef(new Vector3(0, 0, 0));\n\n  const tweenCamera = direction => {\n    animating.current = true;\n    focusPoint.current = onTarget();\n    radius.current = mainCamera.position.distanceTo(target); // Rotate from current camera orientation\n\n    dummy.position.copy(target);\n    dummy.lookAt(mainCamera.position);\n    q1.copy(dummy.quaternion); // To new current camera orientation\n\n    targetPosition.copy(direction).multiplyScalar(radius.current).add(target);\n    dummy.lookAt(targetPosition);\n    q2.copy(dummy.quaternion);\n  };\n\n  const animateStep = delta => {\n    if (!animating.current) return;\n    const step = delta * turnRate; // animate position by doing a slerp and then scaling the position on the unit sphere\n\n    q1.rotateTowards(q2, step);\n    mainCamera.position.set(0, 0, 1).applyQuaternion(q1).multiplyScalar(radius.current).add(focusPoint.current); // animate orientation\n\n    mainCamera.quaternion.rotateTowards(targetQuaternion, step);\n    mainCamera.updateProjectionMatrix();\n    onUpdate && onUpdate();\n\n    if (q1.angleTo(q2) < 0.01) {\n      animating.current = false;\n    }\n  };\n\n  const beforeRender = () => {\n    var _gizmoRef$current;\n\n    // Sync gizmo with main camera orientation\n    matrix.copy(mainCamera.matrix).invert();\n    (_gizmoRef$current = gizmoRef.current) == null ? void 0 : _gizmoRef$current.quaternion.setFromRotationMatrix(matrix);\n  };\n\n  useFrame((_, delta) => {\n    if (virtualCam.current && gizmoRef.current) {\n      animateStep(delta);\n      beforeRender();\n      gl.autoClear = false;\n      gl.clearDepth();\n      gl.render(virtualScene, virtualCam.current);\n    }\n  });\n  const gizmoHelperContext = {\n    tweenCamera,\n    raycast: useCamera(virtualCam)\n  }; // Position gizmo component within scene\n\n  const [marginX, marginY] = margin;\n  const x = alignment.endsWith('-left') ? -size.width / 2 + marginX : size.width / 2 - marginX;\n  const y = alignment.startsWith('top-') ? size.height / 2 - marginY : -size.height / 2 + marginY;\n  return createPortal( /*#__PURE__*/createElement(Context.Provider, {\n    value: gizmoHelperContext\n  }, /*#__PURE__*/createElement(OrthographicCamera, {\n    ref: virtualCam,\n    makeDefault: false,\n    position: [0, 0, 100]\n  }), /*#__PURE__*/createElement(\"group\", {\n    ref: gizmoRef,\n    position: [x, y, 0]\n  }, GizmoHelperComponent)), virtualScene);\n};\n\nexport { GizmoHelper, useGizmoContext };\n"]},"metadata":{},"sourceType":"module"}