{"ast":null,"code":"import { useRef, useCallback, useEffect, useMemo } from 'react';\nimport { markToTrack, getUntrackedObject, isDeepChanged, createDeepProxy } from 'proxy-compare';\nimport { useSubscription } from 'use-subscription';\n/*\nexport {\n  unstable_createMutableSource as createMutableSource,\n  unstable_useMutableSource as useMutableSource,\n} from 'react'\n*/\n\nconst TARGET = Symbol();\nconst GET_VERSION = Symbol();\n\nconst createMutableSource = (target, getVersion) => ({\n  [TARGET]: target,\n  [GET_VERSION]: getVersion\n});\n\nconst useMutableSource = (source, getSnapshot, subscribe) => {\n  const lastVersion = useRef(0);\n  const versionDiff = source[GET_VERSION](source[TARGET]) - lastVersion.current; // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  const getCurrentValue = useCallback(() => getSnapshot(source[TARGET]), [source, getSnapshot, versionDiff]);\n  const sub = useCallback(callback => subscribe(source[TARGET], () => {\n    lastVersion.current = source[GET_VERSION](source[TARGET]);\n    callback();\n  }), [source, subscribe]);\n  useEffect(() => {\n    lastVersion.current = source[GET_VERSION](source[TARGET]);\n  });\n  return useSubscription({\n    getCurrentValue,\n    subscribe: sub\n  });\n};\n\nconst VERSION = Symbol();\nconst LISTENERS = Symbol();\nconst SNAPSHOT = Symbol();\nconst PROMISE_RESULT = Symbol();\nconst PROMISE_ERROR = Symbol();\n\nconst isSupportedObject = x => typeof x === 'object' && x !== null && (Array.isArray(x) || !x[Symbol.iterator]) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer);\n\nconst proxyCache = new WeakMap();\nlet globalVersion = 1;\nconst snapshotCache = new WeakMap();\n\nconst proxy = (initialObject = {}) => {\n  if (!isSupportedObject(initialObject)) {\n    throw new Error('unsupported object type');\n  }\n\n  if (proxyCache.has(initialObject)) {\n    return proxyCache.get(initialObject);\n  }\n\n  let version = globalVersion;\n  const listeners = new Set();\n\n  const notifyUpdate = nextVersion => {\n    if (!nextVersion) {\n      nextVersion = ++globalVersion;\n    }\n\n    if (version !== nextVersion) {\n      version = nextVersion;\n      listeners.forEach(listener => listener(nextVersion));\n    }\n  };\n\n  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));\n  const p = new Proxy(baseObject, {\n    get(target, prop, receiver) {\n      if (prop === VERSION) {\n        return version;\n      }\n\n      if (prop === LISTENERS) {\n        return listeners;\n      }\n\n      if (prop === SNAPSHOT) {\n        const cache = snapshotCache.get(receiver);\n\n        if (cache && cache.version === version) {\n          return cache.snapshot;\n        }\n\n        const snapshot = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));\n        markToTrack(snapshot);\n        snapshotCache.set(receiver, {\n          version,\n          snapshot\n        });\n        Reflect.ownKeys(target).forEach(key => {\n          const value = target[key];\n\n          if (!isSupportedObject(value)) {\n            snapshot[key] = value;\n          } else if (value instanceof Promise) {\n            if (value[PROMISE_RESULT]) {\n              snapshot[key] = value[PROMISE_RESULT];\n            } else {\n              const errorOrPromise = value[PROMISE_ERROR] || value;\n              Object.defineProperty(snapshot, key, {\n                get() {\n                  throw errorOrPromise;\n                }\n\n              });\n            }\n          } else if (value[VERSION]) {\n            snapshot[key] = value[SNAPSHOT];\n          } else {\n            snapshot[key] = value;\n          }\n        });\n\n        if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n          Object.freeze(snapshot);\n        }\n\n        return snapshot;\n      }\n\n      return target[prop];\n    },\n\n    deleteProperty(target, prop) {\n      const prevValue = target[prop];\n      const childListeners = isSupportedObject(prevValue) && prevValue[LISTENERS];\n\n      if (childListeners) {\n        childListeners.delete(notifyUpdate);\n      }\n\n      const deleted = Reflect.deleteProperty(target, prop);\n\n      if (deleted) {\n        notifyUpdate();\n      }\n\n      return deleted;\n    },\n\n    set(target, prop, value) {\n      const prevValue = target[prop];\n\n      if (Object.is(prevValue, value)) {\n        return true;\n      }\n\n      const childListeners = isSupportedObject(prevValue) && prevValue[LISTENERS];\n\n      if (childListeners) {\n        childListeners.delete(notifyUpdate);\n      }\n\n      if (!isSupportedObject(value)) {\n        target[prop] = value;\n      } else if (value instanceof Promise) {\n        target[prop] = value.then(v => {\n          target[prop][PROMISE_RESULT] = v;\n          notifyUpdate();\n        }).catch(e => {\n          target[prop][PROMISE_ERROR] = e;\n          notifyUpdate();\n        });\n      } else {\n        value = getUntrackedObject(value) || value;\n\n        if (value[LISTENERS]) {\n          target[prop] = value;\n        } else {\n          target[prop] = proxy(value);\n        }\n\n        target[prop][LISTENERS].add(notifyUpdate);\n      }\n\n      notifyUpdate();\n      return true;\n    }\n\n  });\n  proxyCache.set(initialObject, p);\n  Reflect.ownKeys(initialObject).forEach(key => {\n    const desc = Object.getOwnPropertyDescriptor(initialObject, key);\n\n    if (desc.get) {\n      Object.defineProperty(baseObject, key, desc);\n    } else {\n      p[key] = initialObject[key];\n    }\n  });\n  return p;\n};\n\nconst getVersion = p => {\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production' && (!p || !p[VERSION])) {\n    throw new Error('Please use proxy object');\n  }\n\n  return p[VERSION];\n};\n\nconst subscribe = (p, callback, notifyInSync) => {\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production' && (!p || !p[LISTENERS])) {\n    throw new Error('Please use proxy object');\n  }\n\n  let pendingVersion = 0;\n\n  const listener = nextVersion => {\n    if (notifyInSync) {\n      callback();\n      return;\n    }\n\n    pendingVersion = nextVersion;\n    Promise.resolve().then(() => {\n      if (nextVersion === pendingVersion) {\n        callback();\n      }\n    });\n  };\n\n  p[LISTENERS].add(listener);\n  return () => {\n    p[LISTENERS].delete(listener);\n  };\n};\n\nconst snapshot = p => {\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production' && (!p || !p[SNAPSHOT])) {\n    throw new Error('Please use proxy object');\n  }\n\n  return p[SNAPSHOT];\n};\n\nconst mutableSourceCache = new WeakMap();\n\nconst getMutableSource = p => {\n  if (!mutableSourceCache.has(p)) {\n    mutableSourceCache.set(p, createMutableSource(p, getVersion));\n  }\n\n  return mutableSourceCache.get(p);\n};\n\nconst useProxy = (p, options) => {\n  const affected = new WeakMap();\n  const lastAffected = useRef();\n  useEffect(() => {\n    lastAffected.current = affected;\n  });\n  const getSnapshot = useMemo(() => {\n    let prevSnapshot = null;\n    const deepChangedCache = new WeakMap();\n    return p => {\n      const nextSnapshot = snapshot(p);\n\n      try {\n        if (prevSnapshot !== null && lastAffected.current && !isDeepChanged(prevSnapshot, nextSnapshot, lastAffected.current, deepChangedCache)) {\n          // not changed\n          return prevSnapshot;\n        }\n      } catch (e) {// ignore and return new nextSnapshot\n      }\n\n      return prevSnapshot = nextSnapshot;\n    };\n  }, []);\n  const notifyInSync = options == null ? void 0 : options.sync;\n  const sub = useCallback((p, cb) => subscribe(p, cb, notifyInSync), [notifyInSync]);\n  const currSnapshot = useMutableSource(getMutableSource(p), getSnapshot, sub);\n  const proxyCache = useMemo(() => new WeakMap(), []); // per-hook proxyCache\n\n  return createDeepProxy(currSnapshot, affected, proxyCache);\n};\n\nexport { proxy, snapshot, subscribe, useProxy };","map":{"version":3,"sources":["/Users/haiakablan/Documents/לוטוס/קורס/Architecture-web/node_modules/valtio/index.js"],"names":["useRef","useCallback","useEffect","useMemo","markToTrack","getUntrackedObject","isDeepChanged","createDeepProxy","useSubscription","TARGET","Symbol","GET_VERSION","createMutableSource","target","getVersion","useMutableSource","source","getSnapshot","subscribe","lastVersion","versionDiff","current","getCurrentValue","sub","callback","VERSION","LISTENERS","SNAPSHOT","PROMISE_RESULT","PROMISE_ERROR","isSupportedObject","x","Array","isArray","iterator","WeakMap","WeakSet","Error","Number","Date","String","RegExp","ArrayBuffer","proxyCache","globalVersion","snapshotCache","proxy","initialObject","has","get","version","listeners","Set","notifyUpdate","nextVersion","forEach","listener","baseObject","Object","create","getPrototypeOf","p","Proxy","prop","receiver","cache","snapshot","set","Reflect","ownKeys","key","value","Promise","errorOrPromise","defineProperty","process","env","NODE_ENV","freeze","deleteProperty","prevValue","childListeners","delete","deleted","is","then","v","catch","e","add","desc","getOwnPropertyDescriptor","notifyInSync","pendingVersion","resolve","mutableSourceCache","getMutableSource","useProxy","options","affected","lastAffected","prevSnapshot","deepChangedCache","nextSnapshot","sync","cb","currSnapshot"],"mappings":"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","sourcesContent":["import { useRef, useCallback, useEffect, useMemo } from 'react';\nimport { markToTrack, getUntrackedObject, isDeepChanged, createDeepProxy } from 'proxy-compare';\nimport { useSubscription } from 'use-subscription';\n\n/*\nexport {\n  unstable_createMutableSource as createMutableSource,\n  unstable_useMutableSource as useMutableSource,\n} from 'react'\n*/\nconst TARGET = Symbol();\nconst GET_VERSION = Symbol();\nconst createMutableSource = (target, getVersion) => ({\n  [TARGET]: target,\n  [GET_VERSION]: getVersion\n});\nconst useMutableSource = (source, getSnapshot, subscribe) => {\n  const lastVersion = useRef(0);\n  const versionDiff = source[GET_VERSION](source[TARGET]) - lastVersion.current; // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  const getCurrentValue = useCallback(() => getSnapshot(source[TARGET]), [source, getSnapshot, versionDiff]);\n  const sub = useCallback(callback => subscribe(source[TARGET], () => {\n    lastVersion.current = source[GET_VERSION](source[TARGET]);\n    callback();\n  }), [source, subscribe]);\n  useEffect(() => {\n    lastVersion.current = source[GET_VERSION](source[TARGET]);\n  });\n  return useSubscription({\n    getCurrentValue,\n    subscribe: sub\n  });\n};\n\nconst VERSION = Symbol();\nconst LISTENERS = Symbol();\nconst SNAPSHOT = Symbol();\nconst PROMISE_RESULT = Symbol();\nconst PROMISE_ERROR = Symbol();\n\nconst isSupportedObject = x => typeof x === 'object' && x !== null && (Array.isArray(x) || !x[Symbol.iterator]) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer);\n\nconst proxyCache = new WeakMap();\nlet globalVersion = 1;\nconst snapshotCache = new WeakMap();\nconst proxy = (initialObject = {}) => {\n  if (!isSupportedObject(initialObject)) {\n    throw new Error('unsupported object type');\n  }\n\n  if (proxyCache.has(initialObject)) {\n    return proxyCache.get(initialObject);\n  }\n\n  let version = globalVersion;\n  const listeners = new Set();\n\n  const notifyUpdate = nextVersion => {\n    if (!nextVersion) {\n      nextVersion = ++globalVersion;\n    }\n\n    if (version !== nextVersion) {\n      version = nextVersion;\n      listeners.forEach(listener => listener(nextVersion));\n    }\n  };\n\n  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));\n  const p = new Proxy(baseObject, {\n    get(target, prop, receiver) {\n      if (prop === VERSION) {\n        return version;\n      }\n\n      if (prop === LISTENERS) {\n        return listeners;\n      }\n\n      if (prop === SNAPSHOT) {\n        const cache = snapshotCache.get(receiver);\n\n        if (cache && cache.version === version) {\n          return cache.snapshot;\n        }\n\n        const snapshot = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));\n        markToTrack(snapshot);\n        snapshotCache.set(receiver, {\n          version,\n          snapshot\n        });\n        Reflect.ownKeys(target).forEach(key => {\n          const value = target[key];\n\n          if (!isSupportedObject(value)) {\n            snapshot[key] = value;\n          } else if (value instanceof Promise) {\n            if (value[PROMISE_RESULT]) {\n              snapshot[key] = value[PROMISE_RESULT];\n            } else {\n              const errorOrPromise = value[PROMISE_ERROR] || value;\n              Object.defineProperty(snapshot, key, {\n                get() {\n                  throw errorOrPromise;\n                }\n\n              });\n            }\n          } else if (value[VERSION]) {\n            snapshot[key] = value[SNAPSHOT];\n          } else {\n            snapshot[key] = value;\n          }\n        });\n\n        if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n          Object.freeze(snapshot);\n        }\n\n        return snapshot;\n      }\n\n      return target[prop];\n    },\n\n    deleteProperty(target, prop) {\n      const prevValue = target[prop];\n      const childListeners = isSupportedObject(prevValue) && prevValue[LISTENERS];\n\n      if (childListeners) {\n        childListeners.delete(notifyUpdate);\n      }\n\n      const deleted = Reflect.deleteProperty(target, prop);\n\n      if (deleted) {\n        notifyUpdate();\n      }\n\n      return deleted;\n    },\n\n    set(target, prop, value) {\n      const prevValue = target[prop];\n\n      if (Object.is(prevValue, value)) {\n        return true;\n      }\n\n      const childListeners = isSupportedObject(prevValue) && prevValue[LISTENERS];\n\n      if (childListeners) {\n        childListeners.delete(notifyUpdate);\n      }\n\n      if (!isSupportedObject(value)) {\n        target[prop] = value;\n      } else if (value instanceof Promise) {\n        target[prop] = value.then(v => {\n          target[prop][PROMISE_RESULT] = v;\n          notifyUpdate();\n        }).catch(e => {\n          target[prop][PROMISE_ERROR] = e;\n          notifyUpdate();\n        });\n      } else {\n        value = getUntrackedObject(value) || value;\n\n        if (value[LISTENERS]) {\n          target[prop] = value;\n        } else {\n          target[prop] = proxy(value);\n        }\n\n        target[prop][LISTENERS].add(notifyUpdate);\n      }\n\n      notifyUpdate();\n      return true;\n    }\n\n  });\n  proxyCache.set(initialObject, p);\n  Reflect.ownKeys(initialObject).forEach(key => {\n    const desc = Object.getOwnPropertyDescriptor(initialObject, key);\n\n    if (desc.get) {\n      Object.defineProperty(baseObject, key, desc);\n    } else {\n      p[key] = initialObject[key];\n    }\n  });\n  return p;\n};\nconst getVersion = p => {\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production' && (!p || !p[VERSION])) {\n    throw new Error('Please use proxy object');\n  }\n\n  return p[VERSION];\n};\nconst subscribe = (p, callback, notifyInSync) => {\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production' && (!p || !p[LISTENERS])) {\n    throw new Error('Please use proxy object');\n  }\n\n  let pendingVersion = 0;\n\n  const listener = nextVersion => {\n    if (notifyInSync) {\n      callback();\n      return;\n    }\n\n    pendingVersion = nextVersion;\n    Promise.resolve().then(() => {\n      if (nextVersion === pendingVersion) {\n        callback();\n      }\n    });\n  };\n\n  p[LISTENERS].add(listener);\n  return () => {\n    p[LISTENERS].delete(listener);\n  };\n};\nconst snapshot = p => {\n  if (typeof process === 'object' && process.env.NODE_ENV !== 'production' && (!p || !p[SNAPSHOT])) {\n    throw new Error('Please use proxy object');\n  }\n\n  return p[SNAPSHOT];\n};\n\nconst mutableSourceCache = new WeakMap();\n\nconst getMutableSource = p => {\n  if (!mutableSourceCache.has(p)) {\n    mutableSourceCache.set(p, createMutableSource(p, getVersion));\n  }\n\n  return mutableSourceCache.get(p);\n};\n\nconst useProxy = (p, options) => {\n  const affected = new WeakMap();\n  const lastAffected = useRef();\n  useEffect(() => {\n    lastAffected.current = affected;\n  });\n  const getSnapshot = useMemo(() => {\n    let prevSnapshot = null;\n    const deepChangedCache = new WeakMap();\n    return p => {\n      const nextSnapshot = snapshot(p);\n\n      try {\n        if (prevSnapshot !== null && lastAffected.current && !isDeepChanged(prevSnapshot, nextSnapshot, lastAffected.current, deepChangedCache)) {\n          // not changed\n          return prevSnapshot;\n        }\n      } catch (e) {// ignore and return new nextSnapshot\n      }\n\n      return prevSnapshot = nextSnapshot;\n    };\n  }, []);\n  const notifyInSync = options == null ? void 0 : options.sync;\n  const sub = useCallback((p, cb) => subscribe(p, cb, notifyInSync), [notifyInSync]);\n  const currSnapshot = useMutableSource(getMutableSource(p), getSnapshot, sub);\n  const proxyCache = useMemo(() => new WeakMap(), []); // per-hook proxyCache\n\n  return createDeepProxy(currSnapshot, affected, proxyCache);\n};\n\nexport { proxy, snapshot, subscribe, useProxy };\n"]},"metadata":{},"sourceType":"module"}