{"ast":null,"code":"import { BufferAttribute, BufferGeometry, InterleavedBuffer, InterleavedBufferAttribute, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, Vector2, Vector3 } from \"../../../build/three.module.js\";\nvar BufferGeometryUtils = {\n  computeTangents: function (geometry) {\n    var index = geometry.index;\n    var attributes = geometry.attributes; // based on http://www.terathon.com/code/tangent.html\n    // (per vertex tangents)\n\n    if (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {\n      console.error('THREE.BufferGeometryUtils: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');\n      return;\n    }\n\n    var indices = index.array;\n    var positions = attributes.position.array;\n    var normals = attributes.normal.array;\n    var uvs = attributes.uv.array;\n    var nVertices = positions.length / 3;\n\n    if (attributes.tangent === undefined) {\n      geometry.setAttribute('tangent', new BufferAttribute(new Float32Array(4 * nVertices), 4));\n    }\n\n    var tangents = attributes.tangent.array;\n    var tan1 = [],\n        tan2 = [];\n\n    for (var i = 0; i < nVertices; i++) {\n      tan1[i] = new Vector3();\n      tan2[i] = new Vector3();\n    }\n\n    var vA = new Vector3(),\n        vB = new Vector3(),\n        vC = new Vector3(),\n        uvA = new Vector2(),\n        uvB = new Vector2(),\n        uvC = new Vector2(),\n        sdir = new Vector3(),\n        tdir = new Vector3();\n\n    function handleTriangle(a, b, c) {\n      vA.fromArray(positions, a * 3);\n      vB.fromArray(positions, b * 3);\n      vC.fromArray(positions, c * 3);\n      uvA.fromArray(uvs, a * 2);\n      uvB.fromArray(uvs, b * 2);\n      uvC.fromArray(uvs, c * 2);\n      vB.sub(vA);\n      vC.sub(vA);\n      uvB.sub(uvA);\n      uvC.sub(uvA);\n      var r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y); // silently ignore degenerate uv triangles having coincident or colinear vertices\n\n      if (!isFinite(r)) return;\n      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);\n      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);\n      tan1[a].add(sdir);\n      tan1[b].add(sdir);\n      tan1[c].add(sdir);\n      tan2[a].add(tdir);\n      tan2[b].add(tdir);\n      tan2[c].add(tdir);\n    }\n\n    var groups = geometry.groups;\n\n    if (groups.length === 0) {\n      groups = [{\n        start: 0,\n        count: indices.length\n      }];\n    }\n\n    for (var i = 0, il = groups.length; i < il; ++i) {\n      var group = groups[i];\n      var start = group.start;\n      var count = group.count;\n\n      for (var j = start, jl = start + count; j < jl; j += 3) {\n        handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);\n      }\n    }\n\n    var tmp = new Vector3(),\n        tmp2 = new Vector3();\n    var n = new Vector3(),\n        n2 = new Vector3();\n    var w, t, test;\n\n    function handleVertex(v) {\n      n.fromArray(normals, v * 3);\n      n2.copy(n);\n      t = tan1[v]; // Gram-Schmidt orthogonalize\n\n      tmp.copy(t);\n      tmp.sub(n.multiplyScalar(n.dot(t))).normalize(); // Calculate handedness\n\n      tmp2.crossVectors(n2, t);\n      test = tmp2.dot(tan2[v]);\n      w = test < 0.0 ? -1.0 : 1.0;\n      tangents[v * 4] = tmp.x;\n      tangents[v * 4 + 1] = tmp.y;\n      tangents[v * 4 + 2] = tmp.z;\n      tangents[v * 4 + 3] = w;\n    }\n\n    for (var i = 0, il = groups.length; i < il; ++i) {\n      var group = groups[i];\n      var start = group.start;\n      var count = group.count;\n\n      for (var j = start, jl = start + count; j < jl; j += 3) {\n        handleVertex(indices[j + 0]);\n        handleVertex(indices[j + 1]);\n        handleVertex(indices[j + 2]);\n      }\n    }\n  },\n\n  /**\n   * @param  {Array<BufferGeometry>} geometries\n   * @param  {Boolean} useGroups\n   * @return {BufferGeometry}\n   */\n  mergeBufferGeometries: function (geometries, useGroups) {\n    var isIndexed = geometries[0].index !== null;\n    var attributesUsed = new Set(Object.keys(geometries[0].attributes));\n    var morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n    var attributes = {};\n    var morphAttributes = {};\n    var morphTargetsRelative = geometries[0].morphTargetsRelative;\n    var mergedGeometry = new BufferGeometry();\n    var offset = 0;\n\n    for (var i = 0; i < geometries.length; ++i) {\n      var geometry = geometries[i];\n      var attributesCount = 0; // ensure that all geometries are indexed, or none\n\n      if (isIndexed !== (geometry.index !== null)) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.');\n        return null;\n      } // gather attributes, exit early if they're different\n\n\n      for (var name in geometry.attributes) {\n        if (!attributesUsed.has(name)) {\n          console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.');\n          return null;\n        }\n\n        if (attributes[name] === undefined) attributes[name] = [];\n        attributes[name].push(geometry.attributes[name]);\n        attributesCount++;\n      } // ensure geometries have the same number of attributes\n\n\n      if (attributesCount !== attributesUsed.size) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.');\n        return null;\n      } // gather morph attributes, exit early if they're different\n\n\n      if (morphTargetsRelative !== geometry.morphTargetsRelative) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.');\n        return null;\n      }\n\n      for (var name in geometry.morphAttributes) {\n        if (!morphAttributesUsed.has(name)) {\n          console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.');\n          return null;\n        }\n\n        if (morphAttributes[name] === undefined) morphAttributes[name] = [];\n        morphAttributes[name].push(geometry.morphAttributes[name]);\n      } // gather .userData\n\n\n      mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n      mergedGeometry.userData.mergedUserData.push(geometry.userData);\n\n      if (useGroups) {\n        var count;\n\n        if (isIndexed) {\n          count = geometry.index.count;\n        } else if (geometry.attributes.position !== undefined) {\n          count = geometry.attributes.position.count;\n        } else {\n          console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute');\n          return null;\n        }\n\n        mergedGeometry.addGroup(offset, count, i);\n        offset += count;\n      }\n    } // merge indices\n\n\n    if (isIndexed) {\n      var indexOffset = 0;\n      var mergedIndex = [];\n\n      for (var i = 0; i < geometries.length; ++i) {\n        var index = geometries[i].index;\n\n        for (var j = 0; j < index.count; ++j) {\n          mergedIndex.push(index.getX(j) + indexOffset);\n        }\n\n        indexOffset += geometries[i].attributes.position.count;\n      }\n\n      mergedGeometry.setIndex(mergedIndex);\n    } // merge attributes\n\n\n    for (var name in attributes) {\n      var mergedAttribute = this.mergeBufferAttributes(attributes[name]);\n\n      if (!mergedAttribute) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.');\n        return null;\n      }\n\n      mergedGeometry.setAttribute(name, mergedAttribute);\n    } // merge morph attributes\n\n\n    for (var name in morphAttributes) {\n      var numMorphTargets = morphAttributes[name][0].length;\n      if (numMorphTargets === 0) break;\n      mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n      mergedGeometry.morphAttributes[name] = [];\n\n      for (var i = 0; i < numMorphTargets; ++i) {\n        var morphAttributesToMerge = [];\n\n        for (var j = 0; j < morphAttributes[name].length; ++j) {\n          morphAttributesToMerge.push(morphAttributes[name][j][i]);\n        }\n\n        var mergedMorphAttribute = this.mergeBufferAttributes(morphAttributesToMerge);\n\n        if (!mergedMorphAttribute) {\n          console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' morphAttribute.');\n          return null;\n        }\n\n        mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n      }\n    }\n\n    return mergedGeometry;\n  },\n\n  /**\n   * @param {Array<BufferAttribute>} attributes\n   * @return {BufferAttribute}\n   */\n  mergeBufferAttributes: function (attributes) {\n    var TypedArray;\n    var itemSize;\n    var normalized;\n    var arrayLength = 0;\n\n    for (var i = 0; i < attributes.length; ++i) {\n      var attribute = attributes[i];\n\n      if (attribute.isInterleavedBufferAttribute) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported.');\n        return null;\n      }\n\n      if (TypedArray === undefined) TypedArray = attribute.array.constructor;\n\n      if (TypedArray !== attribute.array.constructor) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.');\n        return null;\n      }\n\n      if (itemSize === undefined) itemSize = attribute.itemSize;\n\n      if (itemSize !== attribute.itemSize) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.');\n        return null;\n      }\n\n      if (normalized === undefined) normalized = attribute.normalized;\n\n      if (normalized !== attribute.normalized) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.');\n        return null;\n      }\n\n      arrayLength += attribute.array.length;\n    }\n\n    var array = new TypedArray(arrayLength);\n    var offset = 0;\n\n    for (var i = 0; i < attributes.length; ++i) {\n      array.set(attributes[i].array, offset);\n      offset += attributes[i].array.length;\n    }\n\n    return new BufferAttribute(array, itemSize, normalized);\n  },\n\n  /**\n   * @param {Array<BufferAttribute>} attributes\n   * @return {Array<InterleavedBufferAttribute>}\n   */\n  interleaveAttributes: function (attributes) {\n    // Interleaves the provided attributes into an InterleavedBuffer and returns\n    // a set of InterleavedBufferAttributes for each attribute\n    var TypedArray;\n    var arrayLength = 0;\n    var stride = 0; // calculate the the length and type of the interleavedBuffer\n\n    for (var i = 0, l = attributes.length; i < l; ++i) {\n      var attribute = attributes[i];\n      if (TypedArray === undefined) TypedArray = attribute.array.constructor;\n\n      if (TypedArray !== attribute.array.constructor) {\n        console.error('AttributeBuffers of different types cannot be interleaved');\n        return null;\n      }\n\n      arrayLength += attribute.array.length;\n      stride += attribute.itemSize;\n    } // Create the set of buffer attributes\n\n\n    var interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride);\n    var offset = 0;\n    var res = [];\n    var getters = ['getX', 'getY', 'getZ', 'getW'];\n    var setters = ['setX', 'setY', 'setZ', 'setW'];\n\n    for (var j = 0, l = attributes.length; j < l; j++) {\n      var attribute = attributes[j];\n      var itemSize = attribute.itemSize;\n      var count = attribute.count;\n      var iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\n      res.push(iba);\n      offset += itemSize; // Move the data for each attribute into the new interleavedBuffer\n      // at the appropriate offset\n\n      for (var c = 0; c < count; c++) {\n        for (var k = 0; k < itemSize; k++) {\n          iba[setters[k]](c, attribute[getters[k]](c));\n        }\n      }\n    }\n\n    return res;\n  },\n\n  /**\n   * @param {Array<BufferGeometry>} geometry\n   * @return {number}\n   */\n  estimateBytesUsed: function (geometry) {\n    // Return the estimated memory used by this geometry in bytes\n    // Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n    // for InterleavedBufferAttributes.\n    var mem = 0;\n\n    for (var name in geometry.attributes) {\n      var attr = geometry.getAttribute(name);\n      mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n    }\n\n    var indices = geometry.getIndex();\n    mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n    return mem;\n  },\n\n  /**\n   * @param {BufferGeometry} geometry\n   * @param {number} tolerance\n   * @return {BufferGeometry>}\n   */\n  mergeVertices: function (geometry, tolerance = 1e-4) {\n    tolerance = Math.max(tolerance, Number.EPSILON); // Generate an index buffer if the geometry doesn't have one, or optimize it\n    // if it's already available.\n\n    var hashToIndex = {};\n    var indices = geometry.getIndex();\n    var positions = geometry.getAttribute('position');\n    var vertexCount = indices ? indices.count : positions.count; // next value for triangle indices\n\n    var nextIndex = 0; // attributes and new attribute arrays\n\n    var attributeNames = Object.keys(geometry.attributes);\n    var attrArrays = {};\n    var morphAttrsArrays = {};\n    var newIndices = [];\n    var getters = ['getX', 'getY', 'getZ', 'getW']; // initialize the arrays\n\n    for (var i = 0, l = attributeNames.length; i < l; i++) {\n      var name = attributeNames[i];\n      attrArrays[name] = [];\n      var morphAttr = geometry.morphAttributes[name];\n\n      if (morphAttr) {\n        morphAttrsArrays[name] = new Array(morphAttr.length).fill().map(() => []);\n      }\n    } // convert the error tolerance to an amount of decimal places to truncate to\n\n\n    var decimalShift = Math.log10(1 / tolerance);\n    var shiftMultiplier = Math.pow(10, decimalShift);\n\n    for (var i = 0; i < vertexCount; i++) {\n      var index = indices ? indices.getX(i) : i; // Generate a hash for the vertex attributes at the current index 'i'\n\n      var hash = '';\n\n      for (var j = 0, l = attributeNames.length; j < l; j++) {\n        var name = attributeNames[j];\n        var attribute = geometry.getAttribute(name);\n        var itemSize = attribute.itemSize;\n\n        for (var k = 0; k < itemSize; k++) {\n          // double tilde truncates the decimal value\n          hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`;\n        }\n      } // Add another reference to the vertex if it's already\n      // used by another index\n\n\n      if (hash in hashToIndex) {\n        newIndices.push(hashToIndex[hash]);\n      } else {\n        // copy data to the new index in the attribute arrays\n        for (var j = 0, l = attributeNames.length; j < l; j++) {\n          var name = attributeNames[j];\n          var attribute = geometry.getAttribute(name);\n          var morphAttr = geometry.morphAttributes[name];\n          var itemSize = attribute.itemSize;\n          var newarray = attrArrays[name];\n          var newMorphArrays = morphAttrsArrays[name];\n\n          for (var k = 0; k < itemSize; k++) {\n            var getterFunc = getters[k];\n            newarray.push(attribute[getterFunc](index));\n\n            if (morphAttr) {\n              for (var m = 0, ml = morphAttr.length; m < ml; m++) {\n                newMorphArrays[m].push(morphAttr[m][getterFunc](index));\n              }\n            }\n          }\n        }\n\n        hashToIndex[hash] = nextIndex;\n        newIndices.push(nextIndex);\n        nextIndex++;\n      }\n    } // Generate typed arrays from new attribute arrays and update\n    // the attributeBuffers\n\n\n    const result = geometry.clone();\n\n    for (var i = 0, l = attributeNames.length; i < l; i++) {\n      var name = attributeNames[i];\n      var oldAttribute = geometry.getAttribute(name);\n      var buffer = new oldAttribute.array.constructor(attrArrays[name]);\n      var attribute = new BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\n      result.setAttribute(name, attribute); // Update the attribute arrays\n\n      if (name in morphAttrsArrays) {\n        for (var j = 0; j < morphAttrsArrays[name].length; j++) {\n          var oldMorphAttribute = geometry.morphAttributes[name][j];\n          var buffer = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);\n          var morphAttribute = new BufferAttribute(buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\n          result.morphAttributes[name][j] = morphAttribute;\n        }\n      }\n    } // indices\n\n\n    result.setIndex(newIndices);\n    return result;\n  },\n\n  /**\n   * @param {BufferGeometry} geometry\n   * @param {number} drawMode\n   * @return {BufferGeometry>}\n   */\n  toTrianglesDrawMode: function (geometry, drawMode) {\n    if (drawMode === TrianglesDrawMode) {\n      console.warn('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.');\n      return geometry;\n    }\n\n    if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {\n      var index = geometry.getIndex(); // generate index if not present\n\n      if (index === null) {\n        var indices = [];\n        var position = geometry.getAttribute('position');\n\n        if (position !== undefined) {\n          for (var i = 0; i < position.count; i++) {\n            indices.push(i);\n          }\n\n          geometry.setIndex(indices);\n          index = geometry.getIndex();\n        } else {\n          console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');\n          return geometry;\n        }\n      } //\n\n\n      var numberOfTriangles = index.count - 2;\n      var newIndices = [];\n\n      if (drawMode === TriangleFanDrawMode) {\n        // gl.TRIANGLE_FAN\n        for (var i = 1; i <= numberOfTriangles; i++) {\n          newIndices.push(index.getX(0));\n          newIndices.push(index.getX(i));\n          newIndices.push(index.getX(i + 1));\n        }\n      } else {\n        // gl.TRIANGLE_STRIP\n        for (var i = 0; i < numberOfTriangles; i++) {\n          if (i % 2 === 0) {\n            newIndices.push(index.getX(i));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i + 2));\n          } else {\n            newIndices.push(index.getX(i + 2));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i));\n          }\n        }\n      }\n\n      if (newIndices.length / 3 !== numberOfTriangles) {\n        console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');\n      } // build final geometry\n\n\n      var newGeometry = geometry.clone();\n      newGeometry.setIndex(newIndices);\n      newGeometry.clearGroups();\n      return newGeometry;\n    } else {\n      console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode);\n      return geometry;\n    }\n  }\n};\nexport { BufferGeometryUtils };","map":{"version":3,"sources":["/Users/haiakablan/Documents/לוטוס/קורס/Architecture-web/node_modules/three/examples/jsm/utils/BufferGeometryUtils.js"],"names":["BufferAttribute","BufferGeometry","InterleavedBuffer","InterleavedBufferAttribute","TriangleFanDrawMode","TriangleStripDrawMode","TrianglesDrawMode","Vector2","Vector3","BufferGeometryUtils","computeTangents","geometry","index","attributes","position","undefined","normal","uv","console","error","indices","array","positions","normals","uvs","nVertices","length","tangent","setAttribute","Float32Array","tangents","tan1","tan2","i","vA","vB","vC","uvA","uvB","uvC","sdir","tdir","handleTriangle","a","b","c","fromArray","sub","r","x","y","isFinite","copy","multiplyScalar","addScaledVector","add","groups","start","count","il","group","j","jl","tmp","tmp2","n","n2","w","t","test","handleVertex","v","dot","normalize","crossVectors","z","mergeBufferGeometries","geometries","useGroups","isIndexed","attributesUsed","Set","Object","keys","morphAttributesUsed","morphAttributes","morphTargetsRelative","mergedGeometry","offset","attributesCount","name","has","push","size","userData","mergedUserData","addGroup","indexOffset","mergedIndex","getX","setIndex","mergedAttribute","mergeBufferAttributes","numMorphTargets","morphAttributesToMerge","mergedMorphAttribute","TypedArray","itemSize","normalized","arrayLength","attribute","isInterleavedBufferAttribute","constructor","set","interleaveAttributes","stride","l","interleavedBuffer","res","getters","setters","iba","k","estimateBytesUsed","mem","attr","getAttribute","BYTES_PER_ELEMENT","getIndex","mergeVertices","tolerance","Math","max","Number","EPSILON","hashToIndex","vertexCount","nextIndex","attributeNames","attrArrays","morphAttrsArrays","newIndices","morphAttr","Array","fill","map","decimalShift","log10","shiftMultiplier","pow","hash","newarray","newMorphArrays","getterFunc","m","ml","result","clone","oldAttribute","buffer","oldMorphAttribute","morphAttribute","toTrianglesDrawMode","drawMode","warn","numberOfTriangles","newGeometry","clearGroups"],"mappings":"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","sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tTrianglesDrawMode,\n\tVector2,\n\tVector3\n} from \"../../../build/three.module.js\";\n\nvar BufferGeometryUtils = {\n\n\tcomputeTangents: function ( geometry ) {\n\n\t\tvar index = geometry.index;\n\t\tvar attributes = geometry.attributes;\n\n\t\t// based on http://www.terathon.com/code/tangent.html\n\t\t// (per vertex tangents)\n\n\t\tif ( index === null ||\n\t\t\t attributes.position === undefined ||\n\t\t\t attributes.normal === undefined ||\n\t\t\t attributes.uv === undefined ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar indices = index.array;\n\t\tvar positions = attributes.position.array;\n\t\tvar normals = attributes.normal.array;\n\t\tvar uvs = attributes.uv.array;\n\n\t\tvar nVertices = positions.length / 3;\n\n\t\tif ( attributes.tangent === undefined ) {\n\n\t\t\tgeometry.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );\n\n\t\t}\n\n\t\tvar tangents = attributes.tangent.array;\n\n\t\tvar tan1 = [], tan2 = [];\n\n\t\tfor ( var i = 0; i < nVertices; i ++ ) {\n\n\t\t\ttan1[ i ] = new Vector3();\n\t\t\ttan2[ i ] = new Vector3();\n\n\t\t}\n\n\t\tvar vA = new Vector3(),\n\t\t\tvB = new Vector3(),\n\t\t\tvC = new Vector3(),\n\n\t\t\tuvA = new Vector2(),\n\t\t\tuvB = new Vector2(),\n\t\t\tuvC = new Vector2(),\n\n\t\t\tsdir = new Vector3(),\n\t\t\ttdir = new Vector3();\n\n\t\tfunction handleTriangle( a, b, c ) {\n\n\t\t\tvA.fromArray( positions, a * 3 );\n\t\t\tvB.fromArray( positions, b * 3 );\n\t\t\tvC.fromArray( positions, c * 3 );\n\n\t\t\tuvA.fromArray( uvs, a * 2 );\n\t\t\tuvB.fromArray( uvs, b * 2 );\n\t\t\tuvC.fromArray( uvs, c * 2 );\n\n\t\t\tvB.sub( vA );\n\t\t\tvC.sub( vA );\n\n\t\t\tuvB.sub( uvA );\n\t\t\tuvC.sub( uvA );\n\n\t\t\tvar r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );\n\n\t\t\t// silently ignore degenerate uv triangles having coincident or colinear vertices\n\n\t\t\tif ( ! isFinite( r ) ) return;\n\n\t\t\tsdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );\n\t\t\ttdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );\n\n\t\t\ttan1[ a ].add( sdir );\n\t\t\ttan1[ b ].add( sdir );\n\t\t\ttan1[ c ].add( sdir );\n\n\t\t\ttan2[ a ].add( tdir );\n\t\t\ttan2[ b ].add( tdir );\n\t\t\ttan2[ c ].add( tdir );\n\n\t\t}\n\n\t\tvar groups = geometry.groups;\n\n\t\tif ( groups.length === 0 ) {\n\n\t\t\tgroups = [ {\n\t\t\t\tstart: 0,\n\t\t\t\tcount: indices.length\n\t\t\t} ];\n\n\t\t}\n\n\t\tfor ( var i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tvar group = groups[ i ];\n\n\t\t\tvar start = group.start;\n\t\t\tvar count = group.count;\n\n\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleTriangle(\n\t\t\t\t\tindices[ j + 0 ],\n\t\t\t\t\tindices[ j + 1 ],\n\t\t\t\t\tindices[ j + 2 ]\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar tmp = new Vector3(), tmp2 = new Vector3();\n\t\tvar n = new Vector3(), n2 = new Vector3();\n\t\tvar w, t, test;\n\n\t\tfunction handleVertex( v ) {\n\n\t\t\tn.fromArray( normals, v * 3 );\n\t\t\tn2.copy( n );\n\n\t\t\tt = tan1[ v ];\n\n\t\t\t// Gram-Schmidt orthogonalize\n\n\t\t\ttmp.copy( t );\n\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\n\n\t\t\t// Calculate handedness\n\n\t\t\ttmp2.crossVectors( n2, t );\n\t\t\ttest = tmp2.dot( tan2[ v ] );\n\t\t\tw = ( test < 0.0 ) ? - 1.0 : 1.0;\n\n\t\t\ttangents[ v * 4 ] = tmp.x;\n\t\t\ttangents[ v * 4 + 1 ] = tmp.y;\n\t\t\ttangents[ v * 4 + 2 ] = tmp.z;\n\t\t\ttangents[ v * 4 + 3 ] = w;\n\n\t\t}\n\n\t\tfor ( var i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tvar group = groups[ i ];\n\n\t\t\tvar start = group.start;\n\t\t\tvar count = group.count;\n\n\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleVertex( indices[ j + 0 ] );\n\t\t\t\thandleVertex( indices[ j + 1 ] );\n\t\t\t\thandleVertex( indices[ j + 2 ] );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t/**\n\t * @param  {Array<BufferGeometry>} geometries\n\t * @param  {Boolean} useGroups\n\t * @return {BufferGeometry}\n\t */\n\tmergeBufferGeometries: function ( geometries, useGroups ) {\n\n\t\tvar isIndexed = geometries[ 0 ].index !== null;\n\n\t\tvar attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\t\tvar morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );\n\n\t\tvar attributes = {};\n\t\tvar morphAttributes = {};\n\n\t\tvar morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;\n\n\t\tvar mergedGeometry = new BufferGeometry();\n\n\t\tvar offset = 0;\n\n\t\tfor ( var i = 0; i < geometries.length; ++ i ) {\n\n\t\t\tvar geometry = geometries[ i ];\n\t\t\tvar attributesCount = 0;\n\n\t\t\t// ensure that all geometries are indexed, or none\n\n\t\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// gather attributes, exit early if they're different\n\n\t\t\tfor ( var name in geometry.attributes ) {\n\n\t\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tif ( attributes[ name ] === undefined ) attributes[ name ] = [];\n\n\t\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\n\t\t\t\tattributesCount ++;\n\n\t\t\t}\n\n\t\t\t// ensure geometries have the same number of attributes\n\n\t\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// gather morph attributes, exit early if they're different\n\n\t\t\tif ( morphTargetsRelative !== geometry.morphTargetsRelative ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tfor ( var name in geometry.morphAttributes ) {\n\n\t\t\t\tif ( ! morphAttributesUsed.has( name ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tif ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];\n\n\t\t\t\tmorphAttributes[ name ].push( geometry.morphAttributes[ name ] );\n\n\t\t\t}\n\n\t\t\t// gather .userData\n\n\t\t\tmergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n\t\t\tmergedGeometry.userData.mergedUserData.push( geometry.userData );\n\n\t\t\tif ( useGroups ) {\n\n\t\t\t\tvar count;\n\n\t\t\t\tif ( isIndexed ) {\n\n\t\t\t\t\tcount = geometry.index.count;\n\n\t\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tmergedGeometry.addGroup( offset, count, i );\n\n\t\t\t\toffset += count;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// merge indices\n\n\t\tif ( isIndexed ) {\n\n\t\t\tvar indexOffset = 0;\n\t\t\tvar mergedIndex = [];\n\n\t\t\tfor ( var i = 0; i < geometries.length; ++ i ) {\n\n\t\t\t\tvar index = geometries[ i ].index;\n\n\t\t\t\tfor ( var j = 0; j < index.count; ++ j ) {\n\n\t\t\t\t\tmergedIndex.push( index.getX( j ) + indexOffset );\n\n\t\t\t\t}\n\n\t\t\t\tindexOffset += geometries[ i ].attributes.position.count;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.setIndex( mergedIndex );\n\n\t\t}\n\n\t\t// merge attributes\n\n\t\tfor ( var name in attributes ) {\n\n\t\t\tvar mergedAttribute = this.mergeBufferAttributes( attributes[ name ] );\n\n\t\t\tif ( ! mergedAttribute ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.setAttribute( name, mergedAttribute );\n\n\t\t}\n\n\t\t// merge morph attributes\n\n\t\tfor ( var name in morphAttributes ) {\n\n\t\t\tvar numMorphTargets = morphAttributes[ name ][ 0 ].length;\n\n\t\t\tif ( numMorphTargets === 0 ) break;\n\n\t\t\tmergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n\t\t\tmergedGeometry.morphAttributes[ name ] = [];\n\n\t\t\tfor ( var i = 0; i < numMorphTargets; ++ i ) {\n\n\t\t\t\tvar morphAttributesToMerge = [];\n\n\t\t\t\tfor ( var j = 0; j < morphAttributes[ name ].length; ++ j ) {\n\n\t\t\t\t\tmorphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tvar mergedMorphAttribute = this.mergeBufferAttributes( morphAttributesToMerge );\n\n\t\t\t\tif ( ! mergedMorphAttribute ) {\n\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tmergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn mergedGeometry;\n\n\t},\n\n\t/**\n\t * @param {Array<BufferAttribute>} attributes\n\t * @return {BufferAttribute}\n\t */\n\tmergeBufferAttributes: function ( attributes ) {\n\n\t\tvar TypedArray;\n\t\tvar itemSize;\n\t\tvar normalized;\n\t\tvar arrayLength = 0;\n\n\t\tfor ( var i = 0; i < attributes.length; ++ i ) {\n\n\t\t\tvar attribute = attributes[ i ];\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( itemSize === undefined ) itemSize = attribute.itemSize;\n\t\t\tif ( itemSize !== attribute.itemSize ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( normalized === undefined ) normalized = attribute.normalized;\n\t\t\tif ( normalized !== attribute.normalized ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tarrayLength += attribute.array.length;\n\n\t\t}\n\n\t\tvar array = new TypedArray( arrayLength );\n\t\tvar offset = 0;\n\n\t\tfor ( var i = 0; i < attributes.length; ++ i ) {\n\n\t\t\tarray.set( attributes[ i ].array, offset );\n\n\t\t\toffset += attributes[ i ].array.length;\n\n\t\t}\n\n\t\treturn new BufferAttribute( array, itemSize, normalized );\n\n\t},\n\n\t/**\n\t * @param {Array<BufferAttribute>} attributes\n\t * @return {Array<InterleavedBufferAttribute>}\n\t */\n\tinterleaveAttributes: function ( attributes ) {\n\n\t\t// Interleaves the provided attributes into an InterleavedBuffer and returns\n\t\t// a set of InterleavedBufferAttributes for each attribute\n\t\tvar TypedArray;\n\t\tvar arrayLength = 0;\n\t\tvar stride = 0;\n\n\t\t// calculate the the length and type of the interleavedBuffer\n\t\tfor ( var i = 0, l = attributes.length; i < l; ++ i ) {\n\n\t\t\tvar attribute = attributes[ i ];\n\n\t\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\t\tconsole.error( 'AttributeBuffers of different types cannot be interleaved' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tarrayLength += attribute.array.length;\n\t\t\tstride += attribute.itemSize;\n\n\t\t}\n\n\t\t// Create the set of buffer attributes\n\t\tvar interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride );\n\t\tvar offset = 0;\n\t\tvar res = [];\n\t\tvar getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\t\tvar setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\t\tfor ( var j = 0, l = attributes.length; j < l; j ++ ) {\n\n\t\t\tvar attribute = attributes[ j ];\n\t\t\tvar itemSize = attribute.itemSize;\n\t\t\tvar count = attribute.count;\n\t\t\tvar iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );\n\t\t\tres.push( iba );\n\n\t\t\toffset += itemSize;\n\n\t\t\t// Move the data for each attribute into the new interleavedBuffer\n\t\t\t// at the appropriate offset\n\t\t\tfor ( var c = 0; c < count; c ++ ) {\n\n\t\t\t\tfor ( var k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\tiba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn res;\n\n\t},\n\n\t/**\n\t * @param {Array<BufferGeometry>} geometry\n\t * @return {number}\n\t */\n\testimateBytesUsed: function ( geometry ) {\n\n\t\t// Return the estimated memory used by this geometry in bytes\n\t\t// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n\t\t// for InterleavedBufferAttributes.\n\t\tvar mem = 0;\n\t\tfor ( var name in geometry.attributes ) {\n\n\t\t\tvar attr = geometry.getAttribute( name );\n\t\t\tmem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n\n\t\t}\n\n\t\tvar indices = geometry.getIndex();\n\t\tmem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n\t\treturn mem;\n\n\t},\n\n\t/**\n\t * @param {BufferGeometry} geometry\n\t * @param {number} tolerance\n\t * @return {BufferGeometry>}\n\t */\n\tmergeVertices: function ( geometry, tolerance = 1e-4 ) {\n\n\t\ttolerance = Math.max( tolerance, Number.EPSILON );\n\n\t\t// Generate an index buffer if the geometry doesn't have one, or optimize it\n\t\t// if it's already available.\n\t\tvar hashToIndex = {};\n\t\tvar indices = geometry.getIndex();\n\t\tvar positions = geometry.getAttribute( 'position' );\n\t\tvar vertexCount = indices ? indices.count : positions.count;\n\n\t\t// next value for triangle indices\n\t\tvar nextIndex = 0;\n\n\t\t// attributes and new attribute arrays\n\t\tvar attributeNames = Object.keys( geometry.attributes );\n\t\tvar attrArrays = {};\n\t\tvar morphAttrsArrays = {};\n\t\tvar newIndices = [];\n\t\tvar getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\n\t\t// initialize the arrays\n\t\tfor ( var i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\t\tvar name = attributeNames[ i ];\n\n\t\t\tattrArrays[ name ] = [];\n\n\t\t\tvar morphAttr = geometry.morphAttributes[ name ];\n\t\t\tif ( morphAttr ) {\n\n\t\t\t\tmorphAttrsArrays[ name ] = new Array( morphAttr.length ).fill().map( () => [] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// convert the error tolerance to an amount of decimal places to truncate to\n\t\tvar decimalShift = Math.log10( 1 / tolerance );\n\t\tvar shiftMultiplier = Math.pow( 10, decimalShift );\n\t\tfor ( var i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tvar index = indices ? indices.getX( i ) : i;\n\n\t\t\t// Generate a hash for the vertex attributes at the current index 'i'\n\t\t\tvar hash = '';\n\t\t\tfor ( var j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\tvar name = attributeNames[ j ];\n\t\t\t\tvar attribute = geometry.getAttribute( name );\n\t\t\t\tvar itemSize = attribute.itemSize;\n\n\t\t\t\tfor ( var k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\t// double tilde truncates the decimal value\n\t\t\t\t\thash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * shiftMultiplier ) },`;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Add another reference to the vertex if it's already\n\t\t\t// used by another index\n\t\t\tif ( hash in hashToIndex ) {\n\n\t\t\t\tnewIndices.push( hashToIndex[ hash ] );\n\n\t\t\t} else {\n\n\t\t\t\t// copy data to the new index in the attribute arrays\n\t\t\t\tfor ( var j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\t\tvar name = attributeNames[ j ];\n\t\t\t\t\tvar attribute = geometry.getAttribute( name );\n\t\t\t\t\tvar morphAttr = geometry.morphAttributes[ name ];\n\t\t\t\t\tvar itemSize = attribute.itemSize;\n\t\t\t\t\tvar newarray = attrArrays[ name ];\n\t\t\t\t\tvar newMorphArrays = morphAttrsArrays[ name ];\n\n\t\t\t\t\tfor ( var k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\t\tvar getterFunc = getters[ k ];\n\t\t\t\t\t\tnewarray.push( attribute[ getterFunc ]( index ) );\n\n\t\t\t\t\t\tif ( morphAttr ) {\n\n\t\t\t\t\t\t\tfor ( var m = 0, ml = morphAttr.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\t\tnewMorphArrays[ m ].push( morphAttr[ m ][ getterFunc ]( index ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\thashToIndex[ hash ] = nextIndex;\n\t\t\t\tnewIndices.push( nextIndex );\n\t\t\t\tnextIndex ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Generate typed arrays from new attribute arrays and update\n\t\t// the attributeBuffers\n\t\tconst result = geometry.clone();\n\t\tfor ( var i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\t\tvar name = attributeNames[ i ];\n\t\t\tvar oldAttribute = geometry.getAttribute( name );\n\n\t\t\tvar buffer = new oldAttribute.array.constructor( attrArrays[ name ] );\n\t\t\tvar attribute = new BufferAttribute( buffer, oldAttribute.itemSize, oldAttribute.normalized );\n\n\t\t\tresult.setAttribute( name, attribute );\n\n\t\t\t// Update the attribute arrays\n\t\t\tif ( name in morphAttrsArrays ) {\n\n\t\t\t\tfor ( var j = 0; j < morphAttrsArrays[ name ].length; j ++ ) {\n\n\t\t\t\t\tvar oldMorphAttribute = geometry.morphAttributes[ name ][ j ];\n\n\t\t\t\t\tvar buffer = new oldMorphAttribute.array.constructor( morphAttrsArrays[ name ][ j ] );\n\t\t\t\t\tvar morphAttribute = new BufferAttribute( buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized );\n\t\t\t\t\tresult.morphAttributes[ name ][ j ] = morphAttribute;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// indices\n\n\t\tresult.setIndex( newIndices );\n\n\t\treturn result;\n\n\t},\n\n\t/**\n\t * @param {BufferGeometry} geometry\n\t * @param {number} drawMode\n\t * @return {BufferGeometry>}\n\t */\n\ttoTrianglesDrawMode: function ( geometry, drawMode ) {\n\n\t\tif ( drawMode === TrianglesDrawMode ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tif ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {\n\n\t\t\tvar index = geometry.getIndex();\n\n\t\t\t// generate index if not present\n\n\t\t\tif ( index === null ) {\n\n\t\t\t\tvar indices = [];\n\n\t\t\t\tvar position = geometry.getAttribute( 'position' );\n\n\t\t\t\tif ( position !== undefined ) {\n\n\t\t\t\t\tfor ( var i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\t\tindices.push( i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\t\treturn geometry;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar numberOfTriangles = index.count - 2;\n\t\t\tvar newIndices = [];\n\n\t\t\tif ( drawMode === TriangleFanDrawMode ) {\n\n\t\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\t\tfor ( var i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\t\tfor ( var i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t\t}\n\n\t\t\t// build final geometry\n\n\t\t\tvar newGeometry = geometry.clone();\n\t\t\tnewGeometry.setIndex( newIndices );\n\t\t\tnewGeometry.clearGroups();\n\n\t\t\treturn newGeometry;\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );\n\t\t\treturn geometry;\n\n\t\t}\n\n\t}\n\n};\n\nexport { BufferGeometryUtils };\n"]},"metadata":{},"sourceType":"module"}