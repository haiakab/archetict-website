{"ast":null,"code":"import { ShaderChunk, MathUtils, UniformsUtils, MeshDepthMaterial, RGBADepthPacking, MeshDistanceMaterial, ShaderLib, DataTexture, Vector3, Mesh, CylinderBufferGeometry, Vector2, MeshStandardMaterial, DoubleSide } from 'three';\n/**\r\n * Regular expression for matching the `void main() {` opener line in GLSL.\r\n * @type {RegExp}\r\n */\n\nconst voidMainRegExp = /\\bvoid\\s+main\\s*\\(\\s*\\)\\s*{/g;\n/**\r\n * Recursively expands all `#include <xyz>` statements within string of shader code.\r\n * Copied from three's WebGLProgram#parseIncludes for external use.\r\n *\r\n * @param {string} source - The GLSL source code to evaluate\r\n * @return {string} The GLSL code with all includes expanded\r\n */\n\nfunction expandShaderIncludes(source) {\n  const pattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n\n  function replace(match, include) {\n    let chunk = ShaderChunk[include];\n    return chunk ? expandShaderIncludes(chunk) : match;\n  }\n\n  return source.replace(pattern, replace);\n} // Local assign polyfill to avoid importing troika-core\n\n\nconst assign = Object.assign || function ()\n/*target, ...sources*/\n{\n  let target = arguments[0];\n\n  for (let i = 1, len = arguments.length; i < len; i++) {\n    let source = arguments[i];\n\n    if (source) {\n      for (let prop in source) {\n        if (source.hasOwnProperty(prop)) {\n          target[prop] = source[prop];\n        }\n      }\n    }\n  }\n\n  return target;\n};\n\nconst epoch = Date.now();\nconst CONSTRUCTOR_CACHE = new WeakMap();\nconst SHADER_UPGRADE_CACHE = new Map(); // Material ids must be integers, but we can't access the increment from Three's `Material` module,\n// so let's choose a sufficiently large starting value that should theoretically never collide.\n\nlet materialInstanceId = 1e10;\n/**\r\n * A utility for creating a custom shader material derived from another material's\r\n * shaders. This allows you to inject custom shader logic and transforms into the\r\n * builtin ThreeJS materials without having to recreate them from scratch.\r\n *\r\n * @param {THREE.Material} baseMaterial - the original material to derive from\r\n *\r\n * @param {Object} options - How the base material should be modified.\r\n * @param {Object} options.defines - Custom `defines` for the material\r\n * @param {Object} options.extensions - Custom `extensions` for the material, e.g. `{derivatives: true}`\r\n * @param {Object} options.uniforms - Custom `uniforms` for use in the modified shader. These can\r\n *        be accessed and manipulated via the resulting material's `uniforms` property, just like\r\n *        in a ShaderMaterial. You do not need to repeat the base material's own uniforms here.\r\n * @param {String} options.timeUniform - If specified, a uniform of this name will be injected into\r\n *        both shaders, and it will automatically be updated on each render frame with a number of\r\n *        elapsed milliseconds. The \"zero\" epoch time is not significant so don't rely on this as a\r\n *        true calendar time.\r\n * @param {String} options.vertexDefs - Custom GLSL code to inject into the vertex shader's top-level\r\n *        definitions, above the `void main()` function.\r\n * @param {String} options.vertexMainIntro - Custom GLSL code to inject at the top of the vertex\r\n *        shader's `void main` function.\r\n * @param {String} options.vertexMainOutro - Custom GLSL code to inject at the end of the vertex\r\n *        shader's `void main` function.\r\n * @param {String} options.vertexTransform - Custom GLSL code to manipulate the `position`, `normal`,\r\n *        and/or `uv` vertex attributes. This code will be wrapped within a standalone function with\r\n *        those attributes exposed by their normal names as read/write values.\r\n * @param {String} options.fragmentDefs - Custom GLSL code to inject into the fragment shader's top-level\r\n *        definitions, above the `void main()` function.\r\n * @param {String} options.fragmentMainIntro - Custom GLSL code to inject at the top of the fragment\r\n *        shader's `void main` function.\r\n * @param {String} options.fragmentMainOutro - Custom GLSL code to inject at the end of the fragment\r\n *        shader's `void main` function. You can manipulate `gl_FragColor` here but keep in mind it goes\r\n *        after any of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), so if you\r\n *        want those to apply to your changes use `fragmentColorTransform` instead.\r\n * @param {String} options.fragmentColorTransform - Custom GLSL code to manipulate the `gl_FragColor`\r\n *        output value. Will be injected near the end of the `void main` function, but before any\r\n *        of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), and before the\r\n *        `fragmentMainOutro`.\r\n * @param {function<{vertexShader,fragmentShader}>:{vertexShader,fragmentShader}} options.customRewriter - A function\r\n *        for performing custom rewrites of the full shader code. Useful if you need to do something\r\n *        special that's not covered by the other builtin options. This function will be executed before\r\n *        any other transforms are applied.\r\n * @param {boolean} options.chained - Set to `true` to prototype-chain the derived material to the base\r\n *        material, rather than the default behavior of copying it. This allows the derived material to\r\n *        automatically pick up changes made to the base material and its properties. This can be useful\r\n *        where the derived material is hidden from the user as an implementation detail, allowing them\r\n *        to work with the original material like normal. But it can result in unexpected behavior if not\r\n *        handled carefully.\r\n *\r\n * @return {THREE.Material}\r\n *\r\n * The returned material will also have two new methods, `getDepthMaterial()` and `getDistanceMaterial()`,\r\n * which can be called to get a variant of the derived material for use in shadow casting. If the\r\n * target mesh is expected to cast shadows, then you can assign these to the mesh's `customDepthMaterial`\r\n * (for directional and spot lights) and/or `customDistanceMaterial` (for point lights) properties to\r\n * allow the cast shadow to honor your derived shader's vertex transforms and discarded fragments. These\r\n * will also set a custom `#define IS_DEPTH_MATERIAL` or `#define IS_DISTANCE_MATERIAL` that you can look\r\n * for in your derived shaders with `#ifdef` to customize their behavior for the depth or distance\r\n * scenarios, e.g. skipping antialiasing or expensive shader logic.\r\n */\n\nfunction createDerivedMaterial(baseMaterial, options) {\n  // Generate a key that is unique to the content of these `options`. We'll use this\n  // throughout for caching and for generating the upgraded shader code. This increases\n  // the likelihood that the resulting shaders will line up across multiple calls so\n  // their GL programs can be shared and cached.\n  const optionsKey = getKeyForOptions(options); // First check to see if we've already derived from this baseMaterial using this\n  // unique set of options, and if so reuse the constructor to avoid some allocations.\n\n  let ctorsByDerivation = CONSTRUCTOR_CACHE.get(baseMaterial);\n\n  if (!ctorsByDerivation) {\n    CONSTRUCTOR_CACHE.set(baseMaterial, ctorsByDerivation = Object.create(null));\n  }\n\n  if (ctorsByDerivation[optionsKey]) {\n    return new ctorsByDerivation[optionsKey]();\n  }\n\n  const privateBeforeCompileProp = `_onBeforeCompile${optionsKey}`; // Private onBeforeCompile handler that injects the modified shaders and uniforms when\n  // the renderer switches to this material's program\n\n  const onBeforeCompile = function (shaderInfo) {\n    baseMaterial.onBeforeCompile.call(this, shaderInfo); // Upgrade the shaders, caching the result by incoming source code\n\n    const cacheKey = optionsKey + '|||' + shaderInfo.vertexShader + '|||' + shaderInfo.fragmentShader;\n    let upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey];\n\n    if (!upgradedShaders) {\n      const upgraded = upgradeShaders(shaderInfo, options, optionsKey);\n      upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey] = upgraded;\n    } // Inject upgraded shaders and uniforms into the program\n\n\n    shaderInfo.vertexShader = upgradedShaders.vertexShader;\n    shaderInfo.fragmentShader = upgradedShaders.fragmentShader;\n    assign(shaderInfo.uniforms, this.uniforms); // Inject auto-updating time uniform if requested\n\n    if (options.timeUniform) {\n      shaderInfo.uniforms[options.timeUniform] = {\n        get value() {\n          return Date.now() - epoch;\n        }\n\n      };\n    } // Users can still add their own handlers on top of ours\n\n\n    if (this[privateBeforeCompileProp]) {\n      this[privateBeforeCompileProp](shaderInfo);\n    }\n  };\n\n  const DerivedMaterial = function DerivedMaterial() {\n    return derive(options.chained ? baseMaterial : baseMaterial.clone());\n  };\n\n  const derive = function (base) {\n    // Prototype chain to the base material\n    const derived = Object.create(base, descriptor); // Store the baseMaterial for reference; this is always the original even when cloning\n\n    Object.defineProperty(derived, 'baseMaterial', {\n      value: baseMaterial\n    }); // Needs its own ids\n\n    Object.defineProperty(derived, 'id', {\n      value: materialInstanceId++\n    });\n    derived.uuid = MathUtils.generateUUID(); // Merge uniforms, defines, and extensions\n\n    derived.uniforms = assign({}, base.uniforms, options.uniforms);\n    derived.defines = assign({}, base.defines, options.defines);\n    derived.defines[`TROIKA_DERIVED_MATERIAL_${optionsKey}`] = ''; //force a program change from the base material\n\n    derived.extensions = assign({}, base.extensions, options.extensions); // Don't inherit EventDispatcher listeners\n\n    derived._listeners = undefined;\n    return derived;\n  };\n\n  const descriptor = {\n    constructor: {\n      value: DerivedMaterial\n    },\n    isDerivedMaterial: {\n      value: true\n    },\n    customProgramCacheKey: {\n      value: function () {\n        return optionsKey;\n      }\n    },\n    onBeforeCompile: {\n      get() {\n        return onBeforeCompile;\n      },\n\n      set(fn) {\n        this[privateBeforeCompileProp] = fn;\n      }\n\n    },\n    copy: {\n      writable: true,\n      configurable: true,\n      value: function (source) {\n        baseMaterial.copy.call(this, source);\n\n        if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {\n          assign(this.extensions, source.extensions);\n          assign(this.defines, source.defines);\n          assign(this.uniforms, UniformsUtils.clone(source.uniforms));\n        }\n\n        return this;\n      }\n    },\n    clone: {\n      writable: true,\n      configurable: true,\n      value: function () {\n        const newBase = new baseMaterial.constructor();\n        return derive(newBase).copy(this);\n      }\n    },\n\n    /**\r\n     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex\r\n     * transformations and discarded fragments.\r\n     */\n    getDepthMaterial: {\n      writable: true,\n      configurable: true,\n      value: function () {\n        let depthMaterial = this._depthMaterial;\n\n        if (!depthMaterial) {\n          depthMaterial = this._depthMaterial = createDerivedMaterial(baseMaterial.isDerivedMaterial ? baseMaterial.getDepthMaterial() : new MeshDepthMaterial({\n            depthPacking: RGBADepthPacking\n          }), options);\n          depthMaterial.defines.IS_DEPTH_MATERIAL = '';\n          depthMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n        }\n\n        return depthMaterial;\n      }\n    },\n\n    /**\r\n     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex\r\n     * transformations and discarded fragments.\r\n     */\n    getDistanceMaterial: {\n      writable: true,\n      configurable: true,\n      value: function () {\n        let distanceMaterial = this._distanceMaterial;\n\n        if (!distanceMaterial) {\n          distanceMaterial = this._distanceMaterial = createDerivedMaterial(baseMaterial.isDerivedMaterial ? baseMaterial.getDistanceMaterial() : new MeshDistanceMaterial(), options);\n          distanceMaterial.defines.IS_DISTANCE_MATERIAL = '';\n          distanceMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n        }\n\n        return distanceMaterial;\n      }\n    },\n    dispose: {\n      writable: true,\n      configurable: true,\n\n      value() {\n        const {\n          _depthMaterial,\n          _distanceMaterial\n        } = this;\n        if (_depthMaterial) _depthMaterial.dispose();\n        if (_distanceMaterial) _distanceMaterial.dispose();\n        baseMaterial.dispose.call(this);\n      }\n\n    }\n  };\n  ctorsByDerivation[optionsKey] = DerivedMaterial;\n  return new DerivedMaterial();\n}\n\nfunction upgradeShaders({\n  vertexShader,\n  fragmentShader\n}, options, key) {\n  let {\n    vertexDefs,\n    vertexMainIntro,\n    vertexMainOutro,\n    vertexTransform,\n    fragmentDefs,\n    fragmentMainIntro,\n    fragmentMainOutro,\n    fragmentColorTransform,\n    customRewriter,\n    timeUniform\n  } = options;\n  vertexDefs = vertexDefs || '';\n  vertexMainIntro = vertexMainIntro || '';\n  vertexMainOutro = vertexMainOutro || '';\n  fragmentDefs = fragmentDefs || '';\n  fragmentMainIntro = fragmentMainIntro || '';\n  fragmentMainOutro = fragmentMainOutro || ''; // Expand includes if needed\n\n  if (vertexTransform || customRewriter) {\n    vertexShader = expandShaderIncludes(vertexShader);\n  }\n\n  if (fragmentColorTransform || customRewriter) {\n    // We need to be able to find postprocessing chunks after include expansion in order to\n    // put them after the fragmentColorTransform, so mark them with comments first. Even if\n    // this particular derivation doesn't have a fragmentColorTransform, other derivations may,\n    // so we still mark them.\n    fragmentShader = fragmentShader.replace(/^[ \\t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm, '\\n//!BEGIN_POST_CHUNK $1\\n$&\\n//!END_POST_CHUNK\\n');\n    fragmentShader = expandShaderIncludes(fragmentShader);\n  } // Apply custom rewriter function\n\n\n  if (customRewriter) {\n    let res = customRewriter({\n      vertexShader,\n      fragmentShader\n    });\n    vertexShader = res.vertexShader;\n    fragmentShader = res.fragmentShader;\n  } // The fragmentColorTransform needs to go before any postprocessing chunks, so extract\n  // those and re-insert them into the outro in the correct place:\n\n\n  if (fragmentColorTransform) {\n    let postChunks = [];\n    fragmentShader = fragmentShader.replace(/^\\/\\/!BEGIN_POST_CHUNK[^]+?^\\/\\/!END_POST_CHUNK/gm, // [^]+? = non-greedy match of any chars including newlines\n    match => {\n      postChunks.push(match);\n      return '';\n    });\n    fragmentMainOutro = `${fragmentColorTransform}\\n${postChunks.join('\\n')}\\n${fragmentMainOutro}`;\n  } // Inject auto-updating time uniform if requested\n\n\n  if (timeUniform) {\n    const code = `\\nuniform float ${timeUniform};\\n`;\n    vertexDefs = code + vertexDefs;\n    fragmentDefs = code + fragmentDefs;\n  } // Inject a function for the vertexTransform and rename all usages of position/normal/uv\n\n\n  if (vertexTransform) {\n    vertexDefs = `${vertexDefs}\nvec3 troika_position_${key};\nvec3 troika_normal_${key};\nvec2 troika_uv_${key};\nvoid troikaVertexTransform${key}(inout vec3 position, inout vec3 normal, inout vec2 uv) {\n  ${vertexTransform}\n}\n`;\n    vertexMainIntro = `\ntroika_position_${key} = vec3(position);\ntroika_normal_${key} = vec3(normal);\ntroika_uv_${key} = vec2(uv);\ntroikaVertexTransform${key}(troika_position_${key}, troika_normal_${key}, troika_uv_${key});\n${vertexMainIntro}\n`;\n    vertexShader = vertexShader.replace(/\\b(position|normal|uv)\\b/g, (match, match1, index, fullStr) => {\n      return /\\battribute\\s+vec[23]\\s+$/.test(fullStr.substr(0, index)) ? match1 : `troika_${match1}_${key}`;\n    });\n  } // Inject defs and intro/outro snippets\n\n\n  vertexShader = injectIntoShaderCode(vertexShader, key, vertexDefs, vertexMainIntro, vertexMainOutro);\n  fragmentShader = injectIntoShaderCode(fragmentShader, key, fragmentDefs, fragmentMainIntro, fragmentMainOutro);\n  return {\n    vertexShader,\n    fragmentShader\n  };\n}\n\nfunction injectIntoShaderCode(shaderCode, id, defs, intro, outro) {\n  if (intro || outro || defs) {\n    shaderCode = shaderCode.replace(voidMainRegExp, `\n${defs}\nvoid troikaOrigMain${id}() {`);\n    shaderCode += `\nvoid main() {\n  ${intro}\n  troikaOrigMain${id}();\n  ${outro}\n}`;\n  }\n\n  return shaderCode;\n}\n\nfunction optionsJsonReplacer(key, value) {\n  return key === 'uniforms' ? undefined : typeof value === 'function' ? value.toString() : value;\n}\n\nlet _idCtr = 0;\nconst optionsHashesToIds = new Map();\n\nfunction getKeyForOptions(options) {\n  const optionsHash = JSON.stringify(options, optionsJsonReplacer);\n  let id = optionsHashesToIds.get(optionsHash);\n\n  if (id == null) {\n    optionsHashesToIds.set(optionsHash, id = ++_idCtr);\n  }\n\n  return id;\n} // Copied from threejs WebGLPrograms.js so we can resolve builtin materials to their shaders\n// TODO how can we keep this from getting stale?\n\n\nconst MATERIAL_TYPES_TO_SHADERS = {\n  MeshDepthMaterial: 'depth',\n  MeshDistanceMaterial: 'distanceRGBA',\n  MeshNormalMaterial: 'normal',\n  MeshBasicMaterial: 'basic',\n  MeshLambertMaterial: 'lambert',\n  MeshPhongMaterial: 'phong',\n  MeshToonMaterial: 'phong',\n  MeshStandardMaterial: 'physical',\n  MeshPhysicalMaterial: 'physical',\n  MeshMatcapMaterial: 'matcap',\n  LineBasicMaterial: 'basic',\n  LineDashedMaterial: 'dashed',\n  PointsMaterial: 'points',\n  ShadowMaterial: 'shadow',\n  SpriteMaterial: 'sprite'\n};\n/**\r\n * Given a Three.js `Material` instance, find the shaders/uniforms that will be\r\n * used to render that material.\r\n *\r\n * @param material - the Material instance\r\n * @return {object} - the material's shader info: `{uniforms:{}, fragmentShader:'', vertexShader:''}`\r\n */\n\nfunction getShadersForMaterial(material) {\n  let builtinType = MATERIAL_TYPES_TO_SHADERS[material.type];\n  return builtinType ? ShaderLib[builtinType] : material; //TODO fallback for unknown type?\n}\n/**\r\n * Find all uniforms and their types within a shader code string.\r\n *\r\n * @param {string} shader - The shader code to parse\r\n * @return {object} mapping of uniform names to their glsl type\r\n */\n\n\nfunction getShaderUniformTypes(shader) {\n  let uniformRE = /\\buniform\\s+(int|float|vec[234])\\s+([A-Za-z_][\\w]*)/g;\n  let uniforms = Object.create(null);\n  let match;\n\n  while ((match = uniformRE.exec(shader)) !== null) {\n    uniforms[match[2]] = match[1];\n  }\n\n  return uniforms;\n}\n/**\r\n * @class ShaderFloatArray\r\n *\r\n * When writing a custom WebGL shader, sometimes you need to pass it an array of floating\r\n * point numbers that it can read from. Unfortunately this is very difficult to do in WebGL,\r\n * because:\r\n *\r\n *   - GLSL \"array\" uniforms can only be of a constant length.\r\n *   - Textures can only hold floating point numbers in WebGL1 if the `OES_texture_float`\r\n *     extension is available.\r\n *\r\n * ShaderFloatArray is an array-like abstraction that encodes its floating point data into\r\n * an RGBA texture's four Uint8 components, and provides the corresponding ThreeJS uniforms\r\n * and GLSL code for you to put in your custom shader to query the float values by array index.\r\n *\r\n * This should generally only be used within a fragment shader, as some environments (e.g. iOS)\r\n * only allow texture lookups in fragment shaders.\r\n *\r\n * TODO:\r\n *   - Fix texture to fill both dimensions so we don't easily hit max texture size limits\r\n *   - Use a float texture if the extension is available so we can skip the encoding process\r\n */\n\n\nclass ShaderFloatArray {\n  constructor(name) {\n    this.name = name;\n    this.textureUniform = `dataTex_${name}`;\n    this.textureSizeUniform = `dataTexSize_${name}`;\n    this.multiplierUniform = `dataMultiplier_${name}`;\n    /**\r\n     * @property dataSizeUniform - the name of the GLSL uniform that will hold the\r\n     * length of the data array.\r\n     * @type {string}\r\n     */\n\n    this.dataSizeUniform = `dataSize_${name}`;\n    /**\r\n     * @property readFunction - the name of the GLSL function that should be called to\r\n     * read data out of the array by index.\r\n     * @type {string}\r\n     */\n\n    this.readFunction = `readData_${name}`;\n    this._raw = new Float32Array(0);\n    this._texture = new DataTexture(new Uint8Array(0), 0, 1);\n    this._length = 0;\n    this._multiplier = 1;\n  }\n  /**\r\n   * @property length - the current length of the data array\r\n   * @type {number}\r\n   */\n\n\n  set length(value) {\n    if (value !== this._length) {\n      // Find nearest power-of-2 that holds the new length\n      const size = Math.pow(2, Math.ceil(Math.log2(value)));\n      const raw = this._raw;\n\n      if (size < raw.length) {\n        this._raw = raw.subarray(0, size);\n      } else if (size > raw.length) {\n        this._raw = new Float32Array(size);\n\n        this._raw.set(raw);\n      }\n\n      this._length = value;\n    }\n  }\n\n  get length() {\n    return this._length;\n  }\n  /**\r\n   * Add a value to the end of the data array\r\n   * @param {number} value\r\n   */\n\n\n  push(value) {\n    return this.set(this.length++, value);\n  }\n  /**\r\n   * Replace the existing data with that from a new array\r\n   * @param {ArrayLike<number>} array\r\n   */\n\n\n  setArray(array) {\n    this.length = array.length;\n\n    this._raw.set(array);\n\n    this._needsRepack = true;\n  }\n  /**\r\n   * Get the current value at index\r\n   * @param {number} index\r\n   * @return {number}\r\n   */\n\n\n  get(index) {\n    return this._raw[index];\n  }\n\n  set(index, value) {\n    if (index + 1 > this._length) {\n      this.length = index + 1;\n    }\n\n    if (value !== this._raw[index]) {\n      this._raw[index] = value;\n      encodeFloatToFourInts(value / this._multiplier, this._texture.image.data, index * 4);\n      this._needsMultCheck = true;\n    }\n  }\n  /**\r\n   * Make a copy of this ShaderFloatArray\r\n   * @return {ShaderFloatArray}\r\n   */\n\n\n  clone() {\n    const clone = new ShaderFloatArray(this.name);\n    clone.setArray(this._raw);\n    return clone;\n  }\n  /**\r\n   * Retrieve the set of Uniforms that must to be added to the target ShaderMaterial or\r\n   * DerivedMaterial, to feed the GLSL code generated by {@link #getShaderHeaderCode}.\r\n   * @return {Object}\r\n   */\n\n\n  getShaderUniforms() {\n    const me = this;\n    return {\n      [this.textureUniform]: {\n        get value() {\n          me._sync();\n\n          return me._texture;\n        }\n\n      },\n      [this.textureSizeUniform]: {\n        get value() {\n          me._sync();\n\n          return me._texture.image.width;\n        }\n\n      },\n      [this.dataSizeUniform]: {\n        get value() {\n          me._sync();\n\n          return me.length;\n        }\n\n      },\n      [this.multiplierUniform]: {\n        get value() {\n          me._sync();\n\n          return me._multiplier;\n        }\n\n      }\n    };\n  }\n  /**\r\n   * Retrieve the GLSL code that must be injected into the shader's definitions area to\r\n   * enable reading from the data array. This exposes a function with a name matching\r\n   * the {@link #readFunction} property, which other shader code can call to read values\r\n   * from the array by their index.\r\n   * @return {string}\r\n   */\n\n\n  getShaderHeaderCode() {\n    const {\n      textureUniform,\n      textureSizeUniform,\n      dataSizeUniform,\n      multiplierUniform,\n      readFunction\n    } = this;\n    return `\nuniform sampler2D ${textureUniform};\nuniform float ${textureSizeUniform};\nuniform float ${dataSizeUniform};\nuniform float ${multiplierUniform};\n\nfloat ${readFunction}(float index) {\n  vec2 texUV = vec2((index + 0.5) / ${textureSizeUniform}, 0.5);\n  vec4 pixel = texture2D(${textureUniform}, texUV);\n  return dot(pixel, 1.0 / vec4(1.0, 255.0, 65025.0, 16581375.0)) * ${multiplierUniform};\n}\n`;\n  }\n  /**\r\n   * @private Synchronize any pending changes to the underlying DataTexture\r\n   */\n\n\n  _sync() {\n    const tex = this._texture;\n    const raw = this._raw;\n    let needsRepack = this._needsRepack; // If the size of the raw array changed, resize the texture to match\n\n    if (raw.length !== tex.image.width) {\n      tex.image = {\n        data: new Uint8Array(raw.length * 4),\n        width: raw.length,\n        height: 1\n      };\n      needsRepack = true;\n    } // If the values changed, check the multiplier. This should be a value by which\n    // all the values are divided to constrain them to the [0,1] range required by\n    // the Uint8 packing algorithm. We pick the nearest power of 2 that holds the\n    // maximum value for greatest accuracy.\n\n\n    if (needsRepack || this._needsMultCheck) {\n      const maxVal = this._raw.reduce((a, b) => Math.max(a, b), 0);\n\n      const mult = Math.pow(2, Math.ceil(Math.log2(maxVal)));\n\n      if (mult !== this._multiplier) {\n        this._multiplier = mult;\n        needsRepack = true;\n      }\n\n      tex.needsUpdate = true;\n      this._needsMultCheck = false;\n    } // If things changed in a way we need to repack, do so\n\n\n    if (needsRepack) {\n      for (let i = 0, len = raw.length, mult = this._multiplier; i < len; i++) {\n        encodeFloatToFourInts(raw[i] / mult, tex.image.data, i * 4);\n      }\n\n      this._needsRepack = false;\n    }\n  }\n\n}\n/**\r\n * Encode a floating point number into a set of four 8-bit integers.\r\n * Also see the companion decoder function #decodeFloatFromFourInts.\r\n *\r\n * This is adapted to JavaScript from the basic approach at\r\n * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\r\n * but writes out integers in the range 0-255 instead of floats in the range 0-1\r\n * so they can be more easily used in a Uint8Array for standard WebGL rgba textures.\r\n *\r\n * Some precision will necessarily be lost during the encoding and decoding process.\r\n * Testing shows that the maximum precision error is ~1.18e-10 which should be good\r\n * enough for most cases.\r\n *\r\n * @param {Number} value - the floating point number to encode. Must be in the range [0, 1]\r\n *        otherwise the results will be incorrect.\r\n * @param {Array|Uint8Array} array - an array into which the four ints should be written\r\n * @param {Number} startIndex - index in the output array at which to start writing the ints\r\n * @return {Array|Uint8Array}\r\n */\n\n\nfunction encodeFloatToFourInts(value, array, startIndex) {\n  // This is adapted to JS from the basic approach at\n  // http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\n  // but writes to a Uint8Array instead of floats. Input values must be in\n  // the range [0, 1]. The maximum error after encoding and decoding is ~1.18e-10\n  let enc0 = 255 * value;\n  let enc1 = 255 * (enc0 % 1);\n  let enc2 = 255 * (enc1 % 1);\n  let enc3 = 255 * (enc2 % 1);\n  enc0 = enc0 & 255;\n  enc1 = enc1 & 255;\n  enc2 = enc2 & 255;\n  enc3 = Math.round(enc3) & 255;\n  array[startIndex] = enc0;\n  array[startIndex + 1] = enc1;\n  array[startIndex + 2] = enc2;\n  array[startIndex + 3] = enc3;\n  return array;\n}\n/*\r\nInput geometry is a cylinder with r=1, height in y dimension from 0 to 1,\r\ndivided into a reasonable number of height segments.\r\n*/\n\n\nconst vertexDefs = `\nuniform vec3 pointA;\nuniform vec3 controlA;\nuniform vec3 controlB;\nuniform vec3 pointB;\nuniform float radius;\nvarying float bezierT;\n\nvec3 cubicBezier(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\n  float t2 = 1.0 - t;\n  float b0 = t2 * t2 * t2;\n  float b1 = 3.0 * t * t2 * t2;\n  float b2 = 3.0 * t * t * t2;\n  float b3 = t * t * t;\n  return b0 * p1 + b1 * c1 + b2 * c2 + b3 * p2;\n}\n\nvec3 cubicBezierDerivative(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\n  float t2 = 1.0 - t;\n  return -3.0 * p1 * t2 * t2 +\n    c1 * (3.0 * t2 * t2 - 6.0 * t2 * t) +\n    c2 * (6.0 * t2 * t - 3.0 * t * t) +\n    3.0 * p2 * t * t;\n}\n`;\nconst vertexTransform = `\nfloat t = position.y;\nbezierT = t;\nvec3 bezierCenterPos = cubicBezier(pointA, controlA, controlB, pointB, t);\nvec3 bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t));\n\n// Make \"sideways\" always perpendicular to the camera ray; this ensures that any twists\n// in the cylinder occur where you won't see them: \nvec3 viewDirection = normalMatrix * vec3(0.0, 0.0, 1.0);\nif (bezierDir == viewDirection) {\n  bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t == 1.0 ? t - 0.0001 : t + 0.0001));\n}\nvec3 sideways = normalize(cross(bezierDir, viewDirection));\nvec3 upish = normalize(cross(sideways, bezierDir));\n\n// Build a matrix for transforming this disc in the cylinder:\nmat4 discTx;\ndiscTx[0].xyz = sideways * radius;\ndiscTx[1].xyz = bezierDir * radius;\ndiscTx[2].xyz = upish * radius;\ndiscTx[3].xyz = bezierCenterPos;\ndiscTx[3][3] = 1.0;\n\n// Apply transform, ignoring original y\nposition = (discTx * vec4(position.x, 0.0, position.z, 1.0)).xyz;\nnormal = normalize(mat3(discTx) * normal);\n`;\nconst fragmentDefs = `\nuniform vec3 dashing;\nvarying float bezierT;\n`;\nconst fragmentMainIntro = `\nif (dashing.x + dashing.y > 0.0) {\n  float dashFrac = mod(bezierT - dashing.z, dashing.x + dashing.y);\n  if (dashFrac > dashing.x) {\n    discard;\n  }\n}\n`; // Debugging: separate color for each of the 6 sides:\n// const fragmentColorTransform = `\n// float sideNum = floor(vUV.x * 6.0);\n// vec3 mixColor = sideNum < 1.0 ? vec3(1.0, 0.0, 0.0) :\n//   sideNum < 2.0 ? vec3(0.0, 1.0, 1.0) :\n//   sideNum < 3.0 ? vec3(1.0, 1.0, 0.0) :\n//   sideNum < 4.0 ? vec3(0.0, 0.0, 1.0) :\n//   sideNum < 5.0 ? vec3(0.0, 1.0, 0.0) :\n//   vec3(1.0, 0.0, 1.0);\n// gl_FragColor.xyz = mix(gl_FragColor.xyz, mixColor, 0.5);\n// `\n\nfunction createBezierMeshMaterial(baseMaterial) {\n  return createDerivedMaterial(baseMaterial, {\n    chained: true,\n    uniforms: {\n      pointA: {\n        value: new Vector3()\n      },\n      controlA: {\n        value: new Vector3()\n      },\n      controlB: {\n        value: new Vector3()\n      },\n      pointB: {\n        value: new Vector3()\n      },\n      radius: {\n        value: 0.01\n      },\n      dashing: {\n        value: new Vector3()\n      } //on, off, offset\n\n    },\n    vertexDefs,\n    vertexTransform,\n    fragmentDefs,\n    fragmentMainIntro\n  });\n}\n\nlet geometry = null;\nconst defaultBaseMaterial = /*#__PURE__*/new MeshStandardMaterial({\n  color: 0xffffff,\n  side: DoubleSide\n});\n/**\r\n * A ThreeJS `Mesh` that bends a tube shape along a 3D cubic bezier path. The bending is done\r\n * by deforming a straight cylindrical geometry in the vertex shader based on a set of four\r\n * control point uniforms. It patches the necessary GLSL into the mesh's assigned `material`\r\n * automatically.\r\n *\r\n * The cubiz bezier path is determined by its four `Vector3` properties:\r\n * - `pointA`\r\n * - `controlA`\r\n * - `controlB`\r\n * - `pointB`\r\n *\r\n * The tube's radius is controlled by its `radius` property, which defaults to `0.01`.\r\n *\r\n * You can also give the tube a dashed appearance with two properties:\r\n *\r\n * - `dashArray` - an array of two numbers, defining the length of \"on\" and \"off\" parts of\r\n *   the dash. Each is a 0-1 ratio of the entire path's length. (Actually this is the `t` length\r\n *   used as input to the cubic bezier function, not its visible length.)\r\n * - `dashOffset` - offset of where the dash starts. You can animate this to make the dashes move.\r\n *\r\n * Note that the dashes will appear like a hollow tube, not solid. This will be more apparent on\r\n * thicker tubes.\r\n *\r\n * TODO: proper geometry bounding sphere and raycasting\r\n * TODO: allow control of the geometry's segment counts\r\n */\n\nclass BezierMesh extends Mesh {\n  static getGeometry() {\n    return geometry || (geometry = new CylinderBufferGeometry(1, 1, 1, 6, 64).translate(0, 0.5, 0));\n  }\n\n  constructor() {\n    super(BezierMesh.getGeometry(), defaultBaseMaterial);\n    this.pointA = new Vector3();\n    this.controlA = new Vector3();\n    this.controlB = new Vector3();\n    this.pointB = new Vector3();\n    this.radius = 0.01;\n    this.dashArray = new Vector2();\n    this.dashOffset = 0; // TODO - disabling frustum culling until I figure out how to customize the\n    //  geometry's bounding sphere that gets used\n\n    this.frustumCulled = false;\n  } // Handler for automatically wrapping the base material with our upgrades. We do the wrapping\n  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.\n\n\n  get material() {\n    let derivedMaterial = this._derivedMaterial;\n    const baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultBaseMaterial.clone());\n\n    if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {\n      derivedMaterial = this._derivedMaterial = createBezierMeshMaterial(baseMaterial); // dispose the derived material when its base material is disposed:\n\n      baseMaterial.addEventListener('dispose', function onDispose() {\n        baseMaterial.removeEventListener('dispose', onDispose);\n        derivedMaterial.dispose();\n      });\n    }\n\n    return derivedMaterial;\n  }\n\n  set material(baseMaterial) {\n    this._baseMaterial = baseMaterial;\n  } // Create and update material for shadows upon request:\n\n\n  get customDepthMaterial() {\n    return this.material.getDepthMaterial();\n  }\n\n  get customDistanceMaterial() {\n    return this.material.getDistanceMaterial();\n  }\n\n  onBeforeRender(shaderInfo) {\n    const {\n      uniforms\n    } = this.material;\n    const {\n      pointA,\n      controlA,\n      controlB,\n      pointB,\n      radius,\n      dashArray,\n      dashOffset\n    } = this;\n    uniforms.pointA.value.copy(pointA);\n    uniforms.controlA.value.copy(controlA);\n    uniforms.controlB.value.copy(controlB);\n    uniforms.pointB.value.copy(pointB);\n    uniforms.radius.value = radius;\n    uniforms.dashing.value.set(dashArray.x, dashArray.y, dashOffset || 0);\n  }\n\n  raycast(raycaster, intersects) {// TODO - just fail for now\n  }\n\n}\n\nexport { BezierMesh, ShaderFloatArray, createDerivedMaterial, expandShaderIncludes, getShaderUniformTypes, getShadersForMaterial, voidMainRegExp };","map":{"version":3,"sources":["/Users/haiakablan/Documents/לוטוס/קורס/Architecture-web/node_modules/drei/node_modules/troika-three-utils/dist/troika-three-utils.esm.js"],"names":["ShaderChunk","MathUtils","UniformsUtils","MeshDepthMaterial","RGBADepthPacking","MeshDistanceMaterial","ShaderLib","DataTexture","Vector3","Mesh","CylinderBufferGeometry","Vector2","MeshStandardMaterial","DoubleSide","voidMainRegExp","expandShaderIncludes","source","pattern","replace","match","include","chunk","assign","Object","target","arguments","i","len","length","prop","hasOwnProperty","epoch","Date","now","CONSTRUCTOR_CACHE","WeakMap","SHADER_UPGRADE_CACHE","Map","materialInstanceId","createDerivedMaterial","baseMaterial","options","optionsKey","getKeyForOptions","ctorsByDerivation","get","set","create","privateBeforeCompileProp","onBeforeCompile","shaderInfo","call","cacheKey","vertexShader","fragmentShader","upgradedShaders","upgraded","upgradeShaders","uniforms","timeUniform","value","DerivedMaterial","derive","chained","clone","base","derived","descriptor","defineProperty","uuid","generateUUID","defines","extensions","_listeners","undefined","constructor","isDerivedMaterial","customProgramCacheKey","fn","copy","writable","configurable","isShaderMaterial","newBase","getDepthMaterial","depthMaterial","_depthMaterial","depthPacking","IS_DEPTH_MATERIAL","getDistanceMaterial","distanceMaterial","_distanceMaterial","IS_DISTANCE_MATERIAL","dispose","key","vertexDefs","vertexMainIntro","vertexMainOutro","vertexTransform","fragmentDefs","fragmentMainIntro","fragmentMainOutro","fragmentColorTransform","customRewriter","res","postChunks","push","join","code","match1","index","fullStr","test","substr","injectIntoShaderCode","shaderCode","id","defs","intro","outro","optionsJsonReplacer","toString","_idCtr","optionsHashesToIds","optionsHash","JSON","stringify","MATERIAL_TYPES_TO_SHADERS","MeshNormalMaterial","MeshBasicMaterial","MeshLambertMaterial","MeshPhongMaterial","MeshToonMaterial","MeshPhysicalMaterial","MeshMatcapMaterial","LineBasicMaterial","LineDashedMaterial","PointsMaterial","ShadowMaterial","SpriteMaterial","getShadersForMaterial","material","builtinType","type","getShaderUniformTypes","shader","uniformRE","exec","ShaderFloatArray","name","textureUniform","textureSizeUniform","multiplierUniform","dataSizeUniform","readFunction","_raw","Float32Array","_texture","Uint8Array","_length","_multiplier","size","Math","pow","ceil","log2","raw","subarray","setArray","array","_needsRepack","encodeFloatToFourInts","image","data","_needsMultCheck","getShaderUniforms","me","_sync","width","getShaderHeaderCode","tex","needsRepack","height","maxVal","reduce","a","b","max","mult","needsUpdate","startIndex","enc0","enc1","enc2","enc3","round","createBezierMeshMaterial","pointA","controlA","controlB","pointB","radius","dashing","geometry","defaultBaseMaterial","color","side","BezierMesh","getGeometry","translate","dashArray","dashOffset","frustumCulled","derivedMaterial","_derivedMaterial","_baseMaterial","_defaultMaterial","addEventListener","onDispose","removeEventListener","customDepthMaterial","customDistanceMaterial","onBeforeRender","x","y","raycast","raycaster","intersects"],"mappings":"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","sourcesContent":["import { ShaderChunk, MathUtils, UniformsUtils, MeshDepthMaterial, RGBADepthPacking, MeshDistanceMaterial, ShaderLib, DataTexture, Vector3, Mesh, CylinderBufferGeometry, Vector2, MeshStandardMaterial, DoubleSide } from 'three';\n\n/**\r\n * Regular expression for matching the `void main() {` opener line in GLSL.\r\n * @type {RegExp}\r\n */\r\nconst voidMainRegExp = /\\bvoid\\s+main\\s*\\(\\s*\\)\\s*{/g;\n\n/**\r\n * Recursively expands all `#include <xyz>` statements within string of shader code.\r\n * Copied from three's WebGLProgram#parseIncludes for external use.\r\n *\r\n * @param {string} source - The GLSL source code to evaluate\r\n * @return {string} The GLSL code with all includes expanded\r\n */\r\nfunction expandShaderIncludes( source ) {\r\n  const pattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\r\n  function replace(match, include) {\r\n    let chunk = ShaderChunk[include];\r\n    return chunk ? expandShaderIncludes(chunk) : match\r\n  }\r\n  return source.replace( pattern, replace )\r\n}\n\n// Local assign polyfill to avoid importing troika-core\r\nconst assign = Object.assign || function(/*target, ...sources*/) {\r\n  let target = arguments[0];\r\n  for (let i = 1, len = arguments.length; i < len; i++) {\r\n    let source = arguments[i];\r\n    if (source) {\r\n      for (let prop in source) {\r\n        if (source.hasOwnProperty(prop)) {\r\n          target[prop] = source[prop];\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return target\r\n};\r\n\r\n\r\nconst epoch = Date.now();\r\nconst CONSTRUCTOR_CACHE = new WeakMap();\r\nconst SHADER_UPGRADE_CACHE = new Map();\r\n\r\n// Material ids must be integers, but we can't access the increment from Three's `Material` module,\r\n// so let's choose a sufficiently large starting value that should theoretically never collide.\r\nlet materialInstanceId = 1e10;\r\n\r\n/**\r\n * A utility for creating a custom shader material derived from another material's\r\n * shaders. This allows you to inject custom shader logic and transforms into the\r\n * builtin ThreeJS materials without having to recreate them from scratch.\r\n *\r\n * @param {THREE.Material} baseMaterial - the original material to derive from\r\n *\r\n * @param {Object} options - How the base material should be modified.\r\n * @param {Object} options.defines - Custom `defines` for the material\r\n * @param {Object} options.extensions - Custom `extensions` for the material, e.g. `{derivatives: true}`\r\n * @param {Object} options.uniforms - Custom `uniforms` for use in the modified shader. These can\r\n *        be accessed and manipulated via the resulting material's `uniforms` property, just like\r\n *        in a ShaderMaterial. You do not need to repeat the base material's own uniforms here.\r\n * @param {String} options.timeUniform - If specified, a uniform of this name will be injected into\r\n *        both shaders, and it will automatically be updated on each render frame with a number of\r\n *        elapsed milliseconds. The \"zero\" epoch time is not significant so don't rely on this as a\r\n *        true calendar time.\r\n * @param {String} options.vertexDefs - Custom GLSL code to inject into the vertex shader's top-level\r\n *        definitions, above the `void main()` function.\r\n * @param {String} options.vertexMainIntro - Custom GLSL code to inject at the top of the vertex\r\n *        shader's `void main` function.\r\n * @param {String} options.vertexMainOutro - Custom GLSL code to inject at the end of the vertex\r\n *        shader's `void main` function.\r\n * @param {String} options.vertexTransform - Custom GLSL code to manipulate the `position`, `normal`,\r\n *        and/or `uv` vertex attributes. This code will be wrapped within a standalone function with\r\n *        those attributes exposed by their normal names as read/write values.\r\n * @param {String} options.fragmentDefs - Custom GLSL code to inject into the fragment shader's top-level\r\n *        definitions, above the `void main()` function.\r\n * @param {String} options.fragmentMainIntro - Custom GLSL code to inject at the top of the fragment\r\n *        shader's `void main` function.\r\n * @param {String} options.fragmentMainOutro - Custom GLSL code to inject at the end of the fragment\r\n *        shader's `void main` function. You can manipulate `gl_FragColor` here but keep in mind it goes\r\n *        after any of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), so if you\r\n *        want those to apply to your changes use `fragmentColorTransform` instead.\r\n * @param {String} options.fragmentColorTransform - Custom GLSL code to manipulate the `gl_FragColor`\r\n *        output value. Will be injected near the end of the `void main` function, but before any\r\n *        of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), and before the\r\n *        `fragmentMainOutro`.\r\n * @param {function<{vertexShader,fragmentShader}>:{vertexShader,fragmentShader}} options.customRewriter - A function\r\n *        for performing custom rewrites of the full shader code. Useful if you need to do something\r\n *        special that's not covered by the other builtin options. This function will be executed before\r\n *        any other transforms are applied.\r\n * @param {boolean} options.chained - Set to `true` to prototype-chain the derived material to the base\r\n *        material, rather than the default behavior of copying it. This allows the derived material to\r\n *        automatically pick up changes made to the base material and its properties. This can be useful\r\n *        where the derived material is hidden from the user as an implementation detail, allowing them\r\n *        to work with the original material like normal. But it can result in unexpected behavior if not\r\n *        handled carefully.\r\n *\r\n * @return {THREE.Material}\r\n *\r\n * The returned material will also have two new methods, `getDepthMaterial()` and `getDistanceMaterial()`,\r\n * which can be called to get a variant of the derived material for use in shadow casting. If the\r\n * target mesh is expected to cast shadows, then you can assign these to the mesh's `customDepthMaterial`\r\n * (for directional and spot lights) and/or `customDistanceMaterial` (for point lights) properties to\r\n * allow the cast shadow to honor your derived shader's vertex transforms and discarded fragments. These\r\n * will also set a custom `#define IS_DEPTH_MATERIAL` or `#define IS_DISTANCE_MATERIAL` that you can look\r\n * for in your derived shaders with `#ifdef` to customize their behavior for the depth or distance\r\n * scenarios, e.g. skipping antialiasing or expensive shader logic.\r\n */\r\nfunction createDerivedMaterial(baseMaterial, options) {\r\n  // Generate a key that is unique to the content of these `options`. We'll use this\r\n  // throughout for caching and for generating the upgraded shader code. This increases\r\n  // the likelihood that the resulting shaders will line up across multiple calls so\r\n  // their GL programs can be shared and cached.\r\n  const optionsKey = getKeyForOptions(options);\r\n\r\n  // First check to see if we've already derived from this baseMaterial using this\r\n  // unique set of options, and if so reuse the constructor to avoid some allocations.\r\n  let ctorsByDerivation = CONSTRUCTOR_CACHE.get(baseMaterial);\r\n  if (!ctorsByDerivation) {\r\n    CONSTRUCTOR_CACHE.set(baseMaterial, (ctorsByDerivation = Object.create(null)));\r\n  }\r\n  if (ctorsByDerivation[optionsKey]) {\r\n    return new ctorsByDerivation[optionsKey]()\r\n  }\r\n\r\n  const privateBeforeCompileProp = `_onBeforeCompile${optionsKey}`;\r\n\r\n  // Private onBeforeCompile handler that injects the modified shaders and uniforms when\r\n  // the renderer switches to this material's program\r\n  const onBeforeCompile = function (shaderInfo) {\r\n    baseMaterial.onBeforeCompile.call(this, shaderInfo);\r\n\r\n    // Upgrade the shaders, caching the result by incoming source code\r\n    const cacheKey = optionsKey + '|||' + shaderInfo.vertexShader + '|||' + shaderInfo.fragmentShader;\r\n    let upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey];\r\n    if (!upgradedShaders) {\r\n      const upgraded = upgradeShaders(shaderInfo, options, optionsKey);\r\n      upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey] = upgraded;\r\n    }\r\n\r\n    // Inject upgraded shaders and uniforms into the program\r\n    shaderInfo.vertexShader = upgradedShaders.vertexShader;\r\n    shaderInfo.fragmentShader = upgradedShaders.fragmentShader;\r\n    assign(shaderInfo.uniforms, this.uniforms);\r\n\r\n    // Inject auto-updating time uniform if requested\r\n    if (options.timeUniform) {\r\n      shaderInfo.uniforms[options.timeUniform] = {\r\n        get value() {return Date.now() - epoch}\r\n      };\r\n    }\r\n\r\n    // Users can still add their own handlers on top of ours\r\n    if (this[privateBeforeCompileProp]) {\r\n      this[privateBeforeCompileProp](shaderInfo);\r\n    }\r\n  };\r\n\r\n  const DerivedMaterial = function DerivedMaterial() {\r\n    return derive(options.chained ? baseMaterial : baseMaterial.clone())\r\n  };\r\n\r\n  const derive = function(base) {\r\n    // Prototype chain to the base material\r\n    const derived = Object.create(base, descriptor);\r\n\r\n    // Store the baseMaterial for reference; this is always the original even when cloning\r\n    Object.defineProperty(derived, 'baseMaterial', { value: baseMaterial });\r\n\r\n    // Needs its own ids\r\n    Object.defineProperty(derived, 'id', { value: materialInstanceId++ });\r\n    derived.uuid = MathUtils.generateUUID();\r\n\r\n    // Merge uniforms, defines, and extensions\r\n    derived.uniforms = assign({}, base.uniforms, options.uniforms);\r\n    derived.defines = assign({}, base.defines, options.defines);\r\n    derived.defines[`TROIKA_DERIVED_MATERIAL_${optionsKey}`] = ''; //force a program change from the base material\r\n    derived.extensions = assign({}, base.extensions, options.extensions);\r\n\r\n    // Don't inherit EventDispatcher listeners\r\n    derived._listeners = undefined;\r\n\r\n    return derived\r\n  };\r\n\r\n  const descriptor = {\r\n    constructor: {value: DerivedMaterial},\r\n    isDerivedMaterial: {value: true},\r\n\r\n    customProgramCacheKey: {\r\n      value: function () {\r\n        return optionsKey\r\n      }\r\n    },\r\n\r\n    onBeforeCompile: {\r\n      get() {\r\n        return onBeforeCompile\r\n      },\r\n      set(fn) {\r\n        this[privateBeforeCompileProp] = fn;\r\n      }\r\n    },\r\n\r\n    copy: {\r\n      writable: true,\r\n      configurable: true,\r\n      value: function (source) {\r\n        baseMaterial.copy.call(this, source);\r\n        if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {\r\n          assign(this.extensions, source.extensions);\r\n          assign(this.defines, source.defines);\r\n          assign(this.uniforms, UniformsUtils.clone(source.uniforms));\r\n        }\r\n        return this\r\n      }\r\n    },\r\n\r\n    clone: {\r\n      writable: true,\r\n      configurable: true,\r\n      value: function () {\r\n        const newBase = new baseMaterial.constructor();\r\n        return derive(newBase).copy(this)\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex\r\n     * transformations and discarded fragments.\r\n     */\r\n    getDepthMaterial: {\r\n      writable: true,\r\n      configurable: true,\r\n      value: function() {\r\n        let depthMaterial = this._depthMaterial;\r\n        if (!depthMaterial) {\r\n          depthMaterial = this._depthMaterial = createDerivedMaterial(\r\n            baseMaterial.isDerivedMaterial\r\n              ? baseMaterial.getDepthMaterial()\r\n              : new MeshDepthMaterial({ depthPacking: RGBADepthPacking }),\r\n            options\r\n          );\r\n          depthMaterial.defines.IS_DEPTH_MATERIAL = '';\r\n          depthMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\r\n        }\r\n        return depthMaterial\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex\r\n     * transformations and discarded fragments.\r\n     */\r\n    getDistanceMaterial: {\r\n      writable: true,\r\n      configurable: true,\r\n      value: function() {\r\n        let distanceMaterial = this._distanceMaterial;\r\n        if (!distanceMaterial) {\r\n          distanceMaterial = this._distanceMaterial = createDerivedMaterial(\r\n            baseMaterial.isDerivedMaterial\r\n              ? baseMaterial.getDistanceMaterial()\r\n              : new MeshDistanceMaterial(),\r\n            options\r\n          );\r\n          distanceMaterial.defines.IS_DISTANCE_MATERIAL = '';\r\n          distanceMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\r\n        }\r\n        return distanceMaterial\r\n      }\r\n    },\r\n\r\n    dispose: {\r\n      writable: true,\r\n      configurable: true,\r\n      value() {\r\n        const {_depthMaterial, _distanceMaterial} = this;\r\n        if (_depthMaterial) _depthMaterial.dispose();\r\n        if (_distanceMaterial) _distanceMaterial.dispose();\r\n        baseMaterial.dispose.call(this);\r\n      }\r\n    }\r\n  };\r\n\r\n  ctorsByDerivation[optionsKey] = DerivedMaterial;\r\n  return new DerivedMaterial()\r\n}\r\n\r\n\r\nfunction upgradeShaders({vertexShader, fragmentShader}, options, key) {\r\n  let {\r\n    vertexDefs,\r\n    vertexMainIntro,\r\n    vertexMainOutro,\r\n    vertexTransform,\r\n    fragmentDefs,\r\n    fragmentMainIntro,\r\n    fragmentMainOutro,\r\n    fragmentColorTransform,\r\n    customRewriter,\r\n    timeUniform\r\n  } = options;\r\n\r\n  vertexDefs = vertexDefs || '';\r\n  vertexMainIntro = vertexMainIntro || '';\r\n  vertexMainOutro = vertexMainOutro || '';\r\n  fragmentDefs = fragmentDefs || '';\r\n  fragmentMainIntro = fragmentMainIntro || '';\r\n  fragmentMainOutro = fragmentMainOutro || '';\r\n\r\n  // Expand includes if needed\r\n  if (vertexTransform || customRewriter) {\r\n    vertexShader = expandShaderIncludes(vertexShader);\r\n  }\r\n  if (fragmentColorTransform || customRewriter) {\r\n    // We need to be able to find postprocessing chunks after include expansion in order to\r\n    // put them after the fragmentColorTransform, so mark them with comments first. Even if\r\n    // this particular derivation doesn't have a fragmentColorTransform, other derivations may,\r\n    // so we still mark them.\r\n    fragmentShader = fragmentShader.replace(\r\n      /^[ \\t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,\r\n      '\\n//!BEGIN_POST_CHUNK $1\\n$&\\n//!END_POST_CHUNK\\n'\r\n    );\r\n    fragmentShader = expandShaderIncludes(fragmentShader);\r\n  }\r\n\r\n  // Apply custom rewriter function\r\n  if (customRewriter) {\r\n    let res = customRewriter({vertexShader, fragmentShader});\r\n    vertexShader = res.vertexShader;\r\n    fragmentShader = res.fragmentShader;\r\n  }\r\n\r\n  // The fragmentColorTransform needs to go before any postprocessing chunks, so extract\r\n  // those and re-insert them into the outro in the correct place:\r\n  if (fragmentColorTransform) {\r\n    let postChunks = [];\r\n    fragmentShader = fragmentShader.replace(\r\n      /^\\/\\/!BEGIN_POST_CHUNK[^]+?^\\/\\/!END_POST_CHUNK/gm, // [^]+? = non-greedy match of any chars including newlines\r\n      match => {\r\n        postChunks.push(match);\r\n        return ''\r\n      }\r\n    );\r\n    fragmentMainOutro = `${fragmentColorTransform}\\n${postChunks.join('\\n')}\\n${fragmentMainOutro}`;\r\n  }\r\n\r\n  // Inject auto-updating time uniform if requested\r\n  if (timeUniform) {\r\n    const code = `\\nuniform float ${timeUniform};\\n`;\r\n    vertexDefs = code + vertexDefs;\r\n    fragmentDefs = code + fragmentDefs;\r\n  }\r\n\r\n  // Inject a function for the vertexTransform and rename all usages of position/normal/uv\r\n  if (vertexTransform) {\r\n    vertexDefs = `${vertexDefs}\r\nvec3 troika_position_${key};\r\nvec3 troika_normal_${key};\r\nvec2 troika_uv_${key};\r\nvoid troikaVertexTransform${key}(inout vec3 position, inout vec3 normal, inout vec2 uv) {\r\n  ${vertexTransform}\r\n}\r\n`;\r\n    vertexMainIntro = `\r\ntroika_position_${key} = vec3(position);\r\ntroika_normal_${key} = vec3(normal);\r\ntroika_uv_${key} = vec2(uv);\r\ntroikaVertexTransform${key}(troika_position_${key}, troika_normal_${key}, troika_uv_${key});\r\n${vertexMainIntro}\r\n`;\r\n    vertexShader = vertexShader.replace(/\\b(position|normal|uv)\\b/g, (match, match1, index, fullStr) => {\r\n      return /\\battribute\\s+vec[23]\\s+$/.test(fullStr.substr(0, index)) ? match1 : `troika_${match1}_${key}`\r\n    });\r\n  }\r\n\r\n  // Inject defs and intro/outro snippets\r\n  vertexShader = injectIntoShaderCode(vertexShader, key, vertexDefs, vertexMainIntro, vertexMainOutro);\r\n  fragmentShader = injectIntoShaderCode(fragmentShader, key, fragmentDefs, fragmentMainIntro, fragmentMainOutro);\r\n\r\n  return {\r\n    vertexShader,\r\n    fragmentShader\r\n  }\r\n}\r\n\r\nfunction injectIntoShaderCode(shaderCode, id, defs, intro, outro) {\r\n  if (intro || outro || defs) {\r\n    shaderCode = shaderCode.replace(voidMainRegExp, `\r\n${defs}\r\nvoid troikaOrigMain${id}() {`\r\n    );\r\n    shaderCode += `\r\nvoid main() {\r\n  ${intro}\r\n  troikaOrigMain${id}();\r\n  ${outro}\r\n}`;\r\n  }\r\n  return shaderCode\r\n}\r\n\r\n\r\nfunction optionsJsonReplacer(key, value) {\r\n  return key === 'uniforms' ? undefined : typeof value === 'function' ? value.toString() : value\r\n}\r\n\r\nlet _idCtr = 0;\r\nconst optionsHashesToIds = new Map();\r\nfunction getKeyForOptions(options) {\r\n  const optionsHash = JSON.stringify(options, optionsJsonReplacer);\r\n  let id = optionsHashesToIds.get(optionsHash);\r\n  if (id == null) {\r\n    optionsHashesToIds.set(optionsHash, (id = ++_idCtr));\r\n  }\r\n  return id\r\n}\n\n// Copied from threejs WebGLPrograms.js so we can resolve builtin materials to their shaders\r\n// TODO how can we keep this from getting stale?\r\nconst MATERIAL_TYPES_TO_SHADERS = {\r\n  MeshDepthMaterial: 'depth',\r\n  MeshDistanceMaterial: 'distanceRGBA',\r\n  MeshNormalMaterial: 'normal',\r\n  MeshBasicMaterial: 'basic',\r\n  MeshLambertMaterial: 'lambert',\r\n  MeshPhongMaterial: 'phong',\r\n  MeshToonMaterial: 'phong',\r\n  MeshStandardMaterial: 'physical',\r\n  MeshPhysicalMaterial: 'physical',\r\n  MeshMatcapMaterial: 'matcap',\r\n  LineBasicMaterial: 'basic',\r\n  LineDashedMaterial: 'dashed',\r\n  PointsMaterial: 'points',\r\n  ShadowMaterial: 'shadow',\r\n  SpriteMaterial: 'sprite'\r\n};\r\n\r\n/**\r\n * Given a Three.js `Material` instance, find the shaders/uniforms that will be\r\n * used to render that material.\r\n *\r\n * @param material - the Material instance\r\n * @return {object} - the material's shader info: `{uniforms:{}, fragmentShader:'', vertexShader:''}`\r\n */\r\nfunction getShadersForMaterial(material) {\r\n  let builtinType = MATERIAL_TYPES_TO_SHADERS[material.type];\r\n  return builtinType ? ShaderLib[builtinType] : material //TODO fallback for unknown type?\r\n}\n\n/**\r\n * Find all uniforms and their types within a shader code string.\r\n *\r\n * @param {string} shader - The shader code to parse\r\n * @return {object} mapping of uniform names to their glsl type\r\n */\r\nfunction getShaderUniformTypes(shader) {\r\n  let uniformRE = /\\buniform\\s+(int|float|vec[234])\\s+([A-Za-z_][\\w]*)/g;\r\n  let uniforms = Object.create(null);\r\n  let match;\r\n  while ((match = uniformRE.exec(shader)) !== null) {\r\n    uniforms[match[2]] = match[1];\r\n  }\r\n  return uniforms\r\n}\n\n/**\r\n * @class ShaderFloatArray\r\n *\r\n * When writing a custom WebGL shader, sometimes you need to pass it an array of floating\r\n * point numbers that it can read from. Unfortunately this is very difficult to do in WebGL,\r\n * because:\r\n *\r\n *   - GLSL \"array\" uniforms can only be of a constant length.\r\n *   - Textures can only hold floating point numbers in WebGL1 if the `OES_texture_float`\r\n *     extension is available.\r\n *\r\n * ShaderFloatArray is an array-like abstraction that encodes its floating point data into\r\n * an RGBA texture's four Uint8 components, and provides the corresponding ThreeJS uniforms\r\n * and GLSL code for you to put in your custom shader to query the float values by array index.\r\n *\r\n * This should generally only be used within a fragment shader, as some environments (e.g. iOS)\r\n * only allow texture lookups in fragment shaders.\r\n *\r\n * TODO:\r\n *   - Fix texture to fill both dimensions so we don't easily hit max texture size limits\r\n *   - Use a float texture if the extension is available so we can skip the encoding process\r\n */\r\nclass ShaderFloatArray {\r\n  constructor(name) {\r\n    this.name = name;\r\n    this.textureUniform = `dataTex_${name}`;\r\n    this.textureSizeUniform = `dataTexSize_${name}`;\r\n    this.multiplierUniform = `dataMultiplier_${name}`;\r\n\r\n    /**\r\n     * @property dataSizeUniform - the name of the GLSL uniform that will hold the\r\n     * length of the data array.\r\n     * @type {string}\r\n     */\r\n    this.dataSizeUniform = `dataSize_${name}`;\r\n\r\n    /**\r\n     * @property readFunction - the name of the GLSL function that should be called to\r\n     * read data out of the array by index.\r\n     * @type {string}\r\n     */\r\n    this.readFunction = `readData_${name}`;\r\n\r\n    this._raw = new Float32Array(0);\r\n    this._texture = new DataTexture(new Uint8Array(0), 0, 1);\r\n    this._length = 0;\r\n    this._multiplier = 1;\r\n  }\r\n\r\n  /**\r\n   * @property length - the current length of the data array\r\n   * @type {number}\r\n   */\r\n  set length(value) {\r\n    if (value !== this._length) {\r\n      // Find nearest power-of-2 that holds the new length\r\n      const size = Math.pow(2, Math.ceil(Math.log2(value)));\r\n      const raw = this._raw;\r\n      if (size < raw.length) {\r\n        this._raw = raw.subarray(0, size);\r\n      }\r\n      else if(size > raw.length) {\r\n        this._raw = new Float32Array(size);\r\n        this._raw.set(raw);\r\n      }\r\n      this._length = value;\r\n    }\r\n  }\r\n  get length() {\r\n    return this._length\r\n  }\r\n\r\n  /**\r\n   * Add a value to the end of the data array\r\n   * @param {number} value\r\n   */\r\n  push(value) {\r\n    return this.set(this.length++, value)\r\n  }\r\n\r\n  /**\r\n   * Replace the existing data with that from a new array\r\n   * @param {ArrayLike<number>} array\r\n   */\r\n  setArray(array) {\r\n    this.length = array.length;\r\n    this._raw.set(array);\r\n    this._needsRepack = true;\r\n  }\r\n\r\n  /**\r\n   * Get the current value at index\r\n   * @param {number} index\r\n   * @return {number}\r\n   */\r\n  get(index) {\r\n    return this._raw[index]\r\n  }\r\n\r\n  set(index, value) {\r\n    if (index + 1 > this._length) {\r\n      this.length = index + 1;\r\n    }\r\n    if (value !== this._raw[index]) {\r\n      this._raw[index] = value;\r\n      encodeFloatToFourInts(\r\n        value / this._multiplier,\r\n        this._texture.image.data,\r\n        index * 4\r\n      );\r\n      this._needsMultCheck = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Make a copy of this ShaderFloatArray\r\n   * @return {ShaderFloatArray}\r\n   */\r\n  clone() {\r\n    const clone = new ShaderFloatArray(this.name);\r\n    clone.setArray(this._raw);\r\n    return clone\r\n  }\r\n\r\n  /**\r\n   * Retrieve the set of Uniforms that must to be added to the target ShaderMaterial or\r\n   * DerivedMaterial, to feed the GLSL code generated by {@link #getShaderHeaderCode}.\r\n   * @return {Object}\r\n   */\r\n  getShaderUniforms() {\r\n    const me = this;\r\n    return {\r\n      [this.textureUniform]: {get value() {\r\n        me._sync();\r\n        return me._texture\r\n      }},\r\n      [this.textureSizeUniform]: {get value() {\r\n        me._sync();\r\n        return me._texture.image.width\r\n      }},\r\n      [this.dataSizeUniform]: {get value() {\r\n        me._sync();\r\n        return me.length\r\n      }},\r\n      [this.multiplierUniform]: {get value() {\r\n        me._sync();\r\n        return me._multiplier\r\n      }}\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retrieve the GLSL code that must be injected into the shader's definitions area to\r\n   * enable reading from the data array. This exposes a function with a name matching\r\n   * the {@link #readFunction} property, which other shader code can call to read values\r\n   * from the array by their index.\r\n   * @return {string}\r\n   */\r\n  getShaderHeaderCode() {\r\n    const {textureUniform, textureSizeUniform, dataSizeUniform, multiplierUniform, readFunction} = this;\r\n    return `\r\nuniform sampler2D ${textureUniform};\r\nuniform float ${textureSizeUniform};\r\nuniform float ${dataSizeUniform};\r\nuniform float ${multiplierUniform};\r\n\r\nfloat ${readFunction}(float index) {\r\n  vec2 texUV = vec2((index + 0.5) / ${textureSizeUniform}, 0.5);\r\n  vec4 pixel = texture2D(${textureUniform}, texUV);\r\n  return dot(pixel, 1.0 / vec4(1.0, 255.0, 65025.0, 16581375.0)) * ${multiplierUniform};\r\n}\r\n`\r\n  }\r\n\r\n  /**\r\n   * @private Synchronize any pending changes to the underlying DataTexture\r\n   */\r\n  _sync() {\r\n    const tex = this._texture;\r\n    const raw = this._raw;\r\n    let needsRepack = this._needsRepack;\r\n\r\n    // If the size of the raw array changed, resize the texture to match\r\n    if (raw.length !== tex.image.width) {\r\n      tex.image = {\r\n        data: new Uint8Array(raw.length * 4),\r\n        width: raw.length,\r\n        height: 1\r\n      };\r\n      needsRepack = true;\r\n    }\r\n\r\n    // If the values changed, check the multiplier. This should be a value by which\r\n    // all the values are divided to constrain them to the [0,1] range required by\r\n    // the Uint8 packing algorithm. We pick the nearest power of 2 that holds the\r\n    // maximum value for greatest accuracy.\r\n    if (needsRepack || this._needsMultCheck) {\r\n      const maxVal = this._raw.reduce((a, b) => Math.max(a, b), 0);\r\n      const mult = Math.pow(2, Math.ceil(Math.log2(maxVal)));\r\n      if (mult !== this._multiplier) {\r\n        this._multiplier = mult;\r\n        needsRepack = true;\r\n      }\r\n      tex.needsUpdate = true;\r\n      this._needsMultCheck = false;\r\n    }\r\n\r\n    // If things changed in a way we need to repack, do so\r\n    if (needsRepack) {\r\n      for (let i = 0, len = raw.length, mult = this._multiplier; i < len; i++) {\r\n        encodeFloatToFourInts(raw[i] / mult, tex.image.data, i * 4);\r\n      }\r\n      this._needsRepack = false;\r\n    }\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * Encode a floating point number into a set of four 8-bit integers.\r\n * Also see the companion decoder function #decodeFloatFromFourInts.\r\n *\r\n * This is adapted to JavaScript from the basic approach at\r\n * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\r\n * but writes out integers in the range 0-255 instead of floats in the range 0-1\r\n * so they can be more easily used in a Uint8Array for standard WebGL rgba textures.\r\n *\r\n * Some precision will necessarily be lost during the encoding and decoding process.\r\n * Testing shows that the maximum precision error is ~1.18e-10 which should be good\r\n * enough for most cases.\r\n *\r\n * @param {Number} value - the floating point number to encode. Must be in the range [0, 1]\r\n *        otherwise the results will be incorrect.\r\n * @param {Array|Uint8Array} array - an array into which the four ints should be written\r\n * @param {Number} startIndex - index in the output array at which to start writing the ints\r\n * @return {Array|Uint8Array}\r\n */\r\nfunction encodeFloatToFourInts(value, array, startIndex) {\r\n  // This is adapted to JS from the basic approach at\r\n  // http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\r\n  // but writes to a Uint8Array instead of floats. Input values must be in\r\n  // the range [0, 1]. The maximum error after encoding and decoding is ~1.18e-10\r\n  let enc0 = 255 * value;\r\n  let enc1 = 255 * (enc0 % 1);\r\n  let enc2 = 255 * (enc1 % 1);\r\n  let enc3 = 255 * (enc2 % 1);\r\n\r\n  enc0 = enc0 & 255;\r\n  enc1 = enc1 & 255;\r\n  enc2 = enc2 & 255;\r\n  enc3 = Math.round(enc3) & 255;\r\n\r\n  array[startIndex] = enc0;\r\n  array[startIndex + 1] = enc1;\r\n  array[startIndex + 2] = enc2;\r\n  array[startIndex + 3] = enc3;\r\n  return array\r\n}\n\n/*\r\nInput geometry is a cylinder with r=1, height in y dimension from 0 to 1,\r\ndivided into a reasonable number of height segments.\r\n*/\r\n\r\nconst vertexDefs = `\r\nuniform vec3 pointA;\r\nuniform vec3 controlA;\r\nuniform vec3 controlB;\r\nuniform vec3 pointB;\r\nuniform float radius;\r\nvarying float bezierT;\r\n\r\nvec3 cubicBezier(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\r\n  float t2 = 1.0 - t;\r\n  float b0 = t2 * t2 * t2;\r\n  float b1 = 3.0 * t * t2 * t2;\r\n  float b2 = 3.0 * t * t * t2;\r\n  float b3 = t * t * t;\r\n  return b0 * p1 + b1 * c1 + b2 * c2 + b3 * p2;\r\n}\r\n\r\nvec3 cubicBezierDerivative(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\r\n  float t2 = 1.0 - t;\r\n  return -3.0 * p1 * t2 * t2 +\r\n    c1 * (3.0 * t2 * t2 - 6.0 * t2 * t) +\r\n    c2 * (6.0 * t2 * t - 3.0 * t * t) +\r\n    3.0 * p2 * t * t;\r\n}\r\n`;\r\n\r\nconst vertexTransform = `\r\nfloat t = position.y;\r\nbezierT = t;\r\nvec3 bezierCenterPos = cubicBezier(pointA, controlA, controlB, pointB, t);\r\nvec3 bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t));\r\n\r\n// Make \"sideways\" always perpendicular to the camera ray; this ensures that any twists\r\n// in the cylinder occur where you won't see them: \r\nvec3 viewDirection = normalMatrix * vec3(0.0, 0.0, 1.0);\r\nif (bezierDir == viewDirection) {\r\n  bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t == 1.0 ? t - 0.0001 : t + 0.0001));\r\n}\r\nvec3 sideways = normalize(cross(bezierDir, viewDirection));\r\nvec3 upish = normalize(cross(sideways, bezierDir));\r\n\r\n// Build a matrix for transforming this disc in the cylinder:\r\nmat4 discTx;\r\ndiscTx[0].xyz = sideways * radius;\r\ndiscTx[1].xyz = bezierDir * radius;\r\ndiscTx[2].xyz = upish * radius;\r\ndiscTx[3].xyz = bezierCenterPos;\r\ndiscTx[3][3] = 1.0;\r\n\r\n// Apply transform, ignoring original y\r\nposition = (discTx * vec4(position.x, 0.0, position.z, 1.0)).xyz;\r\nnormal = normalize(mat3(discTx) * normal);\r\n`;\r\n\r\nconst fragmentDefs = `\r\nuniform vec3 dashing;\r\nvarying float bezierT;\r\n`;\r\n\r\nconst fragmentMainIntro = `\r\nif (dashing.x + dashing.y > 0.0) {\r\n  float dashFrac = mod(bezierT - dashing.z, dashing.x + dashing.y);\r\n  if (dashFrac > dashing.x) {\r\n    discard;\r\n  }\r\n}\r\n`;\r\n\r\n// Debugging: separate color for each of the 6 sides:\r\n// const fragmentColorTransform = `\r\n// float sideNum = floor(vUV.x * 6.0);\r\n// vec3 mixColor = sideNum < 1.0 ? vec3(1.0, 0.0, 0.0) :\r\n//   sideNum < 2.0 ? vec3(0.0, 1.0, 1.0) :\r\n//   sideNum < 3.0 ? vec3(1.0, 1.0, 0.0) :\r\n//   sideNum < 4.0 ? vec3(0.0, 0.0, 1.0) :\r\n//   sideNum < 5.0 ? vec3(0.0, 1.0, 0.0) :\r\n//   vec3(1.0, 0.0, 1.0);\r\n// gl_FragColor.xyz = mix(gl_FragColor.xyz, mixColor, 0.5);\r\n// `\r\n\r\n\r\n\r\nfunction createBezierMeshMaterial(baseMaterial) {\r\n  return createDerivedMaterial(\r\n    baseMaterial,\r\n    {\r\n      chained: true,\r\n      uniforms: {\r\n        pointA: {value: new Vector3()},\r\n        controlA: {value: new Vector3()},\r\n        controlB: {value: new Vector3()},\r\n        pointB: {value: new Vector3()},\r\n        radius: {value: 0.01},\r\n        dashing: {value: new Vector3()} //on, off, offset\r\n      },\r\n      vertexDefs,\r\n      vertexTransform,\r\n      fragmentDefs,\r\n      fragmentMainIntro\r\n    }\r\n  )\r\n}\n\nlet geometry = null;\r\n\r\nconst defaultBaseMaterial = /*#__PURE__*/new MeshStandardMaterial({color: 0xffffff, side: DoubleSide});\r\n\r\n\r\n/**\r\n * A ThreeJS `Mesh` that bends a tube shape along a 3D cubic bezier path. The bending is done\r\n * by deforming a straight cylindrical geometry in the vertex shader based on a set of four\r\n * control point uniforms. It patches the necessary GLSL into the mesh's assigned `material`\r\n * automatically.\r\n *\r\n * The cubiz bezier path is determined by its four `Vector3` properties:\r\n * - `pointA`\r\n * - `controlA`\r\n * - `controlB`\r\n * - `pointB`\r\n *\r\n * The tube's radius is controlled by its `radius` property, which defaults to `0.01`.\r\n *\r\n * You can also give the tube a dashed appearance with two properties:\r\n *\r\n * - `dashArray` - an array of two numbers, defining the length of \"on\" and \"off\" parts of\r\n *   the dash. Each is a 0-1 ratio of the entire path's length. (Actually this is the `t` length\r\n *   used as input to the cubic bezier function, not its visible length.)\r\n * - `dashOffset` - offset of where the dash starts. You can animate this to make the dashes move.\r\n *\r\n * Note that the dashes will appear like a hollow tube, not solid. This will be more apparent on\r\n * thicker tubes.\r\n *\r\n * TODO: proper geometry bounding sphere and raycasting\r\n * TODO: allow control of the geometry's segment counts\r\n */\r\nclass BezierMesh extends Mesh {\r\n  static getGeometry() {\r\n    return geometry || (geometry =\r\n      new CylinderBufferGeometry(1, 1, 1, 6, 64).translate(0, 0.5, 0)\r\n    )\r\n  }\r\n\r\n  constructor() {\r\n    super(\r\n      BezierMesh.getGeometry(),\r\n      defaultBaseMaterial\r\n    );\r\n\r\n    this.pointA = new Vector3();\r\n    this.controlA = new Vector3();\r\n    this.controlB = new Vector3();\r\n    this.pointB = new Vector3();\r\n    this.radius = 0.01;\r\n    this.dashArray = new Vector2();\r\n    this.dashOffset = 0;\r\n\r\n    // TODO - disabling frustum culling until I figure out how to customize the\r\n    //  geometry's bounding sphere that gets used\r\n    this.frustumCulled = false;\r\n  }\r\n\r\n  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping\r\n  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.\r\n  get material() {\r\n    let derivedMaterial = this._derivedMaterial;\r\n    const baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultBaseMaterial.clone());\r\n    if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {\r\n      derivedMaterial = this._derivedMaterial = createBezierMeshMaterial(baseMaterial);\r\n      // dispose the derived material when its base material is disposed:\r\n      baseMaterial.addEventListener('dispose', function onDispose() {\r\n        baseMaterial.removeEventListener('dispose', onDispose);\r\n        derivedMaterial.dispose();\r\n      });\r\n    }\r\n    return derivedMaterial\r\n  }\r\n  set material(baseMaterial) {\r\n    this._baseMaterial = baseMaterial;\r\n  }\r\n\r\n  // Create and update material for shadows upon request:\r\n  get customDepthMaterial() {\r\n    return this.material.getDepthMaterial()\r\n  }\r\n  get customDistanceMaterial() {\r\n    return this.material.getDistanceMaterial()\r\n  }\r\n\r\n  onBeforeRender(shaderInfo) {\r\n    const {uniforms} = this.material;\r\n    const {pointA, controlA, controlB, pointB, radius, dashArray, dashOffset} = this;\r\n    uniforms.pointA.value.copy(pointA);\r\n    uniforms.controlA.value.copy(controlA);\r\n    uniforms.controlB.value.copy(controlB);\r\n    uniforms.pointB.value.copy(pointB);\r\n    uniforms.radius.value = radius;\r\n    uniforms.dashing.value.set(dashArray.x, dashArray.y, dashOffset || 0);\r\n  }\r\n\r\n  raycast(raycaster, intersects) {\r\n    // TODO - just fail for now\r\n  }\r\n}\n\nexport { BezierMesh, ShaderFloatArray, createDerivedMaterial, expandShaderIncludes, getShaderUniformTypes, getShadersForMaterial, voidMainRegExp };\n"]},"metadata":{},"sourceType":"module"}