{"ast":null,"code":"const t = Symbol(),\n      e = Symbol(),\n      r = Symbol(),\n      n = Object.getPrototypeOf,\n      s = new WeakMap(),\n      o = t => t && (n(t) === Object.prototype || n(t) === Array.prototype || !!s.get(t)),\n      i = t => \"object\" == typeof t && null !== t,\n      c = n => {\n  const s = {\n    o: n,\n    t: !1,\n\n    r(t) {\n      if (!this.t) {\n        let e = this.a.get(this.o);\n        e || (e = new Set(), this.a.set(this.o, e)), e.add(t);\n      }\n    },\n\n    u() {\n      this.t = !0, this.a.delete(this.o);\n    },\n\n    get(t, e) {\n      return e === r ? this.o : (this.r(e), l(t[e], this.a, this.c));\n    },\n\n    has(t, r) {\n      return r === e ? (this.u(), !0) : (this.r(r), r in t);\n    },\n\n    ownKeys(e) {\n      return this.r(t), Reflect.ownKeys(e);\n    }\n\n  };\n  return Object.isFrozen(n) && (s.set = s.deleteProperty = () => !1), s;\n},\n      l = (t, e, s) => {\n  if (!o(t)) return t;\n  const i = t[r] || t;\n  let l = s && s.get(i);\n  return l || (l = c(i), l.p = new Proxy((t => Object.isFrozen(t) ? Array.isArray(t) ? Array.from(t) : Object.create(n(t), (t => {\n    const e = Object.getOwnPropertyDescriptors(t);\n    return Object.values(e).forEach(t => {\n      t.configurable = !0;\n    }), e;\n  })(t)) : t)(i), l), s && s.set(i, l)), l.a = e, l.c = s, l.p;\n},\n      u = (t, e) => {\n  const r = Reflect.ownKeys(t),\n        n = Reflect.ownKeys(e);\n  return r.length !== n.length || r.some((t, e) => t !== n[e]);\n},\n      h = 1,\n      a = 2,\n      f = 4,\n      y = 8,\n      g = (e, r, n, s, o = 0) => {\n  if (Object.is(e, r) && (!i(e) || 0 == (2 & o))) return !1;\n  if (!i(e) || !i(r)) return !0;\n  const c = n.get(e);\n  if (!c) return 0 == (1 & o);\n\n  if (s && 0 == (2 & o)) {\n    const t = s.get(e);\n    if (t && t.n === r) return t.g;\n    s.set(e, {\n      n: r,\n      g: !1\n    });\n  }\n\n  let l = null;\n\n  for (const i of c) {\n    const c = i === t ? u(e, r) : g(e[i], r[i], n, s, o >>> 2 << 2 | o >>> 2);\n    if (!0 !== c && !1 !== c || (l = c), l) break;\n  }\n\n  return null === l && (l = 0 == (1 & o)), s && 0 == (2 & o) && s.set(e, {\n    n: r,\n    g: l\n  }), l;\n},\n      b = t => !!o(t) && e in t,\n      p = t => o(t) && t[r] || null,\n      O = t => {\n  s.set(t, !0);\n},\n      j = (t, e) => {\n  const r = [],\n        n = (t, s) => {\n    const o = e.get(t);\n    o ? o.forEach(e => {\n      n(t[e], s ? [...s, e] : [e]);\n    }) : s && r.push(s);\n  };\n\n  return n(t), r;\n};\n\nexport { h as MODE_ASSUME_UNCHANGED_IF_UNAFFECTED, f as MODE_ASSUME_UNCHANGED_IF_UNAFFECTED_IN_DEEP, a as MODE_IGNORE_REF_EQUALITY, y as MODE_IGNORE_REF_EQUALITY_IN_DEEP, j as affectedToPathList, l as createDeepProxy, p as getUntrackedObject, g as isDeepChanged, O as markToTrack, b as trackMemo };","map":{"version":3,"sources":["../src/index.ts"],"names":["OWN_KEYS_SYMBOL","Symbol","TRACK_MEMO_SYMBOL","GET_ORIGINAL_SYMBOL","getProto","Object","getPrototypeOf","objectsToTrack","WeakMap","isObjectToTrack","obj","prototype","Array","get","isObject","x","descriptors","getOwnPropertyDescriptors","values","forEach","descriptor","configurable","isFrozen","isArray","from","create","createProxyHandler","origObj","handler","o","t","[object Object]","key","this","used","Set","set","add","delete","target","createDeepProxy","has","ownKeys","Reflect","deleteProperty","affected","proxyCache","proxyHandler","Proxy","isOwnKeysChanged","nextObj","origKeys","nextKeys","length","some","k","i","MODE_ASSUME_UNCHANGED_IF_UNAFFECTED","MODE_IGNORE_REF_EQUALITY","MODE_ASSUME_UNCHANGED_IF_UNAFFECTED_IN_DEEP","MODE_IGNORE_REF_EQUALITY_IN_DEEP","isDeepChanged","cache","mode","is","hit","n","g","changed","c","trackMemo","getUntrackedObject","markToTrack","affectedToPathList","list","walk","path","push"],"mappings":"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","sourcesContent":["// symbols\nconst OWN_KEYS_SYMBOL = Symbol();\nconst TRACK_MEMO_SYMBOL = Symbol();\nconst GET_ORIGINAL_SYMBOL = Symbol();\n\n// properties\nconst TRACK_OBJECT_PROPERTY = 't';\nconst AFFECTED_PROPERTY = 'a';\nconst RECORD_USAGE_PROPERTY = 'r';\nconst RECORD_OBJECT_AS_USED_PROPERTY = 'u';\nconst ORIGINAL_OBJECT_PROPERTY = 'o';\nconst PROXY_PROPERTY = 'p';\nconst PROXY_CACHE_PROPERTY = 'c';\nconst NEXT_OBJECT_PROPERTY = 'n';\nconst CHANGED_PROPERTY = 'g';\n\n// get object prototype\nconst getProto = Object.getPrototypeOf;\n\nconst objectsToTrack = new WeakMap<object, boolean>();\n\n// check if obj is a plain object or an array\nconst isObjectToTrack = <T>(obj: T): obj is T extends object ? T : never => (\n  obj && (\n    getProto(obj) === Object.prototype\n    || getProto(obj) === Array.prototype\n    || !!objectsToTrack.get(obj as unknown as object)\n  )\n);\n\n// check if it is object\nconst isObject = (x: unknown): x is object => (\n  typeof x === 'object' && x !== null\n);\n\nconst getPropDescs = (obj: object) => {\n  const descriptors = Object.getOwnPropertyDescriptors(obj);\n  Object.values(descriptors).forEach((descriptor) => {\n    descriptor.configurable = true;\n  });\n  return descriptors;\n};\n\n// copy obj if frozen\nconst unfreeze = (obj: object) => (\n  !Object.isFrozen(obj) ? obj\n    : Array.isArray(obj) ? Array.from(obj)\n      : /* otherwise */ Object.create(getProto(obj), getPropDescs(obj))\n);\n\ntype Affected = WeakMap<object, Set<string | number | symbol>>;\ntype ProxyCache<T extends object> = WeakMap<object, ProxyHandler<T>>;\ntype ProxyHandler<T extends object> = {\n  [PROXY_PROPERTY]?: T;\n  [PROXY_CACHE_PROPERTY]?: ProxyCache<object>;\n  [AFFECTED_PROPERTY]?: Affected;\n  [TRACK_OBJECT_PROPERTY]: boolean;\n  [ORIGINAL_OBJECT_PROPERTY]: T;\n  [RECORD_USAGE_PROPERTY](key: string | number | symbol): void;\n  [RECORD_OBJECT_AS_USED_PROPERTY](): void;\n  get(target: T, key: string | number | symbol): unknown;\n  has(target: T, key: string | number | symbol): boolean;\n  ownKeys(target: T): (string | number | symbol)[];\n  set?(target: T, key: string | number | symbol, value: unknown): boolean;\n  deleteProperty?(target: T, key: string | number | symbol): boolean;\n};\n\nconst createProxyHandler = <T extends object>(origObj: T) => {\n  const handler: ProxyHandler<T> = {\n    [ORIGINAL_OBJECT_PROPERTY]: origObj,\n    [TRACK_OBJECT_PROPERTY]: false, // for trackMemo\n    [RECORD_USAGE_PROPERTY](key) {\n      if (!this[TRACK_OBJECT_PROPERTY]) {\n        let used = (this[AFFECTED_PROPERTY] as Affected).get(this[ORIGINAL_OBJECT_PROPERTY]);\n        if (!used) {\n          used = new Set();\n          (this[AFFECTED_PROPERTY] as Affected).set(this[ORIGINAL_OBJECT_PROPERTY], used);\n        }\n        used.add(key);\n      }\n    },\n    [RECORD_OBJECT_AS_USED_PROPERTY]() {\n      this[TRACK_OBJECT_PROPERTY] = true;\n      (this[AFFECTED_PROPERTY] as Affected).delete(this[ORIGINAL_OBJECT_PROPERTY]);\n    },\n    get(target, key) {\n      if (key === GET_ORIGINAL_SYMBOL) {\n        return this[ORIGINAL_OBJECT_PROPERTY];\n      }\n      this[RECORD_USAGE_PROPERTY](key);\n      return createDeepProxy(\n        (target as any)[key],\n        (this[AFFECTED_PROPERTY] as Affected),\n        this[PROXY_CACHE_PROPERTY],\n      );\n    },\n    has(target, key) {\n      if (key === TRACK_MEMO_SYMBOL) {\n        this[RECORD_OBJECT_AS_USED_PROPERTY]();\n        return true;\n      }\n      // LIMITATION:\n      // We simply record the same as get.\n      // This means { a: {} } and { a: {} } is detected as changed,\n      // if 'a' in obj is handled.\n      this[RECORD_USAGE_PROPERTY](key);\n      return key in target;\n    },\n    ownKeys(target) {\n      this[RECORD_USAGE_PROPERTY](OWN_KEYS_SYMBOL);\n      return Reflect.ownKeys(target);\n    },\n  };\n  if (Object.isFrozen(origObj)) {\n    handler.set = handler.deleteProperty = () => false;\n  }\n  return handler;\n};\n\n/**\n * create a proxy\n *\n * It will recursively create a proxy upon access.\n *\n * @example\n * import { createDeepProxy } from 'proxy-compare';\n *\n * const obj = ...;\n * const affected = new WeakMap();\n * const proxy = createDeepProxy(obj, affected);\n */\nexport const createDeepProxy = <T>(\n  obj: T,\n  affected: WeakMap<object, unknown>,\n  proxyCache?: WeakMap<object, unknown>,\n): T => {\n  if (!isObjectToTrack(obj)) return obj;\n  const origObj = (\n    obj as { [GET_ORIGINAL_SYMBOL]?: typeof obj }\n  )[GET_ORIGINAL_SYMBOL]; // unwrap proxy\n  const target = origObj || obj;\n  let proxyHandler: ProxyHandler<typeof target> | undefined = (\n    proxyCache && (proxyCache as ProxyCache<typeof target>).get(target)\n  );\n  if (!proxyHandler) {\n    proxyHandler = createProxyHandler<T extends object ? T : never>(target);\n    proxyHandler[PROXY_PROPERTY] = new Proxy(unfreeze(target), proxyHandler) as typeof target;\n    if (proxyCache) {\n      proxyCache.set(target, proxyHandler);\n    }\n  }\n  proxyHandler[AFFECTED_PROPERTY] = affected as Affected;\n  proxyHandler[PROXY_CACHE_PROPERTY] = proxyCache as ProxyCache<object> | undefined;\n  return proxyHandler[PROXY_PROPERTY] as typeof target;\n};\n\nconst isOwnKeysChanged = (origObj: object, nextObj: object) => {\n  const origKeys = Reflect.ownKeys(origObj);\n  const nextKeys = Reflect.ownKeys(nextObj);\n  return origKeys.length !== nextKeys.length\n    || origKeys.some((k, i) => k !== nextKeys[i]);\n};\n\nexport const MODE_ASSUME_UNCHANGED_IF_UNAFFECTED = /*   */ 0b00001;\nexport const MODE_IGNORE_REF_EQUALITY = /*              */ 0b00010;\n\nconst IN_DEEP_SHIFT = 2;\nexport const MODE_ASSUME_UNCHANGED_IF_UNAFFECTED_IN_DEEP = (\n  MODE_ASSUME_UNCHANGED_IF_UNAFFECTED << IN_DEEP_SHIFT\n);\nexport const MODE_IGNORE_REF_EQUALITY_IN_DEEP = (\n  MODE_IGNORE_REF_EQUALITY << IN_DEEP_SHIFT\n);\n\ntype DeepChangedCache = WeakMap<object, {\n  [NEXT_OBJECT_PROPERTY]: object;\n  [CHANGED_PROPERTY]: boolean;\n}>;\n\n/**\n * compare two object\n *\n * It will compare only with affected object properties\n *\n * @example\n * import { isDeepChanged } from 'proxy-compare';\n *\n * const objToCompare = ...;\n * const changed = isDeepChanged(obj, objToCompare, affected);\n */\nexport const isDeepChanged = (\n  origObj: unknown,\n  nextObj: unknown,\n  affected: WeakMap<object, unknown>,\n  cache?: WeakMap<object, unknown>,\n  mode = 0,\n): boolean => {\n  if (Object.is(origObj, nextObj) && (\n    !isObject(origObj) || (mode & MODE_IGNORE_REF_EQUALITY) === 0)\n  ) {\n    return false;\n  }\n  if (!isObject(origObj) || !isObject(nextObj)) return true;\n  const used = (affected as Affected).get(origObj);\n  if (!used) return (mode & MODE_ASSUME_UNCHANGED_IF_UNAFFECTED) === 0;\n  if (cache && (mode & MODE_IGNORE_REF_EQUALITY) === 0) {\n    const hit = (cache as DeepChangedCache).get(origObj);\n    if (hit && hit[NEXT_OBJECT_PROPERTY] === nextObj) {\n      return hit[CHANGED_PROPERTY];\n    }\n    // for object with cycles\n    (cache as DeepChangedCache).set(origObj, {\n      [NEXT_OBJECT_PROPERTY]: nextObj,\n      [CHANGED_PROPERTY]: false,\n    });\n  }\n  let changed: boolean | null = null;\n  // eslint-disable-next-line no-restricted-syntax\n  for (const key of used) {\n    const c = key === OWN_KEYS_SYMBOL ? isOwnKeysChanged(origObj, nextObj)\n      : isDeepChanged(\n        (origObj as any)[key],\n        (nextObj as any)[key],\n        affected,\n        cache,\n        ((mode >>> IN_DEEP_SHIFT) << IN_DEEP_SHIFT) | (mode >>> IN_DEEP_SHIFT),\n      );\n    if (c === true || c === false) changed = c;\n    if (changed) break;\n  }\n  if (changed === null) changed = (mode & MODE_ASSUME_UNCHANGED_IF_UNAFFECTED) === 0;\n  if (cache && (mode & MODE_IGNORE_REF_EQUALITY) === 0) {\n    cache.set(origObj, {\n      [NEXT_OBJECT_PROPERTY]: nextObj,\n      [CHANGED_PROPERTY]: changed,\n    });\n  }\n  return changed;\n};\n\n// explicitly track object with memo\nexport const trackMemo = (obj: unknown) => {\n  if (isObjectToTrack(obj)) {\n    return TRACK_MEMO_SYMBOL in obj;\n  }\n  return false;\n};\n\n// get original object from proxy\nexport const getUntrackedObject = <T>(obj: T): T | null => {\n  if (isObjectToTrack(obj)) {\n    return (obj as { [GET_ORIGINAL_SYMBOL]?: T })[GET_ORIGINAL_SYMBOL] || null;\n  }\n  return null;\n};\n\n// mark object to track (even if it is not plain)\nexport const markToTrack = (obj: object) => {\n  objectsToTrack.set(obj, true);\n};\n\n// convert affected to path list\nexport const affectedToPathList = (\n  obj: unknown,\n  affected: WeakMap<object, unknown>,\n) => {\n  const list: (string | number | symbol)[][] = [];\n  const walk = (x: unknown, path?: (string | number | symbol)[]) => {\n    const used = (affected as Affected).get(x as object);\n    if (used) {\n      used.forEach((key) => {\n        walk((x as any)[key], path ? [...path, key] : [key]);\n      });\n    } else if (path) {\n      list.push(path);\n    }\n  };\n  walk(obj);\n  return list;\n};\n"]},"metadata":{},"sourceType":"module"}