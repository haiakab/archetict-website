{"ast":null,"code":"import { strToU8, zipSync } from 'fflate';\n\nclass USDZExporter {\n  async parse(scene) {\n    let output = buildHeader();\n    const materials = {};\n    const textures = {};\n    scene.traverse(object => {\n      if (object.isMesh) {\n        const geometry = object.geometry;\n        const material = object.material;\n        materials[material.uuid] = material;\n        if (material.map !== null) textures[material.map.uuid] = material.map;\n        if (material.normalMap !== null) textures[material.normalMap.uuid] = material.normalMap;\n        if (material.aoMap !== null) textures[material.aoMap.uuid] = material.aoMap;\n        if (material.roughnessMap !== null) textures[material.roughnessMap.uuid] = material.roughnessMap;\n        if (material.metalnessMap !== null) textures[material.metalnessMap.uuid] = material.metalnessMap;\n        if (material.emissiveMap !== null) textures[material.emissiveMap.uuid] = material.emissiveMap;\n        output += buildXform(object, buildMesh(geometry, material));\n      }\n    });\n    output += buildMaterials(materials);\n    output += buildTextures(textures);\n    const files = {\n      'model.usda': strToU8(output)\n    };\n\n    for (let uuid in textures) {\n      const texture = textures[uuid];\n      files[`textures/Texture_${texture.id}.jpg`] = await imgToU8(texture.image);\n    } // 64 byte alignment\n    // https://github.com/101arrowz/fflate/issues/39#issuecomment-777263109\n\n\n    let offset = 0;\n\n    for (let filename in files) {\n      const file = files[filename];\n      const headerSize = 34 + filename.length;\n      offset += headerSize;\n      const offsetMod64 = offset & 63;\n\n      if (offsetMod64 !== 4) {\n        const padLength = 64 - offsetMod64;\n        const padding = new Uint8Array(padLength);\n        files[filename] = [file, {\n          extra: {\n            12345: padding\n          }\n        }];\n      }\n\n      offset = file.length;\n    }\n\n    return zipSync(files, {\n      level: 0\n    });\n  }\n\n}\n\nasync function imgToU8(image) {\n  if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n    const scale = 1024 / Math.max(image.width, image.height);\n    const canvas = document.createElement('canvas');\n    canvas.width = image.width * Math.min(1, scale);\n    canvas.height = image.height * Math.min(1, scale);\n    const context = canvas.getContext('2d');\n    context.drawImage(image, 0, 0, canvas.width, canvas.height);\n    const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 1));\n    return new Uint8Array(await blob.arrayBuffer());\n  }\n} //\n\n\nconst PRECISION = 7;\n\nfunction buildHeader() {\n  return `#usda 1.0\n(\n    customLayerData = {\n        string creator = \"Three.js USDZExporter\"\n    }\n    metersPerUnit = 1\n    upAxis = \"Y\"\n)\n\n`;\n} // Xform\n\n\nfunction buildXform(object, define) {\n  const name = `Object_${object.id}`;\n  const transform = buildMatrix(object.matrixWorld);\n  return `def Xform \"${name}\"\n{\n    matrix4d xformOp:transform = ${transform}\n    uniform token[] xformOpOrder = [\"xformOp:transform\"]\n\n    ${define}\n}\n\n`;\n}\n\nfunction buildMatrix(matrix) {\n  const array = matrix.elements;\n  return `( ${buildMatrixRow(array, 0)}, ${buildMatrixRow(array, 4)}, ${buildMatrixRow(array, 8)}, ${buildMatrixRow(array, 12)} )`;\n}\n\nfunction buildMatrixRow(array, offset) {\n  return `(${array[offset + 0]}, ${array[offset + 1]}, ${array[offset + 2]}, ${array[offset + 3]})`;\n} // Mesh\n\n\nfunction buildMesh(geometry, material) {\n  const name = `Geometry_${geometry.id}`;\n  const attributes = geometry.attributes;\n  const count = attributes.position.count;\n\n  if ('uv2' in attributes) {\n    console.warn('THREE.USDZExporter: uv2 not supported yet.');\n  }\n\n  return `def Mesh \"${name}\"\n    {\n        int[] faceVertexCounts = [${buildMeshVertexCount(geometry)}]\n        int[] faceVertexIndices = [${buildMeshVertexIndices(geometry)}]\n        rel material:binding = </Materials/Material_${material.id}>\n        normal3f[] normals = [${buildVector3Array(attributes.normal, count)}] (\n            interpolation = \"vertex\"\n        )\n        point3f[] points = [${buildVector3Array(attributes.position, count)}]\n        float2[] primvars:st = [${buildVector2Array(attributes.uv, count)}] (\n            interpolation = \"vertex\"\n        )\n        uniform token subdivisionScheme = \"none\"\n    }\n`;\n}\n\nfunction buildMeshVertexCount(geometry) {\n  const count = geometry.index !== null ? geometry.index.array.length : geometry.attributes.position.count;\n  return Array(count / 3).fill(3).join(', ');\n}\n\nfunction buildMeshVertexIndices(geometry) {\n  if (geometry.index !== null) {\n    return geometry.index.array.join(', ');\n  }\n\n  const array = [];\n  const length = geometry.attributes.position.count;\n\n  for (let i = 0; i < length; i++) {\n    array.push(i);\n  }\n\n  return array.join(', ');\n}\n\nfunction buildVector3Array(attribute, count) {\n  if (attribute === undefined) {\n    console.warn('USDZExporter: Normals missing.');\n    return Array(count).fill('(0, 0, 0)').join(', ');\n  }\n\n  const array = [];\n  const data = attribute.array;\n\n  for (let i = 0; i < data.length; i += 3) {\n    array.push(`(${data[i + 0].toPrecision(PRECISION)}, ${data[i + 1].toPrecision(PRECISION)}, ${data[i + 2].toPrecision(PRECISION)})`);\n  }\n\n  return array.join(', ');\n}\n\nfunction buildVector2Array(attribute, count) {\n  if (attribute === undefined) {\n    console.warn('USDZExporter: UVs missing.');\n    return Array(count).fill('(0, 0)').join(', ');\n  }\n\n  const array = [];\n  const data = attribute.array;\n\n  for (let i = 0; i < data.length; i += 2) {\n    array.push(`(${data[i + 0].toPrecision(PRECISION)}, ${1 - data[i + 1].toPrecision(PRECISION)})`);\n  }\n\n  return array.join(', ');\n} // Materials\n\n\nfunction buildMaterials(materials) {\n  const array = [];\n\n  for (let uuid in materials) {\n    const material = materials[uuid];\n    array.push(buildMaterial(material));\n  }\n\n  return `def \"Materials\"\n{\n${array.join('')}\n}\n\n`;\n}\n\nfunction buildMaterial(material) {\n  // https://graphics.pixar.com/usd/docs/UsdPreviewSurface-Proposal.html\n  const pad = '            ';\n  const parameters = [];\n\n  if (material.map !== null) {\n    parameters.push(`${pad}color3f inputs:diffuseColor.connect = </Textures/Texture_${material.map.id}.outputs:rgb>`);\n  } else {\n    parameters.push(`${pad}color3f inputs:diffuseColor = ${buildColor(material.color)}`);\n  }\n\n  if (material.emissiveMap !== null) {\n    parameters.push(`${pad}color3f inputs:emissiveColor.connect = </Textures/Texture_${material.emissiveMap.id}.outputs:rgb>`);\n  } else if (material.emissive.getHex() > 0) {\n    parameters.push(`${pad}color3f inputs:emissiveColor = ${buildColor(material.emissive)}`);\n  }\n\n  if (material.normalMap !== null) {\n    parameters.push(`${pad}normal3f inputs:normal.connect = </Textures/Texture_${material.normalMap.id}.outputs:rgb>`);\n  }\n\n  if (material.aoMap !== null) {\n    parameters.push(`${pad}float inputs:occlusion.connect = </Textures/Texture_${material.aoMap.id}.outputs:r>`);\n  }\n\n  if (material.roughnessMap !== null) {\n    parameters.push(`${pad}float inputs:roughness.connect = </Textures/Texture_${material.roughnessMap.id}.outputs:g>`);\n  } else {\n    parameters.push(`${pad}float inputs:roughness = ${material.roughness}`);\n  }\n\n  if (material.metalnessMap !== null) {\n    parameters.push(`${pad}float inputs:metallic.connect = </Textures/Texture_${material.metalnessMap.id}.outputs:b>`);\n  } else {\n    parameters.push(`${pad}float inputs:metallic = ${material.metalness}`);\n  }\n\n  return `\n    def Material \"Material_${material.id}\"\n    {\n        token outputs:surface.connect = </Materials/Material_${material.id}/PreviewSurface.outputs:surface>\n\n        def Shader \"PreviewSurface\"\n        {\n            uniform token info:id = \"UsdPreviewSurface\"\n${parameters.join('\\n')}\n            int inputs:useSpecularWorkflow = 0\n            token outputs:surface\n        }\n    }\n`;\n}\n\nfunction buildTextures(textures) {\n  const array = [];\n\n  for (let uuid in textures) {\n    const texture = textures[uuid];\n    array.push(buildTexture(texture));\n  }\n\n  return `def \"Textures\"\n{\n${array.join('')}\n}\n\n`;\n}\n\nfunction buildTexture(texture) {\n  return `\n    def Shader \"Texture_${texture.id}\"\n    {\n        uniform token info:id = \"UsdUVTexture\"\n        asset inputs:file = @textures/Texture_${texture.id}.jpg@\n        token inputs:wrapS = \"repeat\"\n        token inputs:wrapT = \"repeat\"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n    }\n`;\n}\n\nfunction buildColor(color) {\n  return `(${color.r}, ${color.g}, ${color.b})`;\n}\n\nexport { USDZExporter };","map":{"version":3,"sources":["/Users/haiakablan/Documents/לוטוס/קורס/Architecture-web/node_modules/three-stdlib/exporters/USDZExporter.js"],"names":["strToU8","zipSync","USDZExporter","parse","scene","output","buildHeader","materials","textures","traverse","object","isMesh","geometry","material","uuid","map","normalMap","aoMap","roughnessMap","metalnessMap","emissiveMap","buildXform","buildMesh","buildMaterials","buildTextures","files","texture","id","imgToU8","image","offset","filename","file","headerSize","length","offsetMod64","padLength","padding","Uint8Array","extra","level","HTMLImageElement","HTMLCanvasElement","OffscreenCanvas","ImageBitmap","scale","Math","max","width","height","canvas","document","createElement","min","context","getContext","drawImage","blob","Promise","resolve","toBlob","arrayBuffer","PRECISION","define","name","transform","buildMatrix","matrixWorld","matrix","array","elements","buildMatrixRow","attributes","count","position","console","warn","buildMeshVertexCount","buildMeshVertexIndices","buildVector3Array","normal","buildVector2Array","uv","index","Array","fill","join","i","push","attribute","undefined","data","toPrecision","buildMaterial","pad","parameters","buildColor","color","emissive","getHex","roughness","metalness","buildTexture","r","g","b"],"mappings":"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","sourcesContent":["import { strToU8, zipSync } from 'fflate';\n\nclass USDZExporter {\n  async parse(scene) {\n    let output = buildHeader();\n    const materials = {};\n    const textures = {};\n    scene.traverse(object => {\n      if (object.isMesh) {\n        const geometry = object.geometry;\n        const material = object.material;\n        materials[material.uuid] = material;\n        if (material.map !== null) textures[material.map.uuid] = material.map;\n        if (material.normalMap !== null) textures[material.normalMap.uuid] = material.normalMap;\n        if (material.aoMap !== null) textures[material.aoMap.uuid] = material.aoMap;\n        if (material.roughnessMap !== null) textures[material.roughnessMap.uuid] = material.roughnessMap;\n        if (material.metalnessMap !== null) textures[material.metalnessMap.uuid] = material.metalnessMap;\n        if (material.emissiveMap !== null) textures[material.emissiveMap.uuid] = material.emissiveMap;\n        output += buildXform(object, buildMesh(geometry, material));\n      }\n    });\n    output += buildMaterials(materials);\n    output += buildTextures(textures);\n    const files = {\n      'model.usda': strToU8(output)\n    };\n\n    for (let uuid in textures) {\n      const texture = textures[uuid];\n      files[`textures/Texture_${texture.id}.jpg`] = await imgToU8(texture.image);\n    } // 64 byte alignment\n    // https://github.com/101arrowz/fflate/issues/39#issuecomment-777263109\n\n\n    let offset = 0;\n\n    for (let filename in files) {\n      const file = files[filename];\n      const headerSize = 34 + filename.length;\n      offset += headerSize;\n      const offsetMod64 = offset & 63;\n\n      if (offsetMod64 !== 4) {\n        const padLength = 64 - offsetMod64;\n        const padding = new Uint8Array(padLength);\n        files[filename] = [file, {\n          extra: {\n            12345: padding\n          }\n        }];\n      }\n\n      offset = file.length;\n    }\n\n    return zipSync(files, {\n      level: 0\n    });\n  }\n\n}\n\nasync function imgToU8(image) {\n  if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n    const scale = 1024 / Math.max(image.width, image.height);\n    const canvas = document.createElement('canvas');\n    canvas.width = image.width * Math.min(1, scale);\n    canvas.height = image.height * Math.min(1, scale);\n    const context = canvas.getContext('2d');\n    context.drawImage(image, 0, 0, canvas.width, canvas.height);\n    const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 1));\n    return new Uint8Array(await blob.arrayBuffer());\n  }\n} //\n\n\nconst PRECISION = 7;\n\nfunction buildHeader() {\n  return `#usda 1.0\n(\n    customLayerData = {\n        string creator = \"Three.js USDZExporter\"\n    }\n    metersPerUnit = 1\n    upAxis = \"Y\"\n)\n\n`;\n} // Xform\n\n\nfunction buildXform(object, define) {\n  const name = `Object_${object.id}`;\n  const transform = buildMatrix(object.matrixWorld);\n  return `def Xform \"${name}\"\n{\n    matrix4d xformOp:transform = ${transform}\n    uniform token[] xformOpOrder = [\"xformOp:transform\"]\n\n    ${define}\n}\n\n`;\n}\n\nfunction buildMatrix(matrix) {\n  const array = matrix.elements;\n  return `( ${buildMatrixRow(array, 0)}, ${buildMatrixRow(array, 4)}, ${buildMatrixRow(array, 8)}, ${buildMatrixRow(array, 12)} )`;\n}\n\nfunction buildMatrixRow(array, offset) {\n  return `(${array[offset + 0]}, ${array[offset + 1]}, ${array[offset + 2]}, ${array[offset + 3]})`;\n} // Mesh\n\n\nfunction buildMesh(geometry, material) {\n  const name = `Geometry_${geometry.id}`;\n  const attributes = geometry.attributes;\n  const count = attributes.position.count;\n\n  if ('uv2' in attributes) {\n    console.warn('THREE.USDZExporter: uv2 not supported yet.');\n  }\n\n  return `def Mesh \"${name}\"\n    {\n        int[] faceVertexCounts = [${buildMeshVertexCount(geometry)}]\n        int[] faceVertexIndices = [${buildMeshVertexIndices(geometry)}]\n        rel material:binding = </Materials/Material_${material.id}>\n        normal3f[] normals = [${buildVector3Array(attributes.normal, count)}] (\n            interpolation = \"vertex\"\n        )\n        point3f[] points = [${buildVector3Array(attributes.position, count)}]\n        float2[] primvars:st = [${buildVector2Array(attributes.uv, count)}] (\n            interpolation = \"vertex\"\n        )\n        uniform token subdivisionScheme = \"none\"\n    }\n`;\n}\n\nfunction buildMeshVertexCount(geometry) {\n  const count = geometry.index !== null ? geometry.index.array.length : geometry.attributes.position.count;\n  return Array(count / 3).fill(3).join(', ');\n}\n\nfunction buildMeshVertexIndices(geometry) {\n  if (geometry.index !== null) {\n    return geometry.index.array.join(', ');\n  }\n\n  const array = [];\n  const length = geometry.attributes.position.count;\n\n  for (let i = 0; i < length; i++) {\n    array.push(i);\n  }\n\n  return array.join(', ');\n}\n\nfunction buildVector3Array(attribute, count) {\n  if (attribute === undefined) {\n    console.warn('USDZExporter: Normals missing.');\n    return Array(count).fill('(0, 0, 0)').join(', ');\n  }\n\n  const array = [];\n  const data = attribute.array;\n\n  for (let i = 0; i < data.length; i += 3) {\n    array.push(`(${data[i + 0].toPrecision(PRECISION)}, ${data[i + 1].toPrecision(PRECISION)}, ${data[i + 2].toPrecision(PRECISION)})`);\n  }\n\n  return array.join(', ');\n}\n\nfunction buildVector2Array(attribute, count) {\n  if (attribute === undefined) {\n    console.warn('USDZExporter: UVs missing.');\n    return Array(count).fill('(0, 0)').join(', ');\n  }\n\n  const array = [];\n  const data = attribute.array;\n\n  for (let i = 0; i < data.length; i += 2) {\n    array.push(`(${data[i + 0].toPrecision(PRECISION)}, ${1 - data[i + 1].toPrecision(PRECISION)})`);\n  }\n\n  return array.join(', ');\n} // Materials\n\n\nfunction buildMaterials(materials) {\n  const array = [];\n\n  for (let uuid in materials) {\n    const material = materials[uuid];\n    array.push(buildMaterial(material));\n  }\n\n  return `def \"Materials\"\n{\n${array.join('')}\n}\n\n`;\n}\n\nfunction buildMaterial(material) {\n  // https://graphics.pixar.com/usd/docs/UsdPreviewSurface-Proposal.html\n  const pad = '            ';\n  const parameters = [];\n\n  if (material.map !== null) {\n    parameters.push(`${pad}color3f inputs:diffuseColor.connect = </Textures/Texture_${material.map.id}.outputs:rgb>`);\n  } else {\n    parameters.push(`${pad}color3f inputs:diffuseColor = ${buildColor(material.color)}`);\n  }\n\n  if (material.emissiveMap !== null) {\n    parameters.push(`${pad}color3f inputs:emissiveColor.connect = </Textures/Texture_${material.emissiveMap.id}.outputs:rgb>`);\n  } else if (material.emissive.getHex() > 0) {\n    parameters.push(`${pad}color3f inputs:emissiveColor = ${buildColor(material.emissive)}`);\n  }\n\n  if (material.normalMap !== null) {\n    parameters.push(`${pad}normal3f inputs:normal.connect = </Textures/Texture_${material.normalMap.id}.outputs:rgb>`);\n  }\n\n  if (material.aoMap !== null) {\n    parameters.push(`${pad}float inputs:occlusion.connect = </Textures/Texture_${material.aoMap.id}.outputs:r>`);\n  }\n\n  if (material.roughnessMap !== null) {\n    parameters.push(`${pad}float inputs:roughness.connect = </Textures/Texture_${material.roughnessMap.id}.outputs:g>`);\n  } else {\n    parameters.push(`${pad}float inputs:roughness = ${material.roughness}`);\n  }\n\n  if (material.metalnessMap !== null) {\n    parameters.push(`${pad}float inputs:metallic.connect = </Textures/Texture_${material.metalnessMap.id}.outputs:b>`);\n  } else {\n    parameters.push(`${pad}float inputs:metallic = ${material.metalness}`);\n  }\n\n  return `\n    def Material \"Material_${material.id}\"\n    {\n        token outputs:surface.connect = </Materials/Material_${material.id}/PreviewSurface.outputs:surface>\n\n        def Shader \"PreviewSurface\"\n        {\n            uniform token info:id = \"UsdPreviewSurface\"\n${parameters.join('\\n')}\n            int inputs:useSpecularWorkflow = 0\n            token outputs:surface\n        }\n    }\n`;\n}\n\nfunction buildTextures(textures) {\n  const array = [];\n\n  for (let uuid in textures) {\n    const texture = textures[uuid];\n    array.push(buildTexture(texture));\n  }\n\n  return `def \"Textures\"\n{\n${array.join('')}\n}\n\n`;\n}\n\nfunction buildTexture(texture) {\n  return `\n    def Shader \"Texture_${texture.id}\"\n    {\n        uniform token info:id = \"UsdUVTexture\"\n        asset inputs:file = @textures/Texture_${texture.id}.jpg@\n        token inputs:wrapS = \"repeat\"\n        token inputs:wrapT = \"repeat\"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n    }\n`;\n}\n\nfunction buildColor(color) {\n  return `(${color.r}, ${color.g}, ${color.b})`;\n}\n\nexport { USDZExporter };\n"]},"metadata":{},"sourceType":"module"}