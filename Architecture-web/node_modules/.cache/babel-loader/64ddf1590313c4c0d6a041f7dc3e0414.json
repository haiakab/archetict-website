{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/haiakablan/Documents/\\u05DC\\u05D5\\u05D8\\u05D5\\u05E1/\\u05E7\\u05D5\\u05E8\\u05E1/Architecture-web/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport { BufferAttribute, BufferGeometry, Vector3 } from \"../../../build/three.module.js\";\nimport { BufferGeometryUtils } from \"../utils/BufferGeometryUtils.js\";\n\nvar EdgeSplitModifier = function EdgeSplitModifier() {\n  var A = new Vector3();\n  var B = new Vector3();\n  var C = new Vector3();\n  var positions, normals;\n  var indexes;\n  var pointToIndexMap, splitIndexes;\n\n  function computeNormals() {\n    normals = new Float32Array(indexes.length * 3);\n\n    for (var i = 0; i < indexes.length; i += 3) {\n      var index = indexes[i];\n      A.set(positions[3 * index], positions[3 * index + 1], positions[3 * index + 2]);\n      index = indexes[i + 1];\n      B.set(positions[3 * index], positions[3 * index + 1], positions[3 * index + 2]);\n      index = indexes[i + 2];\n      C.set(positions[3 * index], positions[3 * index + 1], positions[3 * index + 2]);\n      C.sub(B);\n      A.sub(B);\n      var normal = C.cross(A).normalize();\n\n      for (var j = 0; j < 3; j++) {\n        normals[3 * (i + j)] = normal.x;\n        normals[3 * (i + j) + 1] = normal.y;\n        normals[3 * (i + j) + 2] = normal.z;\n      }\n    }\n  }\n\n  function mapPositionsToIndexes() {\n    pointToIndexMap = Array(positions.length / 3);\n\n    for (var i = 0; i < indexes.length; i++) {\n      var index = indexes[i];\n\n      if (pointToIndexMap[index] == null) {\n        pointToIndexMap[index] = [];\n      }\n\n      pointToIndexMap[index].push(i);\n    }\n  }\n\n  function edgeSplitToGroups(indexes, cutOff, firstIndex) {\n    A.set(normals[3 * firstIndex], normals[3 * firstIndex + 1], normals[3 * firstIndex + 2]).normalize();\n    var result = {\n      splitGroup: [],\n      currentGroup: [firstIndex]\n    };\n\n    var _iterator = _createForOfIteratorHelper(indexes),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var j = _step.value;\n\n        if (j !== firstIndex) {\n          B.set(normals[3 * j], normals[3 * j + 1], normals[3 * j + 2]).normalize();\n\n          if (B.dot(A) < cutOff) {\n            result.splitGroup.push(j);\n          } else {\n            result.currentGroup.push(j);\n          }\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return result;\n  }\n\n  function edgeSplit(indexes, cutOff) {\n    var original = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    if (indexes.length === 0) return;\n    var groupResults = [];\n\n    var _iterator2 = _createForOfIteratorHelper(indexes),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var index = _step2.value;\n        groupResults.push(edgeSplitToGroups(indexes, cutOff, index));\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    var result = groupResults[0];\n\n    for (var _i = 0, _groupResults = groupResults; _i < _groupResults.length; _i++) {\n      var groupResult = _groupResults[_i];\n\n      if (groupResult.currentGroup.length > result.currentGroup.length) {\n        result = groupResult;\n      }\n    }\n\n    if (original != null) {\n      splitIndexes.push({\n        original: original,\n        indexes: result.currentGroup\n      });\n    }\n\n    if (result.splitGroup.length) {\n      edgeSplit(result.splitGroup, cutOff, original || result.currentGroup[0]);\n    }\n  }\n\n  this.modify = function (geometry, cutOffAngle) {\n    if (!geometry.isBufferGeometry) {\n      geometry = new BufferGeometry().fromGeometry(geometry);\n    }\n\n    if (geometry.index == null) {\n      if (BufferGeometryUtils === undefined) {\n        throw 'THREE.EdgeSplitModifier relies on BufferGeometryUtils';\n      }\n\n      geometry = BufferGeometryUtils.mergeVertices(geometry);\n    }\n\n    indexes = geometry.index.array;\n    positions = geometry.getAttribute(\"position\").array;\n    computeNormals();\n    mapPositionsToIndexes();\n    splitIndexes = [];\n\n    var _iterator3 = _createForOfIteratorHelper(pointToIndexMap),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var vertexIndexes = _step3.value;\n        edgeSplit(vertexIndexes, Math.cos(cutOffAngle) - 0.001);\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    var newPositions = new Float32Array(positions.length + 3 * splitIndexes.length);\n    newPositions.set(positions);\n    var offset = positions.length;\n    var newIndexes = new Uint32Array(indexes.length);\n    newIndexes.set(indexes);\n\n    for (var i = 0; i < splitIndexes.length; i++) {\n      var split = splitIndexes[i];\n      var index = indexes[split.original];\n      newPositions[offset + 3 * i] = positions[3 * index];\n      newPositions[offset + 3 * i + 1] = positions[3 * index + 1];\n      newPositions[offset + 3 * i + 2] = positions[3 * index + 2];\n\n      var _iterator4 = _createForOfIteratorHelper(split.indexes),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var j = _step4.value;\n          newIndexes[j] = offset / 3 + i;\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n\n    geometry = new BufferGeometry();\n    geometry.setAttribute('position', new BufferAttribute(newPositions, 3, true));\n    geometry.setIndex(new BufferAttribute(newIndexes, 1));\n    return geometry;\n  };\n};\n\nexport { EdgeSplitModifier };","map":{"version":3,"sources":["/Users/haiakablan/Documents/לוטוס/קורס/Architecture-web/node_modules/three/examples/jsm/modifiers/EdgeSplitModifier.js"],"names":["BufferAttribute","BufferGeometry","Vector3","BufferGeometryUtils","EdgeSplitModifier","A","B","C","positions","normals","indexes","pointToIndexMap","splitIndexes","computeNormals","Float32Array","length","i","index","set","sub","normal","cross","normalize","j","x","y","z","mapPositionsToIndexes","Array","push","edgeSplitToGroups","cutOff","firstIndex","result","splitGroup","currentGroup","dot","edgeSplit","original","groupResults","groupResult","modify","geometry","cutOffAngle","isBufferGeometry","fromGeometry","undefined","mergeVertices","array","getAttribute","vertexIndexes","Math","cos","newPositions","offset","newIndexes","Uint32Array","split","setAttribute","setIndex"],"mappings":";AAAA,SACCA,eADD,EAECC,cAFD,EAGCC,OAHD,QAIO,gCAJP;AAKA,SAASC,mBAAT,QAAoC,iCAApC;;AAGA,IAAIC,iBAAiB,GAAG,SAApBA,iBAAoB,GAAY;AAEnC,MAAIC,CAAC,GAAG,IAAIH,OAAJ,EAAR;AACA,MAAII,CAAC,GAAG,IAAIJ,OAAJ,EAAR;AACA,MAAIK,CAAC,GAAG,IAAIL,OAAJ,EAAR;AAEA,MAAIM,SAAJ,EAAeC,OAAf;AACA,MAAIC,OAAJ;AACA,MAAIC,eAAJ,EAAqBC,YAArB;;AAGA,WAASC,cAAT,GAA0B;AAEzBJ,IAAAA,OAAO,GAAG,IAAIK,YAAJ,CAAkBJ,OAAO,CAACK,MAAR,GAAiB,CAAnC,CAAV;;AAEA,SAAM,IAAIC,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGN,OAAO,CAACK,MAA7B,EAAqCC,CAAC,IAAI,CAA1C,EAA8C;AAE7C,UAAIC,KAAK,GAAGP,OAAO,CAAEM,CAAF,CAAnB;AAEAX,MAAAA,CAAC,CAACa,GAAF,CACCV,SAAS,CAAE,IAAIS,KAAN,CADV,EAECT,SAAS,CAAE,IAAIS,KAAJ,GAAY,CAAd,CAFV,EAGCT,SAAS,CAAE,IAAIS,KAAJ,GAAY,CAAd,CAHV;AAKAA,MAAAA,KAAK,GAAGP,OAAO,CAAEM,CAAC,GAAG,CAAN,CAAf;AACAV,MAAAA,CAAC,CAACY,GAAF,CACCV,SAAS,CAAE,IAAIS,KAAN,CADV,EAECT,SAAS,CAAE,IAAIS,KAAJ,GAAY,CAAd,CAFV,EAGCT,SAAS,CAAE,IAAIS,KAAJ,GAAY,CAAd,CAHV;AAKAA,MAAAA,KAAK,GAAGP,OAAO,CAAEM,CAAC,GAAG,CAAN,CAAf;AACAT,MAAAA,CAAC,CAACW,GAAF,CACCV,SAAS,CAAE,IAAIS,KAAN,CADV,EAECT,SAAS,CAAE,IAAIS,KAAJ,GAAY,CAAd,CAFV,EAGCT,SAAS,CAAE,IAAIS,KAAJ,GAAY,CAAd,CAHV;AAKAV,MAAAA,CAAC,CAACY,GAAF,CAAOb,CAAP;AACAD,MAAAA,CAAC,CAACc,GAAF,CAAOb,CAAP;AAEA,UAAIc,MAAM,GAAGb,CAAC,CAACc,KAAF,CAAShB,CAAT,EAAaiB,SAAb,EAAb;;AAEA,WAAM,IAAIC,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAG,CAArB,EAAwBA,CAAC,EAAzB,EAA+B;AAE9Bd,QAAAA,OAAO,CAAE,KAAMO,CAAC,GAAGO,CAAV,CAAF,CAAP,GAA2BH,MAAM,CAACI,CAAlC;AACAf,QAAAA,OAAO,CAAE,KAAMO,CAAC,GAAGO,CAAV,IAAgB,CAAlB,CAAP,GAA+BH,MAAM,CAACK,CAAtC;AACAhB,QAAAA,OAAO,CAAE,KAAMO,CAAC,GAAGO,CAAV,IAAgB,CAAlB,CAAP,GAA+BH,MAAM,CAACM,CAAtC;AAEA;AAED;AAED;;AAGD,WAASC,qBAAT,GAAiC;AAEhChB,IAAAA,eAAe,GAAGiB,KAAK,CAAEpB,SAAS,CAACO,MAAV,GAAmB,CAArB,CAAvB;;AAEA,SAAM,IAAIC,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGN,OAAO,CAACK,MAA7B,EAAqCC,CAAC,EAAtC,EAA4C;AAE3C,UAAIC,KAAK,GAAGP,OAAO,CAAEM,CAAF,CAAnB;;AAEA,UAAKL,eAAe,CAAEM,KAAF,CAAf,IAA4B,IAAjC,EAAwC;AAEvCN,QAAAA,eAAe,CAAEM,KAAF,CAAf,GAA2B,EAA3B;AAEA;;AAEDN,MAAAA,eAAe,CAAEM,KAAF,CAAf,CAAyBY,IAAzB,CAA+Bb,CAA/B;AAEA;AAED;;AAGD,WAASc,iBAAT,CAA4BpB,OAA5B,EAAqCqB,MAArC,EAA6CC,UAA7C,EAA0D;AAEzD3B,IAAAA,CAAC,CAACa,GAAF,CAAOT,OAAO,CAAE,IAAIuB,UAAN,CAAd,EAAkCvB,OAAO,CAAE,IAAIuB,UAAJ,GAAiB,CAAnB,CAAzC,EAAiEvB,OAAO,CAAE,IAAIuB,UAAJ,GAAiB,CAAnB,CAAxE,EAAiGV,SAAjG;AAEA,QAAIW,MAAM,GAAG;AACZC,MAAAA,UAAU,EAAE,EADA;AAEZC,MAAAA,YAAY,EAAE,CAAEH,UAAF;AAFF,KAAb;;AAJyD,+CAS1CtB,OAT0C;AAAA;;AAAA;AASzD,0DAAyB;AAAA,YAAfa,CAAe;;AAExB,YAAKA,CAAC,KAAKS,UAAX,EAAwB;AAEvB1B,UAAAA,CAAC,CAACY,GAAF,CAAOT,OAAO,CAAE,IAAIc,CAAN,CAAd,EAAyBd,OAAO,CAAE,IAAIc,CAAJ,GAAQ,CAAV,CAAhC,EAA+Cd,OAAO,CAAE,IAAIc,CAAJ,GAAQ,CAAV,CAAtD,EAAsED,SAAtE;;AAEA,cAAKhB,CAAC,CAAC8B,GAAF,CAAO/B,CAAP,IAAa0B,MAAlB,EAA2B;AAE1BE,YAAAA,MAAM,CAACC,UAAP,CAAkBL,IAAlB,CAAwBN,CAAxB;AAEA,WAJD,MAIO;AAENU,YAAAA,MAAM,CAACE,YAAP,CAAoBN,IAApB,CAA0BN,CAA1B;AAEA;AAED;AAED;AA3BwD;AAAA;AAAA;AAAA;AAAA;;AA6BzD,WAAOU,MAAP;AAEA;;AAGD,WAASI,SAAT,CAAoB3B,OAApB,EAA6BqB,MAA7B,EAAuD;AAAA,QAAlBO,QAAkB,uEAAP,IAAO;AAEtD,QAAK5B,OAAO,CAACK,MAAR,KAAmB,CAAxB,EAA4B;AAE5B,QAAIwB,YAAY,GAAG,EAAnB;;AAJsD,gDAMnC7B,OANmC;AAAA;;AAAA;AAMtD,6DAA6B;AAAA,YAAnBO,KAAmB;AAE5BsB,QAAAA,YAAY,CAACV,IAAb,CAAmBC,iBAAiB,CAAEpB,OAAF,EAAWqB,MAAX,EAAmBd,KAAnB,CAApC;AAEA;AAVqD;AAAA;AAAA;AAAA;AAAA;;AAYtD,QAAIgB,MAAM,GAAGM,YAAY,CAAE,CAAF,CAAzB;;AAEA,qCAAyBA,YAAzB,mCAAwC;AAAlC,UAAIC,WAAW,oBAAf;;AAEL,UAAKA,WAAW,CAACL,YAAZ,CAAyBpB,MAAzB,GAAkCkB,MAAM,CAACE,YAAP,CAAoBpB,MAA3D,EAAoE;AAEnEkB,QAAAA,MAAM,GAAGO,WAAT;AAEA;AAED;;AAGD,QAAKF,QAAQ,IAAI,IAAjB,EAAwB;AAEvB1B,MAAAA,YAAY,CAACiB,IAAb,CAAmB;AAClBS,QAAAA,QAAQ,EAAEA,QADQ;AAElB5B,QAAAA,OAAO,EAAEuB,MAAM,CAACE;AAFE,OAAnB;AAKA;;AAED,QAAKF,MAAM,CAACC,UAAP,CAAkBnB,MAAvB,EAAgC;AAE/BsB,MAAAA,SAAS,CAAEJ,MAAM,CAACC,UAAT,EAAqBH,MAArB,EAA6BO,QAAQ,IAAIL,MAAM,CAACE,YAAP,CAAqB,CAArB,CAAzC,CAAT;AAEA;AAED;;AAGD,OAAKM,MAAL,GAAc,UAAWC,QAAX,EAAqBC,WAArB,EAAmC;AAEhD,QAAK,CAAED,QAAQ,CAACE,gBAAhB,EAAmC;AAElCF,MAAAA,QAAQ,GAAG,IAAIzC,cAAJ,GAAqB4C,YAArB,CAAmCH,QAAnC,CAAX;AAEA;;AAGD,QAAKA,QAAQ,CAACzB,KAAT,IAAkB,IAAvB,EAA8B;AAE7B,UAAKd,mBAAmB,KAAK2C,SAA7B,EAAyC;AAEvC,cAAM,uDAAN;AAED;;AAEDJ,MAAAA,QAAQ,GAAGvC,mBAAmB,CAAC4C,aAApB,CAAmCL,QAAnC,CAAX;AAEA;;AAEDhC,IAAAA,OAAO,GAAGgC,QAAQ,CAACzB,KAAT,CAAe+B,KAAzB;AACAxC,IAAAA,SAAS,GAAGkC,QAAQ,CAACO,YAAT,CAAuB,UAAvB,EAAoCD,KAAhD;AAEAnC,IAAAA,cAAc;AACdc,IAAAA,qBAAqB;AAGrBf,IAAAA,YAAY,GAAG,EAAf;;AA5BgD,gDA8BrBD,eA9BqB;AAAA;;AAAA;AA8BhD,6DAA6C;AAAA,YAAnCuC,aAAmC;AAE5Cb,QAAAA,SAAS,CAAEa,aAAF,EAAiBC,IAAI,CAACC,GAAL,CAAUT,WAAV,IAA0B,KAA3C,CAAT;AAEA;AAlC+C;AAAA;AAAA;AAAA;AAAA;;AAoChD,QAAIU,YAAY,GAAG,IAAIvC,YAAJ,CAAkBN,SAAS,CAACO,MAAV,GAAmB,IAAIH,YAAY,CAACG,MAAtD,CAAnB;AACAsC,IAAAA,YAAY,CAACnC,GAAb,CAAkBV,SAAlB;AACA,QAAI8C,MAAM,GAAG9C,SAAS,CAACO,MAAvB;AAEA,QAAIwC,UAAU,GAAG,IAAIC,WAAJ,CAAiB9C,OAAO,CAACK,MAAzB,CAAjB;AACAwC,IAAAA,UAAU,CAACrC,GAAX,CAAgBR,OAAhB;;AAEA,SAAM,IAAIM,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGJ,YAAY,CAACG,MAAlC,EAA0CC,CAAC,EAA3C,EAAiD;AAEhD,UAAIyC,KAAK,GAAG7C,YAAY,CAAEI,CAAF,CAAxB;AACA,UAAIC,KAAK,GAAGP,OAAO,CAAE+C,KAAK,CAACnB,QAAR,CAAnB;AAEAe,MAAAA,YAAY,CAAEC,MAAM,GAAG,IAAItC,CAAf,CAAZ,GAAiCR,SAAS,CAAE,IAAIS,KAAN,CAA1C;AACAoC,MAAAA,YAAY,CAAEC,MAAM,GAAG,IAAItC,CAAb,GAAiB,CAAnB,CAAZ,GAAqCR,SAAS,CAAE,IAAIS,KAAJ,GAAY,CAAd,CAA9C;AACAoC,MAAAA,YAAY,CAAEC,MAAM,GAAG,IAAItC,CAAb,GAAiB,CAAnB,CAAZ,GAAqCR,SAAS,CAAE,IAAIS,KAAJ,GAAY,CAAd,CAA9C;;AAPgD,kDASjCwC,KAAK,CAAC/C,OAT2B;AAAA;;AAAA;AAShD,+DAA+B;AAAA,cAArBa,CAAqB;AAE9BgC,UAAAA,UAAU,CAAEhC,CAAF,CAAV,GAAkB+B,MAAM,GAAG,CAAT,GAAatC,CAA/B;AAEA;AAb+C;AAAA;AAAA;AAAA;AAAA;AAehD;;AAED0B,IAAAA,QAAQ,GAAG,IAAIzC,cAAJ,EAAX;AACAyC,IAAAA,QAAQ,CAACgB,YAAT,CAAuB,UAAvB,EAAmC,IAAI1D,eAAJ,CAAqBqD,YAArB,EAAmC,CAAnC,EAAsC,IAAtC,CAAnC;AACAX,IAAAA,QAAQ,CAACiB,QAAT,CAAmB,IAAI3D,eAAJ,CAAqBuD,UAArB,EAAiC,CAAjC,CAAnB;AAEA,WAAOb,QAAP;AAEA,GAlED;AAoEA,CA5ND;;AA8NA,SAAStC,iBAAT","sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tVector3\n} from \"../../../build/three.module.js\";\nimport { BufferGeometryUtils } from \"../utils/BufferGeometryUtils.js\";\n\n\nvar EdgeSplitModifier = function () {\n\n\tvar A = new Vector3();\n\tvar B = new Vector3();\n\tvar C = new Vector3();\n\n\tvar positions, normals;\n\tvar indexes;\n\tvar pointToIndexMap, splitIndexes;\n\n\n\tfunction computeNormals() {\n\n\t\tnormals = new Float32Array( indexes.length * 3 );\n\n\t\tfor ( var i = 0; i < indexes.length; i += 3 ) {\n\n\t\t\tvar index = indexes[ i ];\n\n\t\t\tA.set(\n\t\t\t\tpositions[ 3 * index ],\n\t\t\t\tpositions[ 3 * index + 1 ],\n\t\t\t\tpositions[ 3 * index + 2 ] );\n\n\t\t\tindex = indexes[ i + 1 ];\n\t\t\tB.set(\n\t\t\t\tpositions[ 3 * index ],\n\t\t\t\tpositions[ 3 * index + 1 ],\n\t\t\t\tpositions[ 3 * index + 2 ] );\n\n\t\t\tindex = indexes[ i + 2 ];\n\t\t\tC.set(\n\t\t\t\tpositions[ 3 * index ],\n\t\t\t\tpositions[ 3 * index + 1 ],\n\t\t\t\tpositions[ 3 * index + 2 ] );\n\n\t\t\tC.sub( B );\n\t\t\tA.sub( B );\n\n\t\t\tvar normal = C.cross( A ).normalize();\n\n\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\tnormals[ 3 * ( i + j ) ] = normal.x;\n\t\t\t\tnormals[ 3 * ( i + j ) + 1 ] = normal.y;\n\t\t\t\tnormals[ 3 * ( i + j ) + 2 ] = normal.z;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\tfunction mapPositionsToIndexes() {\n\n\t\tpointToIndexMap = Array( positions.length / 3 );\n\n\t\tfor ( var i = 0; i < indexes.length; i ++ ) {\n\n\t\t\tvar index = indexes[ i ];\n\n\t\t\tif ( pointToIndexMap[ index ] == null ) {\n\n\t\t\t\tpointToIndexMap[ index ] = [];\n\n\t\t\t}\n\n\t\t\tpointToIndexMap[ index ].push( i );\n\n\t\t}\n\n\t}\n\n\n\tfunction edgeSplitToGroups( indexes, cutOff, firstIndex ) {\n\n\t\tA.set( normals[ 3 * firstIndex ], normals[ 3 * firstIndex + 1 ], normals[ 3 * firstIndex + 2 ] ).normalize();\n\n\t\tvar result = {\n\t\t\tsplitGroup: [],\n\t\t\tcurrentGroup: [ firstIndex ]\n\t\t};\n\n\t\tfor ( var j of indexes ) {\n\n\t\t\tif ( j !== firstIndex ) {\n\n\t\t\t\tB.set( normals[ 3 * j ], normals[ 3 * j + 1 ], normals[ 3 * j + 2 ] ).normalize();\n\n\t\t\t\tif ( B.dot( A ) < cutOff ) {\n\n\t\t\t\t\tresult.splitGroup.push( j );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tresult.currentGroup.push( j );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\n\tfunction edgeSplit( indexes, cutOff, original = null ) {\n\n\t\tif ( indexes.length === 0 ) return;\n\n\t\tvar groupResults = [];\n\n\t\tfor ( var index of indexes ) {\n\n\t\t\tgroupResults.push( edgeSplitToGroups( indexes, cutOff, index ) );\n\n\t\t}\n\n\t\tvar result = groupResults[ 0 ];\n\n\t\tfor ( var groupResult of groupResults ) {\n\n\t\t\tif ( groupResult.currentGroup.length > result.currentGroup.length ) {\n\n\t\t\t\tresult = groupResult;\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tif ( original != null ) {\n\n\t\t\tsplitIndexes.push( {\n\t\t\t\toriginal: original,\n\t\t\t\tindexes: result.currentGroup\n\t\t\t} );\n\n\t\t}\n\n\t\tif ( result.splitGroup.length ) {\n\n\t\t\tedgeSplit( result.splitGroup, cutOff, original || result.currentGroup[ 0 ] );\n\n\t\t}\n\n\t}\n\n\n\tthis.modify = function ( geometry, cutOffAngle ) {\n\n\t\tif ( ! geometry.isBufferGeometry ) {\n\n\t\t\tgeometry = new BufferGeometry().fromGeometry( geometry );\n\n\t\t}\n\n\n\t\tif ( geometry.index == null ) {\n\n\t\t\tif ( BufferGeometryUtils === undefined ) {\n\n\t\t\t \tthrow 'THREE.EdgeSplitModifier relies on BufferGeometryUtils';\n\n\t\t\t}\n\n\t\t\tgeometry = BufferGeometryUtils.mergeVertices( geometry );\n\n\t\t}\n\n\t\tindexes = geometry.index.array;\n\t\tpositions = geometry.getAttribute( \"position\" ).array;\n\n\t\tcomputeNormals();\n\t\tmapPositionsToIndexes();\n\n\n\t\tsplitIndexes = [];\n\n\t\tfor ( var vertexIndexes of pointToIndexMap ) {\n\n\t\t\tedgeSplit( vertexIndexes, Math.cos( cutOffAngle ) - 0.001 );\n\n\t\t}\n\n\t\tvar newPositions = new Float32Array( positions.length + 3 * splitIndexes.length );\n\t\tnewPositions.set( positions );\n\t\tvar offset = positions.length;\n\n\t\tvar newIndexes = new Uint32Array( indexes.length );\n\t\tnewIndexes.set( indexes );\n\n\t\tfor ( var i = 0; i < splitIndexes.length; i ++ ) {\n\n\t\t\tvar split = splitIndexes[ i ];\n\t\t\tvar index = indexes[ split.original ];\n\n\t\t\tnewPositions[ offset + 3 * i ] = positions[ 3 * index ];\n\t\t\tnewPositions[ offset + 3 * i + 1 ] = positions[ 3 * index + 1 ];\n\t\t\tnewPositions[ offset + 3 * i + 2 ] = positions[ 3 * index + 2 ];\n\n\t\t\tfor ( var j of split.indexes ) {\n\n\t\t\t\tnewIndexes[ j ] = offset / 3 + i;\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new BufferAttribute( newPositions, 3, true ) );\n\t\tgeometry.setIndex( new BufferAttribute( newIndexes, 1 ) );\n\n\t\treturn geometry;\n\n\t};\n\n};\n\nexport { EdgeSplitModifier };\n"]},"metadata":{},"sourceType":"module"}