{"ast":null,"code":"import { DataTextureLoader, LinearMipmapLinearFilter } from '../../../build/three.module.js';\n\nvar TGALoader = function (manager) {\n  DataTextureLoader.call(this, manager);\n};\n\nTGALoader.prototype = Object.assign(Object.create(DataTextureLoader.prototype), {\n  constructor: TGALoader,\n  parse: function (buffer) {\n    // reference from vthibault, https://github.com/vthibault/roBrowser/blob/master/src/Loaders/Targa.js\n    function tgaCheckHeader(header) {\n      switch (header.image_type) {\n        // check indexed type\n        case TGA_TYPE_INDEXED:\n        case TGA_TYPE_RLE_INDEXED:\n          if (header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1) {\n            console.error('THREE.TGALoader: Invalid type colormap data for indexed type.');\n          }\n\n          break;\n        // check colormap type\n\n        case TGA_TYPE_RGB:\n        case TGA_TYPE_GREY:\n        case TGA_TYPE_RLE_RGB:\n        case TGA_TYPE_RLE_GREY:\n          if (header.colormap_type) {\n            console.error('THREE.TGALoader: Invalid type colormap data for colormap type.');\n          }\n\n          break;\n        // What the need of a file without data ?\n\n        case TGA_TYPE_NO_DATA:\n          console.error('THREE.TGALoader: No data.');\n        // Invalid type ?\n\n        default:\n          console.error('THREE.TGALoader: Invalid type \"%s\".', header.image_type);\n      } // check image width and height\n\n\n      if (header.width <= 0 || header.height <= 0) {\n        console.error('THREE.TGALoader: Invalid image size.');\n      } // check image pixel size\n\n\n      if (header.pixel_size !== 8 && header.pixel_size !== 16 && header.pixel_size !== 24 && header.pixel_size !== 32) {\n        console.error('THREE.TGALoader: Invalid pixel size \"%s\".', header.pixel_size);\n      }\n    } // parse tga image buffer\n\n\n    function tgaParse(use_rle, use_pal, header, offset, data) {\n      var pixel_data, pixel_size, pixel_total, palettes;\n      pixel_size = header.pixel_size >> 3;\n      pixel_total = header.width * header.height * pixel_size; // read palettes\n\n      if (use_pal) {\n        palettes = data.subarray(offset, offset += header.colormap_length * (header.colormap_size >> 3));\n      } // read RLE\n\n\n      if (use_rle) {\n        pixel_data = new Uint8Array(pixel_total);\n        var c, count, i;\n        var shift = 0;\n        var pixels = new Uint8Array(pixel_size);\n\n        while (shift < pixel_total) {\n          c = data[offset++];\n          count = (c & 0x7f) + 1; // RLE pixels\n\n          if (c & 0x80) {\n            // bind pixel tmp array\n            for (i = 0; i < pixel_size; ++i) {\n              pixels[i] = data[offset++];\n            } // copy pixel array\n\n\n            for (i = 0; i < count; ++i) {\n              pixel_data.set(pixels, shift + i * pixel_size);\n            }\n\n            shift += pixel_size * count;\n          } else {\n            // raw pixels\n            count *= pixel_size;\n\n            for (i = 0; i < count; ++i) {\n              pixel_data[shift + i] = data[offset++];\n            }\n\n            shift += count;\n          }\n        }\n      } else {\n        // raw pixels\n        pixel_data = data.subarray(offset, offset += use_pal ? header.width * header.height : pixel_total);\n      }\n\n      return {\n        pixel_data: pixel_data,\n        palettes: palettes\n      };\n    }\n\n    function tgaGetImageData8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes) {\n      var colormap = palettes;\n      var color,\n          i = 0,\n          x,\n          y;\n      var width = header.width;\n\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i++) {\n          color = image[i];\n          imageData[(x + width * y) * 4 + 3] = 255;\n          imageData[(x + width * y) * 4 + 2] = colormap[color * 3 + 0];\n          imageData[(x + width * y) * 4 + 1] = colormap[color * 3 + 1];\n          imageData[(x + width * y) * 4 + 0] = colormap[color * 3 + 2];\n        }\n      }\n\n      return imageData;\n    }\n\n    function tgaGetImageData16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      var color,\n          i = 0,\n          x,\n          y;\n      var width = header.width;\n\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 2) {\n          color = image[i + 0] + (image[i + 1] << 8); // Inversed ?\n\n          imageData[(x + width * y) * 4 + 0] = (color & 0x7C00) >> 7;\n          imageData[(x + width * y) * 4 + 1] = (color & 0x03E0) >> 2;\n          imageData[(x + width * y) * 4 + 2] = (color & 0x001F) >> 3;\n          imageData[(x + width * y) * 4 + 3] = color & 0x8000 ? 0 : 255;\n        }\n      }\n\n      return imageData;\n    }\n\n    function tgaGetImageData24bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      var i = 0,\n          x,\n          y;\n      var width = header.width;\n\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 3) {\n          imageData[(x + width * y) * 4 + 3] = 255;\n          imageData[(x + width * y) * 4 + 2] = image[i + 0];\n          imageData[(x + width * y) * 4 + 1] = image[i + 1];\n          imageData[(x + width * y) * 4 + 0] = image[i + 2];\n        }\n      }\n\n      return imageData;\n    }\n\n    function tgaGetImageData32bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      var i = 0,\n          x,\n          y;\n      var width = header.width;\n\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 4) {\n          imageData[(x + width * y) * 4 + 2] = image[i + 0];\n          imageData[(x + width * y) * 4 + 1] = image[i + 1];\n          imageData[(x + width * y) * 4 + 0] = image[i + 2];\n          imageData[(x + width * y) * 4 + 3] = image[i + 3];\n        }\n      }\n\n      return imageData;\n    }\n\n    function tgaGetImageDataGrey8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      var color,\n          i = 0,\n          x,\n          y;\n      var width = header.width;\n\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i++) {\n          color = image[i];\n          imageData[(x + width * y) * 4 + 0] = color;\n          imageData[(x + width * y) * 4 + 1] = color;\n          imageData[(x + width * y) * 4 + 2] = color;\n          imageData[(x + width * y) * 4 + 3] = 255;\n        }\n      }\n\n      return imageData;\n    }\n\n    function tgaGetImageDataGrey16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      var i = 0,\n          x,\n          y;\n      var width = header.width;\n\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 2) {\n          imageData[(x + width * y) * 4 + 0] = image[i + 0];\n          imageData[(x + width * y) * 4 + 1] = image[i + 0];\n          imageData[(x + width * y) * 4 + 2] = image[i + 0];\n          imageData[(x + width * y) * 4 + 3] = image[i + 1];\n        }\n      }\n\n      return imageData;\n    }\n\n    function getTgaRGBA(data, width, height, image, palette) {\n      var x_start, y_start, x_step, y_step, x_end, y_end;\n\n      switch ((header.flags & TGA_ORIGIN_MASK) >> TGA_ORIGIN_SHIFT) {\n        default:\n        case TGA_ORIGIN_UL:\n          x_start = 0;\n          x_step = 1;\n          x_end = width;\n          y_start = 0;\n          y_step = 1;\n          y_end = height;\n          break;\n\n        case TGA_ORIGIN_BL:\n          x_start = 0;\n          x_step = 1;\n          x_end = width;\n          y_start = height - 1;\n          y_step = -1;\n          y_end = -1;\n          break;\n\n        case TGA_ORIGIN_UR:\n          x_start = width - 1;\n          x_step = -1;\n          x_end = -1;\n          y_start = 0;\n          y_step = 1;\n          y_end = height;\n          break;\n\n        case TGA_ORIGIN_BR:\n          x_start = width - 1;\n          x_step = -1;\n          x_end = -1;\n          y_start = height - 1;\n          y_step = -1;\n          y_end = -1;\n          break;\n      }\n\n      if (use_grey) {\n        switch (header.pixel_size) {\n          case 8:\n            tgaGetImageDataGrey8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n\n          case 16:\n            tgaGetImageDataGrey16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n\n          default:\n            console.error('THREE.TGALoader: Format not supported.');\n            break;\n        }\n      } else {\n        switch (header.pixel_size) {\n          case 8:\n            tgaGetImageData8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette);\n            break;\n\n          case 16:\n            tgaGetImageData16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n\n          case 24:\n            tgaGetImageData24bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n\n          case 32:\n            tgaGetImageData32bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n\n          default:\n            console.error('THREE.TGALoader: Format not supported.');\n            break;\n        }\n      } // Load image data according to specific method\n      // var func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';\n      // func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );\n\n\n      return data;\n    } // TGA constants\n\n\n    var TGA_TYPE_NO_DATA = 0,\n        TGA_TYPE_INDEXED = 1,\n        TGA_TYPE_RGB = 2,\n        TGA_TYPE_GREY = 3,\n        TGA_TYPE_RLE_INDEXED = 9,\n        TGA_TYPE_RLE_RGB = 10,\n        TGA_TYPE_RLE_GREY = 11,\n        TGA_ORIGIN_MASK = 0x30,\n        TGA_ORIGIN_SHIFT = 0x04,\n        TGA_ORIGIN_BL = 0x00,\n        TGA_ORIGIN_BR = 0x01,\n        TGA_ORIGIN_UL = 0x02,\n        TGA_ORIGIN_UR = 0x03;\n    if (buffer.length < 19) console.error('THREE.TGALoader: Not enough data to contain header.');\n    var content = new Uint8Array(buffer),\n        offset = 0,\n        header = {\n      id_length: content[offset++],\n      colormap_type: content[offset++],\n      image_type: content[offset++],\n      colormap_index: content[offset++] | content[offset++] << 8,\n      colormap_length: content[offset++] | content[offset++] << 8,\n      colormap_size: content[offset++],\n      origin: [content[offset++] | content[offset++] << 8, content[offset++] | content[offset++] << 8],\n      width: content[offset++] | content[offset++] << 8,\n      height: content[offset++] | content[offset++] << 8,\n      pixel_size: content[offset++],\n      flags: content[offset++]\n    }; // check tga if it is valid format\n\n    tgaCheckHeader(header);\n\n    if (header.id_length + offset > buffer.length) {\n      console.error('THREE.TGALoader: No data.');\n    } // skip the needn't data\n\n\n    offset += header.id_length; // get targa information about RLE compression and palette\n\n    var use_rle = false,\n        use_pal = false,\n        use_grey = false;\n\n    switch (header.image_type) {\n      case TGA_TYPE_RLE_INDEXED:\n        use_rle = true;\n        use_pal = true;\n        break;\n\n      case TGA_TYPE_INDEXED:\n        use_pal = true;\n        break;\n\n      case TGA_TYPE_RLE_RGB:\n        use_rle = true;\n        break;\n\n      case TGA_TYPE_RGB:\n        break;\n\n      case TGA_TYPE_RLE_GREY:\n        use_rle = true;\n        use_grey = true;\n        break;\n\n      case TGA_TYPE_GREY:\n        use_grey = true;\n        break;\n    } //\n\n\n    var imageData = new Uint8Array(header.width * header.height * 4);\n    var result = tgaParse(use_rle, use_pal, header, offset, content);\n    getTgaRGBA(imageData, header.width, header.height, result.pixel_data, result.palettes);\n    return {\n      data: imageData,\n      width: header.width,\n      height: header.height,\n      flipY: true,\n      generateMipmaps: true,\n      minFilter: LinearMipmapLinearFilter\n    };\n  }\n});\nexport { TGALoader };","map":{"version":3,"sources":["/Users/haiakablan/Documents/לוטוס/קורס/Architecture-web/node_modules/three/examples/jsm/loaders/TGALoader.js"],"names":["DataTextureLoader","LinearMipmapLinearFilter","TGALoader","manager","call","prototype","Object","assign","create","constructor","parse","buffer","tgaCheckHeader","header","image_type","TGA_TYPE_INDEXED","TGA_TYPE_RLE_INDEXED","colormap_length","colormap_size","colormap_type","console","error","TGA_TYPE_RGB","TGA_TYPE_GREY","TGA_TYPE_RLE_RGB","TGA_TYPE_RLE_GREY","TGA_TYPE_NO_DATA","width","height","pixel_size","tgaParse","use_rle","use_pal","offset","data","pixel_data","pixel_total","palettes","subarray","Uint8Array","c","count","i","shift","pixels","set","tgaGetImageData8bits","imageData","y_start","y_step","y_end","x_start","x_step","x_end","image","colormap","color","x","y","tgaGetImageData16bits","tgaGetImageData24bits","tgaGetImageData32bits","tgaGetImageDataGrey8bits","tgaGetImageDataGrey16bits","getTgaRGBA","palette","flags","TGA_ORIGIN_MASK","TGA_ORIGIN_SHIFT","TGA_ORIGIN_UL","TGA_ORIGIN_BL","TGA_ORIGIN_UR","TGA_ORIGIN_BR","use_grey","length","content","id_length","colormap_index","origin","result","flipY","generateMipmaps","minFilter"],"mappings":"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","sourcesContent":["import {\n\tDataTextureLoader,\n\tLinearMipmapLinearFilter\n} from '../../../build/three.module.js';\n\nvar TGALoader = function ( manager ) {\n\n\tDataTextureLoader.call( this, manager );\n\n};\n\nTGALoader.prototype = Object.assign( Object.create( DataTextureLoader.prototype ), {\n\n\tconstructor: TGALoader,\n\n\tparse: function ( buffer ) {\n\n\t\t// reference from vthibault, https://github.com/vthibault/roBrowser/blob/master/src/Loaders/Targa.js\n\n\t\tfunction tgaCheckHeader( header ) {\n\n\t\t\tswitch ( header.image_type ) {\n\n\t\t\t\t// check indexed type\n\n\t\t\t\tcase TGA_TYPE_INDEXED:\n\t\t\t\tcase TGA_TYPE_RLE_INDEXED:\n\t\t\t\t\tif ( header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1 ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid type colormap data for indexed type.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// check colormap type\n\n\t\t\t\tcase TGA_TYPE_RGB:\n\t\t\t\tcase TGA_TYPE_GREY:\n\t\t\t\tcase TGA_TYPE_RLE_RGB:\n\t\t\t\tcase TGA_TYPE_RLE_GREY:\n\t\t\t\t\tif ( header.colormap_type ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid type colormap data for colormap type.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// What the need of a file without data ?\n\n\t\t\t\tcase TGA_TYPE_NO_DATA:\n\t\t\t\t\tconsole.error( 'THREE.TGALoader: No data.' );\n\n\t\t\t\t\t// Invalid type ?\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid type \"%s\".', header.image_type );\n\n\t\t\t}\n\n\t\t\t// check image width and height\n\n\t\t\tif ( header.width <= 0 || header.height <= 0 ) {\n\n\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid image size.' );\n\n\t\t\t}\n\n\t\t\t// check image pixel size\n\n\t\t\tif ( header.pixel_size !== 8 && header.pixel_size !== 16 &&\n\t\t\t\theader.pixel_size !== 24 && header.pixel_size !== 32 ) {\n\n\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid pixel size \"%s\".', header.pixel_size );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// parse tga image buffer\n\n\t\tfunction tgaParse( use_rle, use_pal, header, offset, data ) {\n\n\t\t\tvar pixel_data,\n\t\t\t\tpixel_size,\n\t\t\t\tpixel_total,\n\t\t\t\tpalettes;\n\n\t\t\tpixel_size = header.pixel_size >> 3;\n\t\t\tpixel_total = header.width * header.height * pixel_size;\n\n\t\t\t // read palettes\n\n\t\t\t if ( use_pal ) {\n\n\t\t\t\t palettes = data.subarray( offset, offset += header.colormap_length * ( header.colormap_size >> 3 ) );\n\n\t\t\t }\n\n\t\t\t // read RLE\n\n\t\t\t if ( use_rle ) {\n\n\t\t\t\t pixel_data = new Uint8Array( pixel_total );\n\n\t\t\t\tvar c, count, i;\n\t\t\t\tvar shift = 0;\n\t\t\t\tvar pixels = new Uint8Array( pixel_size );\n\n\t\t\t\twhile ( shift < pixel_total ) {\n\n\t\t\t\t\tc = data[ offset ++ ];\n\t\t\t\t\tcount = ( c & 0x7f ) + 1;\n\n\t\t\t\t\t// RLE pixels\n\n\t\t\t\t\tif ( c & 0x80 ) {\n\n\t\t\t\t\t\t// bind pixel tmp array\n\n\t\t\t\t\t\tfor ( i = 0; i < pixel_size; ++ i ) {\n\n\t\t\t\t\t\t\tpixels[ i ] = data[ offset ++ ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// copy pixel array\n\n\t\t\t\t\t\tfor ( i = 0; i < count; ++ i ) {\n\n\t\t\t\t\t\t\tpixel_data.set( pixels, shift + i * pixel_size );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tshift += pixel_size * count;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// raw pixels\n\n\t\t\t\t\t\tcount *= pixel_size;\n\n\t\t\t\t\t\tfor ( i = 0; i < count; ++ i ) {\n\n\t\t\t\t\t\t\tpixel_data[ shift + i ] = data[ offset ++ ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tshift += count;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t } else {\n\n\t\t\t\t// raw pixels\n\n\t\t\t\tpixel_data = data.subarray(\n\t\t\t\t\t offset, offset += ( use_pal ? header.width * header.height : pixel_total )\n\t\t\t\t);\n\n\t\t\t }\n\n\t\t\t return {\n\t\t\t\tpixel_data: pixel_data,\n\t\t\t\tpalettes: palettes\n\t\t\t };\n\n\t\t}\n\n\t\tfunction tgaGetImageData8bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes ) {\n\n\t\t\tvar colormap = palettes;\n\t\t\tvar color, i = 0, x, y;\n\t\t\tvar width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i ++ ) {\n\n\t\t\t\t\tcolor = image[ i ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = 255;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = colormap[ ( color * 3 ) + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = colormap[ ( color * 3 ) + 1 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = colormap[ ( color * 3 ) + 2 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageData16bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tvar color, i = 0, x, y;\n\t\t\tvar width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 2 ) {\n\n\t\t\t\t\tcolor = image[ i + 0 ] + ( image[ i + 1 ] << 8 ); // Inversed ?\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = ( color & 0x7C00 ) >> 7;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = ( color & 0x03E0 ) >> 2;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = ( color & 0x001F ) >> 3;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = ( color & 0x8000 ) ? 0 : 255;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageData24bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tvar i = 0, x, y;\n\t\t\tvar width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 3 ) {\n\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = 255;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 1 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 2 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageData32bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tvar i = 0, x, y;\n\t\t\tvar width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 4 ) {\n\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 1 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 2 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = image[ i + 3 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageDataGrey8bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tvar color, i = 0, x, y;\n\t\t\tvar width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i ++ ) {\n\n\t\t\t\t\tcolor = image[ i ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = color;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = color;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = color;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = 255;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageDataGrey16bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tvar i = 0, x, y;\n\t\t\tvar width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 2 ) {\n\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = image[ i + 1 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction getTgaRGBA( data, width, height, image, palette ) {\n\n\t\t\tvar x_start,\n\t\t\t\ty_start,\n\t\t\t\tx_step,\n\t\t\t\ty_step,\n\t\t\t\tx_end,\n\t\t\t\ty_end;\n\n\t\t\tswitch ( ( header.flags & TGA_ORIGIN_MASK ) >> TGA_ORIGIN_SHIFT ) {\n\n\t\t\t\tdefault:\n\t\t\t\tcase TGA_ORIGIN_UL:\n\t\t\t\t\tx_start = 0;\n\t\t\t\t\tx_step = 1;\n\t\t\t\t\tx_end = width;\n\t\t\t\t\ty_start = 0;\n\t\t\t\t\ty_step = 1;\n\t\t\t\t\ty_end = height;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_ORIGIN_BL:\n\t\t\t\t\tx_start = 0;\n\t\t\t\t\tx_step = 1;\n\t\t\t\t\tx_end = width;\n\t\t\t\t\ty_start = height - 1;\n\t\t\t\t\ty_step = - 1;\n\t\t\t\t\ty_end = - 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_ORIGIN_UR:\n\t\t\t\t\tx_start = width - 1;\n\t\t\t\t\tx_step = - 1;\n\t\t\t\t\tx_end = - 1;\n\t\t\t\t\ty_start = 0;\n\t\t\t\t\ty_step = 1;\n\t\t\t\t\ty_end = height;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_ORIGIN_BR:\n\t\t\t\t\tx_start = width - 1;\n\t\t\t\t\tx_step = - 1;\n\t\t\t\t\tx_end = - 1;\n\t\t\t\t\ty_start = height - 1;\n\t\t\t\t\ty_step = - 1;\n\t\t\t\t\ty_end = - 1;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( use_grey ) {\n\n\t\t\t\tswitch ( header.pixel_size ) {\n\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\ttgaGetImageDataGrey8bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 16:\n\t\t\t\t\t\ttgaGetImageDataGrey16bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'THREE.TGALoader: Format not supported.' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tswitch ( header.pixel_size ) {\n\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\ttgaGetImageData8bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 16:\n\t\t\t\t\t\ttgaGetImageData16bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 24:\n\t\t\t\t\t\ttgaGetImageData24bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 32:\n\t\t\t\t\t\ttgaGetImageData32bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'THREE.TGALoader: Format not supported.' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Load image data according to specific method\n\t\t\t// var func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';\n\t\t\t// func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );\n\t\t\treturn data;\n\n\t\t}\n\n\t\t// TGA constants\n\n\t\tvar TGA_TYPE_NO_DATA = 0,\n\t\t\tTGA_TYPE_INDEXED = 1,\n\t\t\tTGA_TYPE_RGB = 2,\n\t\t\tTGA_TYPE_GREY = 3,\n\t\t\tTGA_TYPE_RLE_INDEXED = 9,\n\t\t\tTGA_TYPE_RLE_RGB = 10,\n\t\t\tTGA_TYPE_RLE_GREY = 11,\n\n\t\t\tTGA_ORIGIN_MASK = 0x30,\n\t\t\tTGA_ORIGIN_SHIFT = 0x04,\n\t\t\tTGA_ORIGIN_BL = 0x00,\n\t\t\tTGA_ORIGIN_BR = 0x01,\n\t\t\tTGA_ORIGIN_UL = 0x02,\n\t\t\tTGA_ORIGIN_UR = 0x03;\n\n\t\tif ( buffer.length < 19 ) console.error( 'THREE.TGALoader: Not enough data to contain header.' );\n\n\t\tvar content = new Uint8Array( buffer ),\n\t\t\toffset = 0,\n\t\t\theader = {\n\t\t\t\tid_length: content[ offset ++ ],\n\t\t\t\tcolormap_type: content[ offset ++ ],\n\t\t\t\timage_type: content[ offset ++ ],\n\t\t\t\tcolormap_index: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\tcolormap_length: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\tcolormap_size: content[ offset ++ ],\n\t\t\t\torigin: [\n\t\t\t\t\tcontent[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\t\tcontent[ offset ++ ] | content[ offset ++ ] << 8\n\t\t\t\t],\n\t\t\t\twidth: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\theight: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\tpixel_size: content[ offset ++ ],\n\t\t\t\tflags: content[ offset ++ ]\n\t\t\t};\n\n\t\t// check tga if it is valid format\n\n\t\ttgaCheckHeader( header );\n\n\t\tif ( header.id_length + offset > buffer.length ) {\n\n\t\t\tconsole.error( 'THREE.TGALoader: No data.' );\n\n\t\t}\n\n\t\t// skip the needn't data\n\n\t\toffset += header.id_length;\n\n\t\t// get targa information about RLE compression and palette\n\n\t\tvar use_rle = false,\n\t\t\tuse_pal = false,\n\t\t\tuse_grey = false;\n\n\t\tswitch ( header.image_type ) {\n\n\t\t\tcase TGA_TYPE_RLE_INDEXED:\n\t\t\t\tuse_rle = true;\n\t\t\t\tuse_pal = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_INDEXED:\n\t\t\t\tuse_pal = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_RLE_RGB:\n\t\t\t\tuse_rle = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_RGB:\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_RLE_GREY:\n\t\t\t\tuse_rle = true;\n\t\t\t\tuse_grey = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_GREY:\n\t\t\t\tuse_grey = true;\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\t//\n\n\t\tvar imageData = new Uint8Array( header.width * header.height * 4 );\n\t\tvar result = tgaParse( use_rle, use_pal, header, offset, content );\n\t\tgetTgaRGBA( imageData, header.width, header.height, result.pixel_data, result.palettes );\n\n\t\treturn {\n\n\t\t\tdata: imageData,\n\t\t\twidth: header.width,\n\t\t\theight: header.height,\n\t\t\tflipY: true,\n\t\t\tgenerateMipmaps: true,\n\t\t\tminFilter: LinearMipmapLinearFilter,\n\n\t\t};\n\n\t}\n\n} );\n\nexport { TGALoader };\n"]},"metadata":{},"sourceType":"module"}