{"version":3,"file":"index.module.js","sources":["../src/ErrorBoundary.ts","../src/use-error-boundary.ts","../src/create-error-boundary.ts"],"sourcesContent":["import { PureComponent } from \"react\"\n\nexport type ErrorObject = {\n  error: any\n}\n\n/**\n * Internal callback, used to link the hook state to the boundary state.\n */\nexport type OnDidCatchCallback = (error: any, errorInfo: any) => void\n\n/**\n * Props of the internal ErrorBoundary component.\n *\n * onDidCatch is used internally.\n * children, render and renderError are public facing and get utilized by the UseErrorBoundaryWrapper.\n */\nexport interface ErrorBoundaryProps {\n  onDidCatch: OnDidCatchCallback\n  children?: React.ReactNode | JSX.Element\n  render?: () => React.ReactNode | JSX.Element\n  renderError?: (error: ErrorObject) => React.ReactNode | JSX.Element\n}\n\n/**\n * Internal ErrorBoundary state.\n */\nexport interface ErrorBoundaryState {\n  hasError: boolean\n  error: any\n}\n\n/**\n * ErrorBoundary class\n *\n * Catches errors using lifecycle methods and renders fallback ui using children or render props.\n */\nexport class ErrorBoundary extends PureComponent<\n  ErrorBoundaryProps,\n  ErrorBoundaryState\n> {\n  /**\n   * Initialize component state.\n   */\n  constructor(props: ErrorBoundaryProps) {\n    super(props)\n\n    this.state = {\n      hasError: false,\n      error: null,\n    }\n  }\n\n  /**\n   * Set error state when the boundary catches.\n   */\n  static getDerivedStateFromError(error: any) {\n    return { hasError: true, error }\n  }\n\n  /**\n   * Use componentDidCatch lifecycle method to report the error using\n   * the onDidCatch prop.\n   */\n  componentDidCatch(error: any, errorInfo: any) {\n    return this.props.onDidCatch(error, errorInfo)\n  }\n  /**\n   * Render children or fallback ui depending on the error state.\n   *\n   * Uses render props api if either render or renderError is defined.\n   */\n  render() {\n    const { hasError, error } = this.state\n    const { render, children, renderError } = this.props\n\n    // Prevent rendering of children that caused the error, render fallbacks instead\n    if (hasError) {\n      // Render either components from renderError() or nothing\n      return renderError ? renderError({ error }) : null\n    }\n\n    // Render either components from render() or children or null\n    return render ? render() : children || null\n  }\n}\n","import React, { useRef, useReducer } from \"react\"\n\nimport {\n  createErrorBoundary,\n  UseErrorBoundaryWrapper,\n} from \"./create-error-boundary\"\n\nexport interface ErrorState {\n  didCatch: boolean\n  error: any | null\n}\n\nexport interface UseErrorBoundaryState extends ErrorState {\n  ErrorBoundary: UseErrorBoundaryWrapper\n}\n\ninterface StateAction {\n  type: \"catch\"\n  error?: any | null\n}\n\n/**\n * useErrorBoundary hook options.\n */\nexport interface UseErrorBoundaryOptions {\n  /**\n   * Gets called when the ErrorBoundary catches an error.\n   *\n   * You can use this for logging or reporting errors.\n   */\n  onDidCatch?: (error: any, errorInfo: any) => void\n}\n\n/**\n * useErrorBoundary\n * React hook to use an ErrorBoundary in your component and keep track of the\n * error state of that boundary.\n *\n * Uses a wrapped class component to create the error Boundary, but uses hooks to keep the state\n * in your function component.\n */\n\ntype UseErrorBoundaryReducer = (\n  state: ErrorState,\n  action: StateAction\n) => ErrorState\n\nconst useErrorBoundaryReducer: UseErrorBoundaryReducer = (state, action) => {\n  switch (action.type) {\n    // The component did catch, update state\n    case \"catch\":\n      return {\n        //...state,\n        didCatch: true,\n        // Pass the values from action.error\n        error: action.error,\n      }\n    // Unknown action, return state\n    default:\n      return state\n  }\n}\n\nfunction useErrorBoundary(\n  options?: UseErrorBoundaryOptions\n): UseErrorBoundaryState {\n  // Reducer handling the error state\n  const [state, dispatch] = useReducer<UseErrorBoundaryReducer>(\n    useErrorBoundaryReducer,\n    // Default state\n    {\n      didCatch: false,\n      error: null,\n    }\n  )\n  // Create ref for wrapped ErrorBoundary class\n  const errorBoundaryWrapperRef = useRef<UseErrorBoundaryWrapper | null>(null)\n\n  // Get the current ref value or initialize it with a new wrapped ErrorBoundary\n  function getWrappedErrorBoundary() {\n    // Get current ref value\n    let errorBoundaryWrapper = errorBoundaryWrapperRef.current\n\n    // Return the component when already initialized\n    if (errorBoundaryWrapper !== null) {\n      return errorBoundaryWrapper\n    }\n\n    // Create new wrapped ErrorBoundary class with onDidCatch callback\n    errorBoundaryWrapper = createErrorBoundary((err, errorInfo) => {\n      // Dispatch action in case of an error\n      dispatch({\n        type: \"catch\",\n        error: err,\n      })\n\n      // call onDidCatch if provided by user\n      if (options && options.onDidCatch) options.onDidCatch(err, errorInfo)\n    })\n\n    // Update the ref with new component\n    errorBoundaryWrapperRef.current = errorBoundaryWrapper\n\n    // Return the newly created component\n    return errorBoundaryWrapper\n  }\n\n  // Return the wrapped ErrorBoundary class to wrap your components in plus the error state\n  return {\n    ErrorBoundary: getWrappedErrorBoundary(),\n    didCatch: state.didCatch,\n    error: state.error,\n  }\n}\n\nexport default useErrorBoundary\n","import React from \"react\"\n\nimport {\n  ErrorBoundary,\n  ErrorBoundaryProps,\n  OnDidCatchCallback,\n} from \"./ErrorBoundary\"\n\n/**\n * createErrorBoundary\n * Accepts a onDidCatch callback.\n * Creates a UseErrorBoundaryWrapper HOC, to keep the onDidCatch callback while\n * still providing the ability to pass props to the ErrorBoundary\n */\n\nexport type UseErrorBoundaryWrapper = (\n  props: Omit<ErrorBoundaryProps, \"onDidCatch\">\n) => React.ReactElement\n\nexport function createErrorBoundary(\n  onDidCatch: OnDidCatchCallback\n): UseErrorBoundaryWrapper {\n  // Return function component that wraps ErrorBoundary and passes props to it\n  return function UseErrorBoundaryWrapper(props) {\n    // Return ErrorBoundary with original onDidCatch and the current props\n    return React.createElement<ErrorBoundaryProps>(ErrorBoundary, {\n      onDidCatch,\n      children: props.children,\n      render: props.render,\n      renderError: props.renderError,\n    })\n  }\n}\n"],"names":["ErrorBoundary","props","_this","state","hasError","error","getDerivedStateFromError","componentDidCatch","errorInfo","onDidCatch","render","this","children","renderError","PureComponent","useErrorBoundaryReducer","action","type","didCatch","useErrorBoundary","options","errorBoundaryWrapper","useReducer","dispatch","errorBoundaryWrapperRef","useRef","current","err","React","createElement"],"mappings":"yEAqCaA,sBAOX,WAAYC,gBACVC,cAAMD,UAEDE,MAAQ,CACXC,UAAU,EACVC,MAAO,+FAZbL,EAmBSM,yBAAP,SAAgCD,GAC9B,MAAO,CAAED,UAAU,EAAMC,MAAAA,+BAO3BE,kBAAA,SAAkBF,EAAYG,GAC5B,YAAYP,MAAMQ,WAAWJ,EAAOG,MAOtCE,OAAA,iBAC8BC,KAAKR,QACSQ,KAAKV,MAAvCS,IAAAA,OAAQE,IAAAA,SAAUC,IAAAA,YAG1B,SAJQT,SAMCS,EAAcA,EAAY,CAAER,QANnBA,QAM8B,KAIzCK,EAASA,IAAWE,GAAY,SA9CRE,GCU7BC,EAAmD,SAACZ,EAAOa,GAC/D,OAAQA,EAAOC,MAEb,IAAK,QACH,MAAO,CAELC,UAAU,EAEVb,MAAOW,EAAOX,OAGlB,QACE,OAAOF,IAIb,SAASgB,EACPC,OC5CAX,ED6DMY,IAdoBC,EACxBP,EAEA,CACEG,UAAU,EACVb,MAAO,OALJF,OAAOoB,OASRC,EAA0BC,EAAuC,MAgCvE,MAAO,CACLzB,eA5BIqB,EAAuBG,EAAwBE,QAGtB,OAAzBL,IChENZ,EDqE6C,SAACkB,EAAKnB,GAE/Ce,EAAS,CACPN,KAAM,QACNZ,MAAOsB,IAILP,GAAWA,EAAQX,YAAYW,EAAQX,WAAWkB,EAAKnB,IAI7DgB,EAAwBE,QAZxBL,WClEsCpB,GAEtC,OAAO2B,EAAMC,cAAkC7B,EAAe,CAC5DS,WAAAA,EACAG,SAAUX,EAAMW,SAChBF,OAAQT,EAAMS,OACdG,YAAaZ,EAAMY,gBDwDZQ,GAyBTH,SAAUf,EAAMe,SAChBb,MAAOF,EAAME"}