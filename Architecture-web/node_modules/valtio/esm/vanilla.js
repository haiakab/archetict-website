import { getUntrackedObject, markToTrack } from 'proxy-compare';

const VERSION = Symbol();
const LISTENERS = Symbol();
const SNAPSHOT = Symbol();
const PROMISE_RESULT = Symbol();
const PROMISE_ERROR = Symbol();
const refSet = new WeakSet();
const ref = (o) => {
  refSet.add(o);
  return o;
};
const isSupportedObject = (x) => typeof x === "object" && x !== null && (Array.isArray(x) || !x[Symbol.iterator]) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer);
const proxyCache = new WeakMap();
let globalVersion = 1;
const snapshotCache = new WeakMap();
const proxy = (initialObject = {}) => {
  if (!isSupportedObject(initialObject)) {
    throw new Error("unsupported object type");
  }
  if (proxyCache.has(initialObject)) {
    return proxyCache.get(initialObject);
  }
  let version = globalVersion;
  const listeners = new Set();
  const notifyUpdate = (nextVersion) => {
    if (!nextVersion) {
      nextVersion = ++globalVersion;
    }
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(nextVersion));
    }
  };
  const createSnapshot = (target, receiver) => {
    const cache = snapshotCache.get(receiver);
    if (cache && cache.version === version) {
      return cache.snapshot;
    }
    const snapshot2 = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
    markToTrack(snapshot2, true);
    snapshotCache.set(receiver, {version, snapshot: snapshot2});
    Reflect.ownKeys(target).forEach((key) => {
      const value = target[key];
      if (refSet.has(value)) {
        markToTrack(value, false);
        snapshot2[key] = value;
      } else if (!isSupportedObject(value)) {
        snapshot2[key] = value;
      } else if (value instanceof Promise) {
        if (PROMISE_RESULT in value) {
          snapshot2[key] = value[PROMISE_RESULT];
        } else {
          const errorOrPromise = value[PROMISE_ERROR] || value;
          Object.defineProperty(snapshot2, key, {
            get() {
              throw errorOrPromise;
            }
          });
        }
      } else if (value[VERSION]) {
        snapshot2[key] = value[SNAPSHOT];
      } else {
        snapshot2[key] = value;
      }
    });
    Object.freeze(snapshot2);
    return snapshot2;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const proxyObject = new Proxy(baseObject, {
    get(target, prop, receiver) {
      if (prop === VERSION) {
        return version;
      }
      if (prop === LISTENERS) {
        return listeners;
      }
      if (prop === SNAPSHOT) {
        return createSnapshot(target, receiver);
      }
      return target[prop];
    },
    deleteProperty(target, prop) {
      const prevValue = target[prop];
      const childListeners = prevValue && prevValue[LISTENERS];
      if (childListeners) {
        childListeners.delete(notifyUpdate);
      }
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate();
      }
      return deleted;
    },
    set(target, prop, value) {
      var _a;
      const prevValue = target[prop];
      if (Object.is(prevValue, value)) {
        return true;
      }
      const childListeners = prevValue && prevValue[LISTENERS];
      if (childListeners) {
        childListeners.delete(notifyUpdate);
      }
      if (refSet.has(value) || !isSupportedObject(value) || ((_a = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a.set)) {
        target[prop] = value;
      } else if (value instanceof Promise) {
        target[prop] = value.then((v) => {
          target[prop][PROMISE_RESULT] = v;
          notifyUpdate();
          return v;
        }).catch((e) => {
          target[prop][PROMISE_ERROR] = e;
          notifyUpdate();
        });
      } else {
        value = getUntrackedObject(value) || value;
        if (value[LISTENERS]) {
          target[prop] = value;
        } else {
          target[prop] = proxy(value);
        }
        target[prop][LISTENERS].add(notifyUpdate);
      }
      notifyUpdate();
      return true;
    }
  });
  proxyCache.set(initialObject, proxyObject);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
};
const getVersion = (proxyObject) => {
  if (typeof process === "object" && process.env.NODE_ENV !== "production" && (!proxyObject || !proxyObject[VERSION])) {
    throw new Error("Please use proxy object");
  }
  return proxyObject[VERSION];
};
const subscribe = (proxyObject, callback, notifyInSync) => {
  if (typeof process === "object" && process.env.NODE_ENV !== "production" && (!proxyObject || !proxyObject[LISTENERS])) {
    throw new Error("Please use proxy object");
  }
  let pendingVersion = 0;
  const listener = (nextVersion) => {
    if (notifyInSync) {
      callback();
      return;
    }
    pendingVersion = nextVersion;
    Promise.resolve().then(() => {
      if (nextVersion === pendingVersion) {
        callback();
      }
    });
  };
  proxyObject[LISTENERS].add(listener);
  return () => {
    proxyObject[LISTENERS].delete(listener);
  };
};
const snapshot = (proxyObject) => {
  if (typeof process === "object" && process.env.NODE_ENV !== "production" && (!proxyObject || !proxyObject[SNAPSHOT])) {
    throw new Error("Please use proxy object");
  }
  return proxyObject[SNAPSHOT];
};

export { getVersion, proxy, ref, snapshot, subscribe };
