import { createDeepProxy, isDeepChanged } from 'proxy-compare';
import { subscribe, snapshot, proxy } from 'valtio/vanilla';

const subscribeKey = (proxyObject, key, callback, notifyInSync) => {
  let prevValue = proxyObject[key];
  return subscribe(proxyObject, () => {
    const nextValue = proxyObject[key];
    if (!Object.is(prevValue, nextValue)) {
      callback(prevValue = nextValue);
    }
  }, notifyInSync);
};
const devtools = (proxyObject, name) => {
  let extension;
  try {
    extension = window.__REDUX_DEVTOOLS_EXTENSION__;
  } catch {
  }
  if (!extension) {
    if (typeof process === "object" && process.env.NODE_ENV === "development" && typeof window !== "undefined") {
      console.warn("[Warning] Please install/enable Redux devtools extension");
    }
    return;
  }
  let isTimeTraveling = false;
  const devtools2 = extension.connect({name});
  const unsub1 = subscribe(proxyObject, () => {
    if (isTimeTraveling) {
      isTimeTraveling = false;
    } else {
      devtools2.send(`Update - ${new Date().toLocaleString()}`, snapshot(proxyObject));
    }
  });
  const unsub2 = devtools2.subscribe((message) => {
    var _a, _b, _c;
    if (message.type === "DISPATCH" && message.state) {
      if (((_a = message.payload) == null ? void 0 : _a.type) === "JUMP_TO_ACTION" || ((_b = message.payload) == null ? void 0 : _b.type) === "JUMP_TO_STATE") {
        isTimeTraveling = true;
      }
      const nextValue = JSON.parse(message.state);
      Object.keys(nextValue).forEach((key) => {
        proxyObject[key] = nextValue[key];
      });
    } else if (message.type === "DISPATCH" && ((_c = message.payload) == null ? void 0 : _c.type) === "COMMIT") {
      devtools2.init(snapshot(proxyObject));
    }
  });
  devtools2.init(snapshot(proxyObject));
  return () => {
    unsub1();
    unsub2();
  };
};
const addComputed = (proxyObject, computedFns, targetObject = proxyObject) => {
  Object.keys(computedFns).forEach((key) => {
    if (Object.getOwnPropertyDescriptor(targetObject, key)) {
      throw new Error("object property already defined");
    }
    const get = computedFns[key];
    let prevSnapshot;
    let affected = new WeakMap();
    let pending = false;
    const callback = () => {
      const nextSnapshot = snapshot(proxyObject);
      if (!pending && (!prevSnapshot || isDeepChanged(prevSnapshot, nextSnapshot, affected))) {
        affected = new WeakMap();
        const value = get(createDeepProxy(nextSnapshot, affected));
        prevSnapshot = nextSnapshot;
        if (value instanceof Promise) {
          pending = true;
          value.then((v) => {
            targetObject[key] = v;
          }).catch((e) => {
            targetObject[key] = new Proxy({}, {
              get() {
                throw e;
              }
            });
          }).finally(() => {
            pending = false;
          });
        }
        targetObject[key] = value;
      }
    };
    subscribe(proxyObject, callback);
    callback();
  });
};
const proxyWithComputed = (initialObject, computedFns) => {
  Object.keys(computedFns).forEach((key) => {
    if (Object.getOwnPropertyDescriptor(initialObject, key)) {
      throw new Error("object property already defined");
    }
    const computedFn = computedFns[key];
    const {get, set} = typeof computedFn === "function" ? {get: computedFn} : computedFn;
    let computedValue;
    let prevSnapshot;
    let affected = new WeakMap();
    const desc = {};
    desc.get = () => {
      const nextSnapshot = snapshot(proxyObject);
      if (!prevSnapshot || isDeepChanged(prevSnapshot, nextSnapshot, affected)) {
        affected = new WeakMap();
        computedValue = get(createDeepProxy(nextSnapshot, affected));
        prevSnapshot = nextSnapshot;
      }
      return computedValue;
    };
    if (set) {
      desc.set = (newValue) => set(proxyObject, newValue);
    }
    Object.defineProperty(initialObject, key, desc);
  });
  const proxyObject = proxy(initialObject);
  return proxyObject;
};

export { addComputed, devtools, proxyWithComputed, subscribeKey };
