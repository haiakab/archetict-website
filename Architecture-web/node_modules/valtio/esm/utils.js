import { createProxy, isChanged } from 'proxy-compare';
import { subscribe, snapshot, proxy } from 'valtio/vanilla';

const subscribeKey = (proxyObject, key, callback, notifyInSync) => {
  let prevValue = proxyObject[key];
  return subscribe(proxyObject, () => {
    const nextValue = proxyObject[key];
    if (!Object.is(prevValue, nextValue)) {
      callback(prevValue = nextValue);
    }
  }, notifyInSync);
};
const devtools = (proxyObject, name) => {
  let extension;
  try {
    extension = window.__REDUX_DEVTOOLS_EXTENSION__;
  } catch {
  }
  if (!extension) {
    if (typeof process === "object" && process.env.NODE_ENV === "development" && typeof window !== "undefined") {
      console.warn("[Warning] Please install/enable Redux devtools extension");
    }
    return;
  }
  let isTimeTraveling = false;
  const devtools2 = extension.connect({ name });
  const unsub1 = subscribe(proxyObject, () => {
    if (isTimeTraveling) {
      isTimeTraveling = false;
    } else {
      devtools2.send(`Update - ${new Date().toLocaleString()}`, snapshot(proxyObject));
    }
  });
  const unsub2 = devtools2.subscribe((message) => {
    var _a, _b, _c, _d, _e, _f;
    if (message.type === "DISPATCH" && message.state) {
      if (((_a = message.payload) == null ? void 0 : _a.type) === "JUMP_TO_ACTION" || ((_b = message.payload) == null ? void 0 : _b.type) === "JUMP_TO_STATE") {
        isTimeTraveling = true;
      }
      const nextValue = JSON.parse(message.state);
      Object.keys(nextValue).forEach((key) => {
        proxyObject[key] = nextValue[key];
      });
    } else if (message.type === "DISPATCH" && ((_c = message.payload) == null ? void 0 : _c.type) === "COMMIT") {
      devtools2.init(snapshot(proxyObject));
    } else if (message.type === "DISPATCH" && ((_d = message.payload) == null ? void 0 : _d.type) === "IMPORT_STATE") {
      const actions = (_e = message.payload.nextLiftedState) == null ? void 0 : _e.actionsById;
      const computedStates = ((_f = message.payload.nextLiftedState) == null ? void 0 : _f.computedStates) || [];
      isTimeTraveling = true;
      computedStates.forEach(({ state }, index) => {
        const action = actions[index] || `Update - ${new Date().toLocaleString()}`;
        Object.keys(state).forEach((key) => {
          proxyObject[key] = state[key];
        });
        if (index === 0) {
          devtools2.init(snapshot(proxyObject));
        } else {
          devtools2.send(action, snapshot(proxyObject));
        }
      });
    }
  });
  devtools2.init(snapshot(proxyObject));
  return () => {
    unsub1();
    unsub2();
  };
};
const addComputed = (proxyObject, computedFns, targetObject = proxyObject) => {
  Object.keys(computedFns).forEach((key) => {
    if (Object.getOwnPropertyDescriptor(targetObject, key)) {
      throw new Error("object property already defined");
    }
    const get = computedFns[key];
    let prevSnapshot;
    let affected = new WeakMap();
    let pending = false;
    const callback = () => {
      const nextSnapshot = snapshot(proxyObject);
      if (!pending && (!prevSnapshot || isChanged(prevSnapshot, nextSnapshot, affected))) {
        affected = new WeakMap();
        const value = get(createProxy(nextSnapshot, affected));
        prevSnapshot = nextSnapshot;
        if (value instanceof Promise) {
          pending = true;
          value.then((v) => {
            targetObject[key] = v;
          }).catch((e) => {
            targetObject[key] = new Proxy({}, {
              get() {
                throw e;
              }
            });
          }).finally(() => {
            pending = false;
          });
        }
        targetObject[key] = value;
      }
    };
    subscribe(proxyObject, callback);
    callback();
  });
};
const proxyWithComputed = (initialObject, computedFns) => {
  Object.keys(computedFns).forEach((key) => {
    if (Object.getOwnPropertyDescriptor(initialObject, key)) {
      throw new Error("object property already defined");
    }
    const computedFn = computedFns[key];
    const { get, set } = typeof computedFn === "function" ? { get: computedFn } : computedFn;
    let computedValue;
    let prevSnapshot;
    let affected = new WeakMap();
    const desc = {};
    desc.get = () => {
      const nextSnapshot = snapshot(proxyObject);
      if (!prevSnapshot || isChanged(prevSnapshot, nextSnapshot, affected)) {
        affected = new WeakMap();
        computedValue = get(createProxy(nextSnapshot, affected));
        prevSnapshot = nextSnapshot;
      }
      return computedValue;
    };
    if (set) {
      desc.set = (newValue) => set(proxyObject, newValue);
    }
    Object.defineProperty(initialObject, key, desc);
  });
  const proxyObject = proxy(initialObject);
  return proxyObject;
};
let currentCleanups;
const watch = (callback) => {
  const cleanups = new Set();
  const subscriptions = new Set();
  let alive = true;
  const cleanup = () => {
    cleanups.forEach((clean) => {
      clean();
    });
    cleanups.clear();
    subscriptions.clear();
  };
  const revalidate = () => {
    if (!alive) {
      return;
    }
    cleanup();
    const parent = currentCleanups;
    currentCleanups = cleanups;
    try {
      const cleanupReturn = callback((proxy2) => {
        subscriptions.add(proxy2);
        return proxy2;
      });
      if (cleanupReturn) {
        cleanups.add(cleanupReturn);
      }
    } finally {
      currentCleanups = parent;
    }
    subscriptions.forEach((proxy2) => {
      const clean = subscribe(proxy2, revalidate);
      cleanups.add(clean);
    });
  };
  const wrappedCleanup = () => {
    if (alive) {
      cleanup();
      alive = false;
    }
  };
  if (currentCleanups) {
    currentCleanups.add(wrappedCleanup);
  }
  revalidate();
  return wrappedCleanup;
};

export { addComputed, devtools, proxyWithComputed, subscribeKey, watch };
