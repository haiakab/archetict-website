import type { DeepResolveType } from './vanilla';
/**
 * subscribeKey
 *
 * The subscribeKey utility enables subscription to a primitive subproperty of a given state proxy.
 * Subscriptions created with subscribeKey will only fire when the specified property changes.
 * notifyInSync: same as the parameter to subscribe(); true disables batching of subscriptions.
 *
 * @example
 * import { subscribeKey } from 'valtio/utils'
 * subscribeKey(state, 'count', (v) => console.log('state.count has changed to', v))
 */
export declare const subscribeKey: <T extends object>(proxyObject: T, key: keyof T, callback: (value: T[keyof T]) => void, notifyInSync?: boolean | undefined) => () => void;
/**
 * devtools
 *
 * This is to connect with [Redux DevTools Extension](https://github.com/zalmoxisus/redux-devtools-extension).
 * Limitation: Only plain objects/values are supported.
 *
 * @example
 * import { devtools } from 'valtio/utils'
 * const state = proxy({ count: 0, text: 'hello' })
 * const unsub = devtools(state, 'state name')
 */
export declare const devtools: <T extends object>(proxyObject: T, name?: string | undefined) => (() => void) | undefined;
/**
 * addComputed
 *
 * This adds computed values to an existing proxy object.
 *
 * [Notes]
 * This comes with a cost and overlaps with useSnapshot.
 * Do not try to optimize too early. It can worsen the performance.
 * Measurement and comparison will be very important.
 *
 * @example
 * import { proxy } from 'valtio'
 * import { addComputed } from 'valtio/utils'
 * const state = proxy({
 *   count: 1,
 * })
 * addComputed(state, {
 *   doubled: snap => snap.count * 2,
 * })
 */
export declare const addComputed: <T extends object, U extends object>(proxyObject: T, computedFns: { [K in keyof U]: (snap: DeepResolveType<T>) => U[K]; }, targetObject?: any) => void;
/**
 * proxyWithComputed
 *
 * This is to create a proxy with initial object and additional object,
 * which specifies getters for computed values with dependency tracking.
 * It also accepts optional setters for computed values.
 *
 * [Notes]
 * This comes with a cost and overlaps with useSnapshot.
 * Do not try to optimize too early. It can worsen the performance.
 * Measurement and comparison will be very important.
 *
 * @example
 * import { proxyWithComputed } from 'valtio/utils'
 * const state = proxyWithComputed({
 *   count: 1,
 * }, {
 *   doubled: snap => snap.count * 2, // getter only
 *   tripled: {
 *     get: snap => snap.count * 3,
 *     set: (state, newValue) => { state.count = newValue / 3 }
 *   }, // with optional setter
 * })
 */
export declare const proxyWithComputed: <T extends object, U extends object>(initialObject: T, computedFns: { [K in keyof U]: {
    get: (snap: DeepResolveType<T>) => U[K];
    set?: ((state: T, newValue: U[K]) => void) | undefined;
} | ((snap: DeepResolveType<T>) => U[K]); }) => T & U;
declare type WatchGet = <T extends object>(value: T) => T;
declare type WatchCallback = (get: WatchGet) => (() => void) | void | undefined;
/**
 * watch
 *
 * Creates a reactive effect that automatically tracks proxy objects and
 * reevaluates everytime one of the tracked proxy objects updates. It returns
 * a cleanup function to stop the reactive effect from reevaluating.
 *
 * Callback is invoked immediately to detect the tracked objects.
 *
 * Callback passed to `watch` receives a `get` function that "tracks" the
 * passed proxy object.
 *
 * Watch callbacks may return an optional cleanup function, which is evaluated
 * whenever the callback reevaluates or when the cleanup function returned by
 * `watch` is evaluated.
 *
 * `watch` calls inside `watch` are also automatically tracked and cleaned up
 * whenever the parent `watch` reevaluates.
 *
 * @param callback
 * @returns A cleanup function that stops the callback from reevaluating and
 * also performs cleanups registered into `watch`.
 */
export declare const watch: (callback: WatchCallback) => (() => void);
export {};
