{"version":3,"file":"ModelViewerGLTFInstance.js","sourceRoot":"","sources":["../../../src/three-components/gltf-instance/ModelViewerGLTFInstance.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {BackSide, DoubleSide, FrontSide, Material, Mesh, MeshStandardMaterial, Object3D, Shader, Texture} from 'three';\nimport {GLTF} from 'three/examples/jsm/loaders/GLTFLoader.js';\n\nimport {$clone, $prepare, $preparedGLTF, GLTFInstance, PreparedGLTF} from '../GLTFInstance.js';\nimport {Renderer} from '../Renderer.js';\nimport {alphaChunk} from '../shader-chunk/alphatest_fragment.glsl.js';\n\nimport {CorrelatedSceneGraph} from './correlated-scene-graph.js';\n\n\n\nconst $cloneAndPatchMaterial = Symbol('cloneAndPatchMaterial');\nconst $correlatedSceneGraph = Symbol('correlatedSceneGraph');\n\ninterface PreparedModelViewerGLTF extends PreparedGLTF {\n  [$correlatedSceneGraph]?: CorrelatedSceneGraph;\n}\n\n/**\n * This specialization of GLTFInstance collects all of the processing needed\n * to prepare a model and to clone it making special considerations for\n * <model-viewer> use cases.\n */\nexport class ModelViewerGLTFInstance extends GLTFInstance {\n  /**\n   * @override\n   */\n  protected static[$prepare](source: GLTF) {\n    const prepared = super[$prepare](source) as PreparedModelViewerGLTF;\n\n    if (prepared[$correlatedSceneGraph] == null) {\n      prepared[$correlatedSceneGraph] = CorrelatedSceneGraph.from(prepared);\n    }\n\n    const {scene} = prepared;\n\n    const meshesToDuplicate: Mesh[] = [];\n\n    scene.traverse((node: Object3D) => {\n      // Set a high renderOrder while we're here to ensure the model\n      // always renders on top of the skysphere\n      node.renderOrder = 1000;\n\n      // Three.js seems to cull some animated models incorrectly. Since we\n      // expect to view our whole scene anyway, we turn off the frustum\n      // culling optimization here.\n      node.frustumCulled = false;\n      // Animations for objects without names target their UUID instead. When\n      // objects are cloned, they get new UUIDs which the animation can't\n      // find. To fix this, we assign their UUID as their name.\n      if (!node.name) {\n        node.name = node.uuid;\n      }\n      if (!(node as Mesh).isMesh) {\n        return;\n      }\n      node.castShadow = true;\n      const mesh = node as Mesh;\n      let transparent = false;\n      const materials =\n          Array.isArray(mesh.material) ? mesh.material : [mesh.material];\n      materials.forEach(material => {\n        if ((material as any).isMeshStandardMaterial) {\n          if (material.transparent && material.side === DoubleSide) {\n            transparent = true;\n            material.side = FrontSide;\n          }\n        }\n      });\n\n      if (transparent) {\n        meshesToDuplicate.push(mesh);\n      }\n    });\n\n    // We duplicate transparent, double-sided meshes and render the back face\n    // before the front face. This creates perfect triangle sorting for all\n    // convex meshes. Sorting artifacts can still appear when you can see\n    // through more than two layers of a given mesh, but this can usually be\n    // mitigated by the author splitting the mesh into mostly convex regions.\n    // The performance cost is not too great as the same shader is reused and\n    // the same number of fragments are processed; only the vertex shader is run\n    // twice. @see https://threejs.org/examples/webgl_materials_physical_transparency.html\n    for (const mesh of meshesToDuplicate) {\n      const materials =\n          Array.isArray(mesh.material) ? mesh.material : [mesh.material];\n      const duplicateMaterials = materials.map((material) => {\n        const backMaterial = material.clone();\n        backMaterial.side = BackSide;\n        return backMaterial;\n      });\n      const duplicateMaterial = Array.isArray(mesh.material) ?\n          duplicateMaterials :\n          duplicateMaterials[0];\n      const meshBack = mesh.clone() as Mesh;\n      meshBack.material = duplicateMaterial;\n      meshBack.renderOrder = -1;\n      mesh.parent!.add(meshBack);\n    }\n\n    return prepared;\n  }\n\n  get correlatedSceneGraph() {\n    return (\n        this[$preparedGLTF] as PreparedModelViewerGLTF)[$correlatedSceneGraph]!;\n  }\n\n  /**\n   * @override\n   */\n  [$clone](): PreparedGLTF {\n    const clone: PreparedModelViewerGLTF = super[$clone]();\n    const sourceUUIDToClonedMaterial = new Map<string, Material>();\n\n    clone.scene.traverse((node: any) => {\n      // Materials aren't cloned when cloning meshes; geometry\n      // and materials are copied by reference. This is necessary\n      // for the same model to be used twice with different\n      // environment maps.\n      if ((node as Mesh).isMesh) {\n        const mesh = node as Mesh;\n        if (Array.isArray(mesh.material)) {\n          mesh.material = mesh.material.map(\n              (material) => this[$cloneAndPatchMaterial](\n                  material as MeshStandardMaterial,\n                  sourceUUIDToClonedMaterial));\n        } else if (mesh.material != null) {\n          mesh.material = this[$cloneAndPatchMaterial](\n              mesh.material as MeshStandardMaterial,\n              sourceUUIDToClonedMaterial);\n        }\n      }\n    });\n\n    // Cross-correlate the scene graph by relying on information in the\n    // current scene graph; without this step, relationships between the\n    // Three.js object graph and the glTF scene graph will be lost.\n    clone[$correlatedSceneGraph] =\n        CorrelatedSceneGraph.from(clone, this.correlatedSceneGraph);\n\n    return clone;\n  }\n\n  /**\n   * Creates a clone of the given material, and applies a patch to the\n   * shader program.\n   */\n  [$cloneAndPatchMaterial](\n      material: MeshStandardMaterial,\n      sourceUUIDToClonedMaterial: Map<string, Material>) {\n    // If we already cloned this material (determined by tracking the UUID of\n    // source materials that have been cloned), then return that previously\n    // cloned instance:\n    if (sourceUUIDToClonedMaterial.has(material.uuid)) {\n      return sourceUUIDToClonedMaterial.get(material.uuid)!;\n    }\n\n    const clone = material.clone() as MeshStandardMaterial;\n    if (material.map != null) {\n      clone.map = material.map.clone();\n      clone.map.needsUpdate = true;\n    }\n    if (material.normalMap != null) {\n      clone.normalMap = material.normalMap.clone();\n      clone.normalMap.needsUpdate = true;\n    }\n    if (material.emissiveMap != null) {\n      clone.emissiveMap = material.emissiveMap.clone();\n      clone.emissiveMap.needsUpdate = true;\n    }\n\n    // Clones the roughnessMap if it exists.\n    let roughnessMap: Texture|null = null;\n    if (material.roughnessMap != null) {\n      roughnessMap = material.roughnessMap.clone();\n    }\n\n    // Assigns the roughnessMap to the cloned material and generates mipmaps.\n    if (roughnessMap != null) {\n      roughnessMap.needsUpdate = true;\n      clone.roughnessMap = roughnessMap;\n\n      // Generates mipmaps from the clone of the roughnessMap.\n      const {threeRenderer, roughnessMipmapper} = Renderer.singleton;\n      // XR must be disabled while doing offscreen rendering or it will\n      // clobber the camera.\n      const {enabled} = threeRenderer.xr;\n      threeRenderer.xr.enabled = false;\n      roughnessMipmapper.generateMipmaps(clone as MeshStandardMaterial);\n      threeRenderer.xr.enabled = enabled;\n    }\n\n    // Checks if roughnessMap and metalnessMap share the same texture and\n    // either clones or assigns.\n    if (material.roughnessMap === material.metalnessMap) {\n      clone.metalnessMap = roughnessMap;\n    } else if (material.metalnessMap != null) {\n      clone.metalnessMap = material.metalnessMap.clone();\n      clone.metalnessMap.needsUpdate = true;\n    }\n\n    // Checks if roughnessMap and aoMap share the same texture and\n    // either clones or assigns.\n    if (material.roughnessMap === material.aoMap) {\n      clone.aoMap = roughnessMap;\n    } else if (material.aoMap != null) {\n      clone.aoMap = material.aoMap.clone();\n      clone.aoMap.needsUpdate = true;\n    }\n\n    // This allows us to patch three's materials, on top of patches already\n    // made, for instance GLTFLoader patches SpecularGlossiness materials.\n    // Unfortunately, three's program cache differentiates SpecGloss materials\n    // via onBeforeCompile.toString(), so these two functions do the same\n    // thing but look different in order to force a proper recompile.\n    const oldOnBeforeCompile = material.onBeforeCompile;\n    clone.onBeforeCompile = (material as any).isGLTFSpecularGlossinessMaterial ?\n        (shader: Shader) => {\n          oldOnBeforeCompile(shader, undefined as any);\n          shader.fragmentShader = shader.fragmentShader.replace(\n              '#include <alphatest_fragment>', alphaChunk);\n        } :\n        (shader: Shader) => {\n          shader.fragmentShader = shader.fragmentShader.replace(\n              '#include <alphatest_fragment>', alphaChunk);\n          oldOnBeforeCompile(shader, undefined as any);\n        };\n    // This makes shadows better for non-manifold meshes\n    clone.shadowSide = FrontSide;\n    // This improves transparent rendering and can be removed whenever\n    // https://github.com/mrdoob/three.js/pull/18235 finally lands.\n    if (clone.transparent) {\n      clone.depthWrite = false;\n    }\n    // This little hack ignores alpha for opaque materials, in order to comply\n    // with the glTF spec.\n    if (!clone.alphaTest && !clone.transparent) {\n      clone.alphaTest = -0.5;\n    }\n\n    sourceUUIDToClonedMaterial.set(material.uuid, clone);\n\n    return clone;\n  }\n}\n"]}