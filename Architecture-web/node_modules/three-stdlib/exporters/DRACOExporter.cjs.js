"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const e=()=>{};e.prototype={constructor:e,parse:function(t,o){if(!0===t.isBufferGeometry)throw new Error("DRACOExporter: The first parameter of parse() is now an instance of Mesh or Points.");if(void 0===DracoEncoderModule)throw new Error("THREE.DRACOExporter: required the draco_decoder to work.");void 0===o&&(o={decodeSpeed:5,encodeSpeed:5,encoderMethod:e.MESH_EDGEBREAKER_ENCODING,quantization:[16,8,8,8,8],exportUvs:!0,exportNormals:!0,exportColor:!1});const r=t.geometry,i=DracoEncoderModule(),n=new i.Encoder;let d,a;if(!0!==r.isBufferGeometry)throw new Error("THREE.DRACOExporter.parse(geometry, options): geometry is not a THREE.BufferGeometry instance.");if(!0===t.isMesh){d=new i.MeshBuilder,a=new i.Mesh;var s=r.getAttribute("position");if(d.AddFloatAttributeToMesh(a,i.POSITION,s.count,s.itemSize,s.array),null!==(c=r.getIndex()))d.AddFacesToMesh(a,c.count/3,c.array);else{var c=new(s.count>65535?Uint32Array:Uint16Array)(s.count);for(let e=0;e<c.length;e++)c[e]=e;d.AddFacesToMesh(a,s.count,c)}if(!0===o.exportNormals){const e=r.getAttribute("normal");void 0!==e&&d.AddFloatAttributeToMesh(a,i.NORMAL,e.count,e.itemSize,e.array)}if(!0===o.exportUvs){const e=r.getAttribute("uv");void 0!==e&&d.AddFloatAttributeToMesh(a,i.TEX_COORD,e.count,e.itemSize,e.array)}if(!0===o.exportColor)void 0!==(u=r.getAttribute("color"))&&d.AddFloatAttributeToMesh(a,i.COLOR,u.count,u.itemSize,u.array)}else{if(!0!==t.isPoints)throw new Error("DRACOExporter: Unsupported object type.");d=new i.PointCloudBuilder,a=new i.PointCloud;var u;s=r.getAttribute("position");d.AddFloatAttribute(a,i.POSITION,s.count,s.itemSize,s.array),!0===o.exportColor&&void 0!==(u=r.getAttribute("color"))&&d.AddFloatAttribute(a,i.COLOR,u.count,u.itemSize,u.array)}const E=new i.DracoInt8Array,A=void 0!==o.encodeSpeed?o.encodeSpeed:5,p=void 0!==o.decodeSpeed?o.decodeSpeed:5;if(n.SetSpeedOptions(A,p),void 0!==o.encoderMethod&&n.SetEncodingMethod(o.encoderMethod),void 0!==o.quantization)for(let e=0;e<5;e++)void 0!==o.quantization[e]&&n.SetAttributeQuantization(e,o.quantization[e]);let l;if(l=!0===t.isMesh?n.EncodeMeshToDracoBuffer(a,E):n.EncodePointCloudToDracoBuffer(a,!0,E),i.destroy(a),0===l)throw new Error("THREE.DRACOExporter: Draco encoding failed.");const f=new Int8Array(new ArrayBuffer(l));for(let e=0;e<l;e++)f[e]=E.GetValue(e);return i.destroy(E),i.destroy(n),i.destroy(d),f}},e.MESH_EDGEBREAKER_ENCODING=1,e.MESH_SEQUENTIAL_ENCODING=0,e.POINT_CLOUD=0,e.TRIANGULAR_MESH=1,e.INVALID=-1,e.POSITION=0,e.NORMAL=1,e.COLOR=2,e.TEX_COORD=3,e.GENERIC=4,exports.DRACOExporter=e;
