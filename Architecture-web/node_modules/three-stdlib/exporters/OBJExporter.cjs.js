"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var t=require("three");const e=()=>{};e.prototype={constructor:e,parse:function(e){let r="",o=0,n=0,i=0;const f=new t.Vector3,u=new t.Color,s=new t.Vector3,$=new t.Vector2;let a,m,y,l,c;const p=[];return e.traverse((e=>{!0===e.isMesh&&(e=>{let u=0,y=0,x=0;const g=e.geometry,E=new t.Matrix3;if(!0!==g.isBufferGeometry)throw new Error("THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.");const v=g.getAttribute("position"),d=g.getAttribute("normal"),B=g.getAttribute("uv"),w=g.getIndex();if(r+=`o ${e.name}\n`,e.material&&e.material.name&&(r+=`usemtl ${e.material.name}\n`),void 0!==v)for(a=0,l=v.count;a<l;a++,u++)f.x=v.getX(a),f.y=v.getY(a),f.z=v.getZ(a),f.applyMatrix4(e.matrixWorld),r+=`v ${f.x} ${f.y} ${f.z}\n`;if(void 0!==B)for(a=0,l=B.count;a<l;a++,x++)$.x=B.getX(a),$.y=B.getY(a),r+=`vt ${$.x} ${$.y}\n`;if(void 0!==d)for(E.getNormalMatrix(e.matrixWorld),a=0,l=d.count;a<l;a++,y++)s.x=d.getX(a),s.y=d.getY(a),s.z=d.getZ(a),s.applyMatrix3(E).normalize(),r+=`vn ${s.x} ${s.y} ${s.z}\n`;if(null!==w)for(a=0,l=w.count;a<l;a+=3){for(c=0;c<3;c++)m=w.getX(a+c)+1,p[c]=o+m+(d||B?`/${B?n+m:""}${d?`/${i+m}`:""}`:"");r+=`f ${p.join(" ")}\n`}else for(a=0,l=v.count;a<l;a+=3){for(c=0;c<3;c++)m=a+c+1,p[c]=o+m+(d||B?`/${B?n+m:""}${d?`/${i+m}`:""}`:"");r+=`f ${p.join(" ")}\n`}o+=u,n+=x,i+=y})(e),!0===e.isLine&&(t=>{let e=0;const n=t.geometry,i=t.type;if(!0!==n.isBufferGeometry)throw new Error("THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.");const u=n.getAttribute("position");if(r+=`o ${t.name}\n`,void 0!==u)for(a=0,l=u.count;a<l;a++,e++)f.x=u.getX(a),f.y=u.getY(a),f.z=u.getZ(a),f.applyMatrix4(t.matrixWorld),r+=`v ${f.x} ${f.y} ${f.z}\n`;if("Line"===i){for(r+="l ",m=1,l=u.count;m<=l;m++)r+=`${o+m} `;r+="\n"}if("LineSegments"===i)for(m=1,y=m+1,l=u.count;m<l;m+=2,y=m+1)r+=`l ${o+m} ${o+y}\n`;o+=e})(e),!0===e.isPoints&&(t=>{let e=0;const n=t.geometry;if(!0!==n.isBufferGeometry)throw new Error("THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.");const i=n.getAttribute("position"),s=n.getAttribute("color");if(r+=`o ${t.name}\n`,void 0!==i)for(a=0,l=i.count;a<l;a++,e++)f.fromBufferAttribute(i,a),f.applyMatrix4(t.matrixWorld),r+=`v ${f.x} ${f.y} ${f.z}`,void 0!==s&&(u.fromBufferAttribute(s,a),r+=` ${u.r} ${u.g} ${u.b}`),r+="\n";for(r+="p ",m=1,l=i.count;m<=l;m++)r+=`${o+m} `;r+="\n",o+=e})(e)})),r}},exports.OBJExporter=e;
