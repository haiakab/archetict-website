"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("three");const t=(()=>{function t(){this.pluginCallbacks=[],this.register((e=>new R(e))),this.register((e=>new F(e))),this.register((e=>new N(e)))}t.prototype={constructor:t,register:function(e){return-1===this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.push(e),this},unregister:function(e){return-1!==this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this},parse:function(e,t,s){const n=new S,r=[];for(let e=0,t=this.pluginCallbacks.length;e<t;e++)r.push(this.pluginCallbacks[e](n));n.setPlugins(r),n.write(e,t,s)}};const s=0,n=1,r=2,i=3,a=4,o=5121,l=5123,c=5126,u=5125,h=34962,p=34963,f=9728,m=9729,g=9984,d=9985,y=9986,b=9987,x=33071,w=33648,T=10497,M={};M[e.NearestFilter]=f,M[e.NearestMipmapNearestFilter]=g,M[e.NearestMipmapLinearFilter]=y,M[e.LinearFilter]=m,M[e.LinearMipmapNearestFilter]=d,M[e.LinearMipmapLinearFilter]=b,M[e.ClampToEdgeWrapping]=x,M[e.RepeatWrapping]=T,M[e.MirroredRepeatWrapping]=w;const A={scale:"scale",position:"translation",quaternion:"rotation",morphTargetInfluences:"weights"};function E(e,t){return e.length===t.length&&e.every(((e,s)=>e===t[s]))}function I(e){return 4*Math.ceil(e/4)}function v(e,t){t=t||0;const s=I(e.byteLength);if(s!==e.byteLength){const n=new Uint8Array(s);if(n.set(new Uint8Array(e)),0!==t)for(let r=e.byteLength;r<s;r++)n[r]=t;return n.buffer}return e}let L=null;function S(){this.plugins=[],this.options={},this.pending=[],this.buffers=[],this.byteOffset=0,this.buffers=[],this.nodeMap=new Map,this.skins=[],this.extensionsUsed={},this.uids=new Map,this.uid=0,this.json={asset:{version:"2.0",generator:"THREE.GLTFExporter"}},this.cache={meshes:new Map,attributes:new Map,attributesNormalized:new Map,materials:new Map,textures:new Map,images:new Map}}function R(e){this.writer=e,this.name="KHR_lights_punctual"}function F(e){this.writer=e,this.name="KHR_materials_unlit"}function N(e){this.writer=e,this.name="KHR_materials_pbrSpecularGlossiness"}return S.prototype={constructor:S,setPlugins:function(e){this.plugins=e},write:function(e,t,s){this.options=Object.assign({},{binary:!1,trs:!1,onlyVisible:!0,truncateDrawRange:!0,embedImages:!0,maxTextureSize:1/0,animations:[],includeCustomExtensions:!1},s),this.options.animations.length>0&&(this.options.trs=!0),this.processInput(e);const n=this;Promise.all(this.pending).then((()=>{const e=n.buffers,s=n.json,r=n.options,i=n.extensionsUsed,a=new Blob(e,{type:"application/octet-stream"}),o=Object.keys(i);var l;(o.length>0&&(s.extensionsUsed=o),s.buffers&&s.buffers.length>0&&(s.buffers[0].byteLength=a.size),!0===r.binary)?((l=new window.FileReader).readAsArrayBuffer(a),l.onloadend=()=>{const e=v(l.result),n=new DataView(new ArrayBuffer(8));n.setUint32(0,e.byteLength,!0),n.setUint32(4,5130562,!0);const r=v(function(e){if(void 0!==window.TextEncoder)return(new TextEncoder).encode(e).buffer;const t=new Uint8Array(new ArrayBuffer(e.length));for(let s=0,n=e.length;s<n;s++){const n=e.charCodeAt(s);t[s]=n>255?32:n}return t.buffer}(JSON.stringify(s)),32),i=new DataView(new ArrayBuffer(8));i.setUint32(0,r.byteLength,!0),i.setUint32(4,1313821514,!0);const a=new ArrayBuffer(12),o=new DataView(a);o.setUint32(0,1179937895,!0),o.setUint32(4,2,!0);const c=12+i.byteLength+r.byteLength+n.byteLength+e.byteLength;o.setUint32(8,c,!0);const u=new Blob([a,i,r,n,e],{type:"application/octet-stream"}),h=new window.FileReader;h.readAsArrayBuffer(u),h.onloadend=()=>{t(h.result)}}):s.buffers&&s.buffers.length>0?((l=new window.FileReader).readAsDataURL(a),l.onloadend=()=>{const e=l.result;s.buffers[0].uri=e,t(s)}):t(s)}))},serializeUserData:function(e,t){if(0===Object.keys(e.userData).length)return;const s=this.options,n=this.extensionsUsed;try{const r=JSON.parse(JSON.stringify(e.userData));if(s.includeCustomExtensions&&r.gltfExtensions){void 0===t.extensions&&(t.extensions={});for(let e in r.gltfExtensions)t.extensions[e]=r.gltfExtensions[e],n[e]=!0;delete r.gltfExtensions}Object.keys(r).length>0&&(t.extras=r)}catch(t){console.warn(`THREE.GLTFExporter: userData of '${e.name}' won't be serialized because of JSON.stringify error - ${t.message}`)}},getUID:function(e){return this.uids.has(e)||this.uids.set(e,this.uid++),this.uids.get(e)},isNormalizedNormalAttribute:function(t){if(this.cache.attributesNormalized.has(t))return!1;const s=new e.Vector3;for(let e=0,n=t.count;e<n;e++)if(Math.abs(s.fromBufferAttribute(t,e).length()-1)>5e-4)return!1;return!0},createNormalizedNormalAttribute:function(t){const s=this.cache;if(s.attributesNormalized.has(t))return s.attributesNormalized.get(t);const n=t.clone(),r=new e.Vector3;for(let e=0,t=n.count;e<t;e++)r.fromBufferAttribute(n,e),0===r.x&&0===r.y&&0===r.z?r.setX(1):r.normalize(),n.setXYZ(e,r.x,r.y,r.z);return s.attributesNormalized.set(t,n),n},applyTextureTransform:function(e,t){let s=!1;const n={};0===t.offset.x&&0===t.offset.y||(n.offset=t.offset.toArray(),s=!0),0!==t.rotation&&(n.rotation=t.rotation,s=!0),1===t.repeat.x&&1===t.repeat.y||(n.scale=t.repeat.toArray(),s=!0),s&&(e.extensions=e.extensions||{},e.extensions.KHR_texture_transform=n,this.extensionsUsed.KHR_texture_transform=!0)},processBuffer:function(e){const t=this.json,s=this.buffers;return t.buffers||(t.buffers=[{byteLength:0}]),s.push(e),0},processBufferView:function(e,t,s,n,r){const i=this.json;let a;i.bufferViews||(i.bufferViews=[]),a=t===o?1:t===l?2:4;const p=I(n*e.itemSize*a),f=new DataView(new ArrayBuffer(p));let m=0;for(let r=s;r<s+n;r++)for(let s=0;s<e.itemSize;s++){let n;e.itemSize>4?n=e.array[r*e.itemSize+s]:0===s?n=e.getX(r):1===s?n=e.getY(r):2===s?n=e.getZ(r):3===s&&(n=e.getW(r)),t===c?f.setFloat32(m,n,!0):t===u?f.setUint32(m,n,!0):t===l?f.setUint16(m,n,!0):t===o&&f.setUint8(m,n),m+=a}const g={buffer:this.processBuffer(f.buffer),byteOffset:this.byteOffset,byteLength:p};void 0!==r&&(g.target=r),r===h&&(g.byteStride=e.itemSize*a),this.byteOffset+=p,i.bufferViews.push(g);return{id:i.bufferViews.length-1,byteLength:0}},processBufferViewImage:function(e){const t=this,s=t.json;return s.bufferViews||(s.bufferViews=[]),new Promise((n=>{const r=new window.FileReader;r.readAsArrayBuffer(e),r.onloadend=()=>{const e=v(r.result),i={buffer:t.processBuffer(e),byteOffset:t.byteOffset,byteLength:e.byteLength};t.byteOffset+=e.byteLength,n(s.bufferViews.push(i)-1)}}))},processAccessor:function(e,t,s,n){const r=this.options,i=this.json;let a;if(e.array.constructor===Float32Array)a=c;else if(e.array.constructor===Uint32Array)a=u;else if(e.array.constructor===Uint16Array)a=l;else{if(e.array.constructor!==Uint8Array)throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type.");a=o}if(void 0===s&&(s=0),void 0===n&&(n=e.count),r.truncateDrawRange&&void 0!==t&&null===t.index){const r=s+n,i=t.drawRange.count===1/0?e.count:t.drawRange.start+t.drawRange.count;s=Math.max(s,t.drawRange.start),(n=Math.min(r,i)-s)<0&&(n=0)}if(0===n)return null;const f=function(e,t,s){const n={min:new Array(e.itemSize).fill(Number.POSITIVE_INFINITY),max:new Array(e.itemSize).fill(Number.NEGATIVE_INFINITY)};for(let r=t;r<t+s;r++)for(let t=0;t<e.itemSize;t++){let s;e.itemSize>4?s=e.array[r*e.itemSize+t]:0===t?s=e.getX(r):1===t?s=e.getY(r):2===t?s=e.getZ(r):3===t&&(s=e.getW(r)),n.min[t]=Math.min(n.min[t],s),n.max[t]=Math.max(n.max[t],s)}return n}(e,s,n);let m;void 0!==t&&(m=e===t.index?p:h);const g=this.processBufferView(e,a,s,n,m),d={bufferView:g.id,byteOffset:g.byteOffset,componentType:a,count:n,max:f.max,min:f.min,type:{1:"SCALAR",2:"VEC2",3:"VEC3",4:"VEC4",16:"MAT4"}[e.itemSize]};return!0===e.normalized&&(d.normalized=!0),i.accessors||(i.accessors=[]),i.accessors.push(d)-1},processImage:function(t,s,n){const r=this,i=r.cache,a=r.json,o=r.options,l=r.pending;i.images.has(t)||i.images.set(t,{});const c=i.images.get(t),u=s===e.RGBAFormat?"image/png":"image/jpeg",h=`${u}:flipY/${n.toString()}`;if(void 0!==c[h])return c[h];a.images||(a.images=[]);const p={mimeType:u};if(o.embedImages){const i=L=L||document.createElement("canvas");i.width=Math.min(t.width,o.maxTextureSize),i.height=Math.min(t.height,o.maxTextureSize);const a=i.getContext("2d");if(!0===n&&(a.translate(0,i.height),a.scale(1,-1)),"undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&t instanceof OffscreenCanvas||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap)a.drawImage(t,0,0,i.width,i.height);else{s!==e.RGBAFormat&&s!==e.RGBFormat&&console.error("GLTFExporter: Only RGB and RGBA formats are supported."),(t.width>o.maxTextureSize||t.height>o.maxTextureSize)&&console.warn("GLTFExporter: Image size is bigger than maxTextureSize",t);let n=t.data;if(s===e.RGBFormat){n=new Uint8ClampedArray(t.height*t.width*4);for(let e=0,s=0;e<n.length;e+=4,s+=3)n[e+0]=t.data[s+0],n[e+1]=t.data[s+1],n[e+2]=t.data[s+2],n[e+3]=255}a.putImageData(new ImageData(n,t.width,t.height),0,0)}!0===o.binary?l.push(new Promise((e=>{i.toBlob((t=>{r.processBufferViewImage(t).then((t=>{p.bufferView=t,e()}))}),u)}))):p.uri=i.toDataURL(u)}else p.uri=t.src;const f=a.images.push(p)-1;return c[h]=f,f},processSampler:function(e){const t=this.json;t.samplers||(t.samplers=[]);const s={magFilter:M[e.magFilter],minFilter:M[e.minFilter],wrapS:M[e.wrapS],wrapT:M[e.wrapT]};return t.samplers.push(s)-1},processTexture:function(e){const t=this.cache,s=this.json;if(t.textures.has(e))return t.textures.get(e);s.textures||(s.textures=[]);const n={sampler:this.processSampler(e),source:this.processImage(e.image,e.format,e.flipY)};e.name&&(n.name=e.name),this._invokeAll((t=>{t.writeTexture&&t.writeTexture(e,n)}));const r=s.textures.push(n)-1;return t.textures.set(e,r),r},processMaterial:function(t){const s=this.cache,n=this.json;if(s.materials.has(t))return s.materials.get(t);if(t.isShaderMaterial)return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."),null;n.materials||(n.materials=[]);const r={pbrMetallicRoughness:{}};!0!==t.isMeshStandardMaterial&&!0!==t.isMeshBasicMaterial&&console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");const i=t.color.toArray().concat([t.opacity]);if(E(i,[1,1,1,1])||(r.pbrMetallicRoughness.baseColorFactor=i),t.isMeshStandardMaterial?(r.pbrMetallicRoughness.metallicFactor=t.metalness,r.pbrMetallicRoughness.roughnessFactor=t.roughness):(r.pbrMetallicRoughness.metallicFactor=.5,r.pbrMetallicRoughness.roughnessFactor=.5),t.metalnessMap||t.roughnessMap)if(t.metalnessMap===t.roughnessMap){const e={index:this.processTexture(t.metalnessMap)};this.applyTextureTransform(e,t.metalnessMap),r.pbrMetallicRoughness.metallicRoughnessTexture=e}else console.warn("THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.");if(t.map){const e={index:this.processTexture(t.map)};this.applyTextureTransform(e,t.map),r.pbrMetallicRoughness.baseColorTexture=e}if(t.emissive){const e=t.emissive.clone().multiplyScalar(t.emissiveIntensity).toArray();if(E(e,[0,0,0])||(r.emissiveFactor=e),t.emissiveMap){const e={index:this.processTexture(t.emissiveMap)};this.applyTextureTransform(e,t.emissiveMap),r.emissiveTexture=e}}if(t.normalMap){const e={index:this.processTexture(t.normalMap)};t.normalScale&&-1!==t.normalScale.x&&(t.normalScale.x!==t.normalScale.y&&console.warn("THREE.GLTFExporter: Normal scale components are different, ignoring Y and exporting X."),e.scale=t.normalScale.x),this.applyTextureTransform(e,t.normalMap),r.normalTexture=e}if(t.aoMap){const e={index:this.processTexture(t.aoMap),texCoord:1};1!==t.aoMapIntensity&&(e.strength=t.aoMapIntensity),this.applyTextureTransform(e,t.aoMap),r.occlusionTexture=e}t.transparent?r.alphaMode="BLEND":t.alphaTest>0&&(r.alphaMode="MASK",r.alphaCutoff=t.alphaTest),t.side===e.DoubleSide&&(r.doubleSided=!0),""!==t.name&&(r.name=t.name),this.serializeUserData(t,r),this._invokeAll((e=>{e.writeMaterial&&e.writeMaterial(t,r)}));const a=n.materials.push(r)-1;return s.materials.set(t,a),a},processMesh:function(t){const o=this.cache,l=this.json,c=[t.geometry.uuid];if(Array.isArray(t.material))for(let e=0,s=t.material.length;e<s;e++)c.push(t.material[e].uuid);else c.push(t.material.uuid);const u=c.join(":");if(o.meshes.has(u))return o.meshes.get(u);const h=t.geometry;let p;if(p=t.isLineSegments?n:t.isLineLoop?r:t.isLine?i:t.isPoints?s:t.material.wireframe?n:a,!0!==h.isBufferGeometry)throw new Error("THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.");const f={},m={},g=[],d=[],y={uv:"TEXCOORD_0",uv2:"TEXCOORD_1",color:"COLOR_0",skinWeight:"WEIGHTS_0",skinIndex:"JOINTS_0"},b=h.getAttribute("normal");void 0===b||this.isNormalizedNormalAttribute(b)||(console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."),h.setAttribute("normal",this.createNormalizedNormalAttribute(b)));let x=null;for(let t in h.attributes){if("morph"===t.substr(0,5))continue;var w=h.attributes[t];t=y[t]||t.toUpperCase();if(/^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(t)||(t=`_${t}`),o.attributes.has(this.getUID(w))){m[t]=o.attributes.get(this.getUID(w));continue}x=null;const s=w.array;"JOINTS_0"!==t||s instanceof Uint16Array||s instanceof Uint8Array||(console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'),x=new e.BufferAttribute(new Uint16Array(s),w.itemSize,w.normalized));const n=this.processAccessor(x||w,h);null!==n&&(m[t]=n,o.attributes.set(this.getUID(w),n))}if(void 0!==b&&h.setAttribute("normal",b),0===Object.keys(m).length)return null;if(void 0!==t.morphTargetInfluences&&t.morphTargetInfluences.length>0){const e=[],s=[],n={};if(void 0!==t.morphTargetDictionary)for(let e in t.morphTargetDictionary)n[t.morphTargetDictionary[e]]=e;for(let r=0;r<t.morphTargetInfluences.length;++r){const i={};let a=!1;for(let e in h.morphAttributes){if("position"!==e&&"normal"!==e){a||(console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."),a=!0);continue}w=h.morphAttributes[e][r];const t=e.toUpperCase(),s=h.attributes[e];if(o.attributes.has(this.getUID(w))){i[t]=o.attributes.get(this.getUID(w));continue}const n=w.clone();if(!h.morphTargetsRelative)for(let e=0,t=w.count;e<t;e++)n.setXYZ(e,w.getX(e)-s.getX(e),w.getY(e)-s.getY(e),w.getZ(e)-s.getZ(e));i[t]=this.processAccessor(n,h),o.attributes.set(this.getUID(s),i[t])}d.push(i),e.push(t.morphTargetInfluences[r]),void 0!==t.morphTargetDictionary&&s.push(n[r])}f.weights=e,s.length>0&&(f.extras={},f.extras.targetNames=s)}const T=Array.isArray(t.material);if(T&&0===h.groups.length)return null;const M=T?t.material:[t.material],A=T?h.groups:[{materialIndex:0,start:void 0,count:void 0}];for(let e=0,t=A.length;e<t;e++){const t={mode:p,attributes:m};if(this.serializeUserData(h,t),d.length>0&&(t.targets=d),null!==h.index){let s=this.getUID(h.index);void 0===A[e].start&&void 0===A[e].count||(s+=`:${A[e].start}:${A[e].count}`),o.attributes.has(s)?t.indices=o.attributes.get(s):(t.indices=this.processAccessor(h.index,h,A[e].start,A[e].count),o.attributes.set(s,t.indices)),null===t.indices&&delete t.indices}const s=this.processMaterial(M[A[e].materialIndex]);null!==s&&(t.material=s),g.push(t)}f.primitives=g,l.meshes||(l.meshes=[]),this._invokeAll((e=>{e.writeMesh&&e.writeMesh(t,f)}));const E=l.meshes.push(f)-1;return o.meshes.set(u,E),E},processCamera:function(t){const s=this.json;s.cameras||(s.cameras=[]);const n=t.isOrthographicCamera,r={type:n?"orthographic":"perspective"};return n?r.orthographic={xmag:2*t.right,ymag:2*t.top,zfar:t.far<=0?.001:t.far,znear:t.near<0?0:t.near}:r.perspective={aspectRatio:t.aspect,yfov:e.MathUtils.degToRad(t.fov),zfar:t.far<=0?.001:t.far,znear:t.near<0?0:t.near},""!==t.name&&(r.name=t.type),s.cameras.push(r)-1},processAnimation:function(s,n){const r=this.json,i=this.nodeMap;r.animations||(r.animations=[]);const a=(s=t.Utils.mergeMorphTargetTracks(s.clone(),n)).tracks,o=[],l=[];for(let t=0;t<a.length;++t){const s=a[t],r=e.PropertyBinding.parseTrackName(s.name);let c=e.PropertyBinding.findNode(n,r.nodeName);const u=A[r.propertyName];if("bones"===r.objectName&&(c=!0===c.isSkinnedMesh?c.skeleton.getBoneByName(r.objectIndex):void 0),!c||!u)return console.warn('THREE.GLTFExporter: Could not export animation track "%s".',s.name),null;const h=1;let p,f=s.values.length/s.times.length;u===A.morphTargetInfluences&&(f/=c.morphTargetInfluences.length),!0===s.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline?(p="CUBICSPLINE",f/=3):p=s.getInterpolation()===e.InterpolateDiscrete?"STEP":"LINEAR",l.push({input:this.processAccessor(new e.BufferAttribute(s.times,h)),output:this.processAccessor(new e.BufferAttribute(s.values,f)),interpolation:p}),o.push({sampler:l.length-1,target:{node:i.get(c),path:u}})}return r.animations.push({name:s.name||`clip_${r.animations.length}`,samplers:l,channels:o}),r.animations.length-1},processSkin:function(t){const s=this.json,n=this.nodeMap,r=s.nodes[n.get(t)],i=t.skeleton;if(void 0===i)return null;const a=t.skeleton.bones[0];if(void 0===a)return null;const o=[],l=new Float32Array(16*i.bones.length),c=new e.Matrix4;for(let e=0;e<i.bones.length;++e)o.push(n.get(i.bones[e])),c.copy(i.boneInverses[e]),c.multiply(t.bindMatrix).toArray(l,16*e);void 0===s.skins&&(s.skins=[]),s.skins.push({inverseBindMatrices:this.processAccessor(new e.BufferAttribute(l,16)),joints:o,skeleton:n.get(a)});return r.skin=s.skins.length-1},processNode:function(e){const t=this.json,s=this.options,n=this.nodeMap;t.nodes||(t.nodes=[]);const r={};if(s.trs){const t=e.quaternion.toArray(),s=e.position.toArray(),n=e.scale.toArray();E(t,[0,0,0,1])||(r.rotation=t),E(s,[0,0,0])||(r.translation=s),E(n,[1,1,1])||(r.scale=n)}else e.matrixAutoUpdate&&e.updateMatrix(),!1===E(e.matrix.elements,[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])&&(r.matrix=e.matrix.elements);if(""!==e.name&&(r.name=String(e.name)),this.serializeUserData(e,r),e.isMesh||e.isLine||e.isPoints){const t=this.processMesh(e);null!==t&&(r.mesh=t)}else e.isCamera&&(r.camera=this.processCamera(e));if(e.isSkinnedMesh&&this.skins.push(e),e.children.length>0){const t=[];for(let n=0,r=e.children.length;n<r;n++){const r=e.children[n];if(r.visible||!1===s.onlyVisible)null!==(i=this.processNode(r))&&t.push(i)}t.length>0&&(r.children=t)}this._invokeAll((t=>{t.writeNode&&t.writeNode(e,r)}));var i=t.nodes.push(r)-1;return n.set(e,i),i},processScene:function(e){const t=this.json,s=this.options;t.scenes||(t.scenes=[],t.scene=0);const n={};""!==e.name&&(n.name=e.name),t.scenes.push(n);const r=[];for(let t=0,n=e.children.length;t<n;t++){const n=e.children[t];if(n.visible||!1===s.onlyVisible){const e=this.processNode(n);null!==e&&r.push(e)}}r.length>0&&(n.nodes=r),this.serializeUserData(e,n)},processObjects:function(t){const s=new e.Scene;s.name="AuxScene";for(let e=0;e<t.length;e++)s.children.push(t[e]);this.processScene(s)},processInput:function(t){const s=this.options;t=t instanceof Array?t:[t],this._invokeAll((e=>{e.beforeParse&&e.beforeParse(t)}));const n=[];for(let s=0;s<t.length;s++)t[s]instanceof e.Scene?this.processScene(t[s]):n.push(t[s]);n.length>0&&this.processObjects(n);for(let e=0;e<this.skins.length;++e)this.processSkin(this.skins[e]);for(let e=0;e<s.animations.length;++e)this.processAnimation(s.animations[e],t[0]);this._invokeAll((e=>{e.afterParse&&e.afterParse(t)}))},_invokeAll:function(e){for(let t=0,s=this.plugins.length;t<s;t++)e(this.plugins[t])}},R.prototype={constructor:R,writeNode:function(e,t){if(!e.isLight)return;if(!e.isDirectionalLight&&!e.isPointLight&&!e.isSpotLight)return void console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.",e);const s=this.writer,n=s.json,r=s.extensionsUsed,i={};e.name&&(i.name=e.name),i.color=e.color.toArray(),i.intensity=e.intensity,e.isDirectionalLight?i.type="directional":e.isPointLight?(i.type="point",e.distance>0&&(i.range=e.distance)):e.isSpotLight&&(i.type="spot",e.distance>0&&(i.range=e.distance),i.spot={},i.spot.innerConeAngle=(e.penumbra-1)*e.angle*-1,i.spot.outerConeAngle=e.angle),void 0!==e.decay&&2!==e.decay&&console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."),!e.target||e.target.parent===e&&0===e.target.position.x&&0===e.target.position.y&&-1===e.target.position.z||console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."),r[this.name]||(n.extensions=n.extensions||{},n.extensions[this.name]={lights:[]},r[this.name]=!0);const a=n.extensions[this.name].lights;a.push(i),t.extensions=t.extensions||{},t.extensions[this.name]={light:a.length-1}}},F.prototype={constructor:F,writeMaterial:function(e,t){if(!e.isMeshBasicMaterial)return;const s=this.writer.extensionsUsed;t.extensions=t.extensions||{},t.extensions[this.name]={},s[this.name]=!0,t.pbrMetallicRoughness.metallicFactor=0,t.pbrMetallicRoughness.roughnessFactor=.9}},N.prototype={constructor:N,writeMaterial:function(e,t){if(!e.isGLTFSpecularGlossinessMaterial)return;const s=this.writer,n=s.extensionsUsed,r={};t.pbrMetallicRoughness.baseColorFactor&&(r.diffuseFactor=t.pbrMetallicRoughness.baseColorFactor);const i=[1,1,1];if(e.specular.toArray(i,0),r.specularFactor=i,r.glossinessFactor=e.glossiness,t.pbrMetallicRoughness.baseColorTexture&&(r.diffuseTexture=t.pbrMetallicRoughness.baseColorTexture),e.specularMap){const t={index:s.processTexture(e.specularMap)};s.applyTextureTransform(t,e.specularMap),r.specularGlossinessTexture=t}t.extensions=t.extensions||{},t.extensions[this.name]=r,n[this.name]=!0}},t.Utils={insertKeyframe:function(e,t){const s=.001,n=e.getValueSize(),r=new e.TimeBufferType(e.times.length+1),i=new e.ValueBufferType(e.values.length+n),a=e.createInterpolant(new e.ValueBufferType(n));let o;if(0===e.times.length){r[0]=t;for(let e=0;e<n;e++)i[e]=0;o=0}else if(t<e.times[0]){if(Math.abs(e.times[0]-t)<s)return 0;r[0]=t,r.set(e.times,1),i.set(a.evaluate(t),0),i.set(e.values,n),o=0}else if(t>e.times[e.times.length-1]){if(Math.abs(e.times[e.times.length-1]-t)<s)return e.times.length-1;r[r.length-1]=t,r.set(e.times,0),i.set(e.values,0),i.set(a.evaluate(t),e.values.length),o=r.length-1}else for(let l=0;l<e.times.length;l++){if(Math.abs(e.times[l]-t)<s)return l;if(e.times[l]<t&&e.times[l+1]>t){r.set(e.times.slice(0,l+1),0),r[l+1]=t,r.set(e.times.slice(l+1),l+2),i.set(e.values.slice(0,(l+1)*n),0),i.set(a.evaluate(t),(l+1)*n),i.set(e.values.slice((l+1)*n),(l+2)*n),o=l+1;break}}return e.times=r,e.values=i,o},mergeMorphTargetTracks:function(t,s){const n=[],r={},i=t.tracks;for(let t=0;t<i.length;++t){let a=i[t];const o=e.PropertyBinding.parseTrackName(a.name),l=e.PropertyBinding.findNode(s,o.nodeName);if("morphTargetInfluences"!==o.propertyName||void 0===o.propertyIndex){n.push(a);continue}if(a.createInterpolant!==a.InterpolantFactoryMethodDiscrete&&a.createInterpolant!==a.InterpolantFactoryMethodLinear){if(a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."),a=a.clone(),a.setInterpolation(e.InterpolateLinear)}const c=l.morphTargetInfluences.length,u=l.morphTargetDictionary[o.propertyIndex];if(void 0===u)throw new Error(`THREE.GLTFExporter: Morph target name not found: ${o.propertyIndex}`);let h;if(void 0===r[l.uuid]){h=a.clone();const e=new h.ValueBufferType(c*h.times.length);for(let t=0;t<h.times.length;t++)e[t*c+u]=h.values[t];h.name=`${o.nodeName||""}.morphTargetInfluences`,h.values=e,r[l.uuid]=h,n.push(h);continue}const p=a.createInterpolant(new a.ValueBufferType(1));h=r[l.uuid];for(let e=0;e<h.times.length;e++)h.values[e*c+u]=p.evaluate(h.times[e]);for(let e=0;e<a.times.length;e++){const t=this.insertKeyframe(h,a.times[e]);h.values[t*c+u]=a.values[e]}}return t.tracks=n,t}},t})();exports.GLTFExporter=t;
