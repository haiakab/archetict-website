"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var t=require("three");const e=()=>{};e.prototype={constructor:e,parse:function(e,n,r){function o(t){e.traverse((e=>{if(!0===e.isMesh){const n=e,r=n.geometry;if(!0!==r.isBufferGeometry)throw new Error("THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.");!0===r.hasAttribute("position")&&t(n,r)}}))}n&&"object"==typeof n&&(console.warn('THREE.PLYExporter: The options parameter is now the third argument to the "parse" function. See the documentation for the new API.'),r=n,n=void 0);const i=(r=Object.assign({binary:!1,excludeAttributes:[],littleEndian:!1},r)).excludeAttributes;let l=!1,a=!1,s=!1,u=0,f=0;e.traverse((t=>{if(!0===t.isMesh){const e=t.geometry;if(!0!==e.isBufferGeometry)throw new Error("THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.");const n=e.getAttribute("position"),r=e.getAttribute("normal"),o=e.getAttribute("uv"),i=e.getAttribute("color"),d=e.getIndex();if(void 0===n)return;u+=n.count,f+=d?d.count/3:n.count/3,void 0!==r&&(l=!0),void 0!==o&&(s=!0),void 0!==i&&(a=!0)}}));const d=-1===i.indexOf("index");if(l=l&&-1===i.indexOf("normal"),a=a&&-1===i.indexOf("color"),s=s&&-1===i.indexOf("uv"),d&&f!==Math.floor(f))return console.error("PLYExporter: Failed to generate a valid PLY file with triangle indices because the number of indices is not divisible by 3."),null;let g=`ply\nformat ${r.binary?r.littleEndian?"binary_little_endian":"binary_big_endian":"ascii"} 1.0\nelement vertex ${u}\nproperty float x\nproperty float y\nproperty float z\n`;!0===l&&(g+="property float nx\nproperty float ny\nproperty float nz\n"),!0===s&&(g+="property float s\nproperty float t\n"),!0===a&&(g+="property uchar red\nproperty uchar green\nproperty uchar blue\n"),!0===d&&(g+=`element face ${f}\nproperty list uchar int vertex_index\n`),g+="end_header\n";const p=new t.Vector3,c=new t.Matrix3;let y=null;if(!0===r.binary){const t=(new TextEncoder).encode(g),e=u*(12+(l?12:0)+(a?3:0)+(s?8:0)),n=d?13*f:0,i=new DataView(new ArrayBuffer(t.length+e+n));new Uint8Array(i.buffer).set(t,0);let E=t.length,b=t.length+e;var x=0;o(((t,e)=>{const n=e.getAttribute("position"),o=e.getAttribute("normal"),u=e.getAttribute("uv"),f=e.getAttribute("color"),g=e.getIndex();c.getNormalMatrix(t.matrixWorld);for(let e=0,d=n.count;e<d;e++)p.x=n.getX(e),p.y=n.getY(e),p.z=n.getZ(e),p.applyMatrix4(t.matrixWorld),i.setFloat32(E,p.x,r.littleEndian),E+=4,i.setFloat32(E,p.y,r.littleEndian),E+=4,i.setFloat32(E,p.z,r.littleEndian),E+=4,!0===l&&(null!=o?(p.x=o.getX(e),p.y=o.getY(e),p.z=o.getZ(e),p.applyMatrix3(c).normalize(),i.setFloat32(E,p.x,r.littleEndian),E+=4,i.setFloat32(E,p.y,r.littleEndian),E+=4,i.setFloat32(E,p.z,r.littleEndian),E+=4):(i.setFloat32(E,0,r.littleEndian),E+=4,i.setFloat32(E,0,r.littleEndian),E+=4,i.setFloat32(E,0,r.littleEndian),E+=4)),!0===s&&(null!=u?(i.setFloat32(E,u.getX(e),r.littleEndian),E+=4,i.setFloat32(E,u.getY(e),r.littleEndian),E+=4):!1!==s&&(i.setFloat32(E,0,r.littleEndian),E+=4,i.setFloat32(E,0,r.littleEndian),E+=4)),!0===a&&(null!=f?(i.setUint8(E,Math.floor(255*f.getX(e))),E+=1,i.setUint8(E,Math.floor(255*f.getY(e))),E+=1,i.setUint8(E,Math.floor(255*f.getZ(e))),E+=1):(i.setUint8(E,255),E+=1,i.setUint8(E,255),E+=1,i.setUint8(E,255),E+=1));if(!0===d)if(null!==g)for(let t=0,e=g.count;t<e;t+=3)i.setUint8(b,3),b+=1,i.setUint32(b,g.getX(t+0)+x,r.littleEndian),b+=4,i.setUint32(b,g.getX(t+1)+x,r.littleEndian),b+=4,i.setUint32(b,g.getX(t+2)+x,r.littleEndian),b+=4;else for(let t=0,e=n.count;t<e;t+=3)i.setUint8(b,3),b+=1,i.setUint32(b,x+t,r.littleEndian),b+=4,i.setUint32(b,x+t+1,r.littleEndian),b+=4,i.setUint32(b,x+t+2,r.littleEndian),b+=4;x+=n.count})),y=i.buffer}else{x=0;let t="",e="";o(((n,r)=>{const o=r.getAttribute("position"),i=r.getAttribute("normal"),u=r.getAttribute("uv"),g=r.getAttribute("color"),y=r.getIndex();c.getNormalMatrix(n.matrixWorld);for(let e=0,r=o.count;e<r;e++){p.x=o.getX(e),p.y=o.getY(e),p.z=o.getZ(e),p.applyMatrix4(n.matrixWorld);let r=`${p.x} ${p.y} ${p.z}`;!0===l&&(null!=i?(p.x=i.getX(e),p.y=i.getY(e),p.z=i.getZ(e),p.applyMatrix3(c).normalize(),r+=` ${p.x} ${p.y} ${p.z}`):r+=" 0 0 0"),!0===s&&(null!=u?r+=` ${u.getX(e)} ${u.getY(e)}`:!1!==s&&(r+=" 0 0")),!0===a&&(r+=null!=g?` ${Math.floor(255*g.getX(e))} ${Math.floor(255*g.getY(e))} ${Math.floor(255*g.getZ(e))}`:" 255 255 255"),t+=`${r}\n`}if(!0===d){if(null!==y)for(let t=0,n=y.count;t<n;t+=3)e+=`3 ${y.getX(t+0)+x}`,e+=` ${y.getX(t+1)+x}`,e+=` ${y.getX(t+2)+x}\n`;else for(let t=0,n=o.count;t<n;t+=3)e+=`3 ${x+t} ${x+t+1} ${x+t+2}\n`;f+=y?y.count/3:o.count/3}x+=o.count})),y=`${g}${t}${d?`${e}\n`:"\n"}`}return"function"==typeof n&&requestAnimationFrame((()=>n(y))),y}},exports.PLYExporter=e;
