"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("three");const t=()=>{};t.prototype={constructor:t,parse:function(t,r,a){a=a||{},""!==(a=Object.assign({version:"1.4.1",author:null,textureDirectory:""},a)).textureDirectory&&(a.textureDirectory=`${a.textureDirectory}/`.replace(/\\/g,"/").replace(/\/+/g,"/"));const n=a.version;if("1.4.1"!==n&&"1.5.0"!==n)return console.warn(`ColladaExporter : Version ${n} not supported for export. Only 1.4.1 and 1.5.0.`),null;let i,s;function o(e,t){i=i||document.createElement("canvas"),s=s||i.getContext("2d"),i.width=e.width,i.height=e.height,s.drawImage(e,0,0);return function(e){const t=atob(e),r=new Uint8Array(t.length);for(let e=0,a=r.length;e<a;e++)r[e]=t.charCodeAt(e);return r}(i.toDataURL(`image/${t}`,1).replace(/^data:image\/(png|jpg);base64,/,""))}const c=["getX","getY","getZ","getW"];function l(e){if(e.isInterleavedBufferAttribute){const t=new e.array.constructor(e.count*e.itemSize),r=e.itemSize;for(let a=0,n=e.count;a<n;a++)for(let n=0;n<r;n++)t[a*r+n]=e[c[n]](a);return t}return e.array}function u(e,t,r,a){const n=l(e);return`${`<source id="${t}"><float_array id="${t}-array" count="${n.length}">`+n.join(" ")}</float_array><technique_common><accessor source="#${t}-array" count="${Math.floor(n.length/e.itemSize)}" stride="${e.itemSize}">${r.map((e=>`<param name="${e}" type="${a}" />`)).join("")}</accessor></technique_common></source>`}let m;function p(e){let t=d.get(e);if(null==t){t=`image-${h.length+1}`;const r="png",i=e.name||t;let s=`<image id="${t}" name="${i}">`;s+="1.5.0"===n?`<init_from><ref>${a.textureDirectory}${i}.${r}</ref></init_from>`:`<init_from>${a.textureDirectory}${i}.${r}</init_from>`,s+="</image>",h.push(s),d.set(e,t),g.push({directory:a.textureDirectory,name:i,ext:r,data:o(e.image,r),original:e})}return t}var f=new WeakMap,$=new WeakMap,d=new WeakMap,g=[],h=[],y=[],_=[],x=[];const b=function t(r){let a=`<node name="${r.name}">`;if(a+=function(t){return t.updateMatrix(),m=m||new e.Matrix4,m.copy(t.matrix),m.transpose(),`<matrix>${m.toArray().join(" ")}</matrix>`}(r),!0===r.isMesh&&null!==r.geometry){const t=function(e){let t=f.get(e);if(!t){const s=e;if(!0!==s.isBufferGeometry)throw new Error("THREE.ColladaExporter: Geometry is not of type THREE.BufferGeometry.");const o=`Mesh${y.length+1}`,c=s.index?s.index.count*s.index.itemSize:s.attributes.position.count,m=null!=s.groups&&0!==s.groups.length?s.groups:[{start:0,count:c,materialIndex:0}];let p=`<geometry id="${o}"${e.name?` name="${e.name}"`:""}><mesh>`;const $=`${o}-position`,d=`${o}-vertices`;p+=u(s.attributes.position,$,["X","Y","Z"],"float"),p+=`<vertices id="${d}"><input semantic="POSITION" source="#${$}" /></vertices>`;let g=`<input semantic="VERTEX" source="#${d}" offset="0" />`;if("normal"in s.attributes){const e=`${o}-normal`;p+=u(s.attributes.normal,e,["X","Y","Z"],"float"),g+=`<input semantic="NORMAL" source="#${e}" offset="0" />`}if("uv"in s.attributes){var r=`${o}-texcoord`;p+=u(s.attributes.uv,r,["S","T"],"float"),g+=`<input semantic="TEXCOORD" source="#${r}" offset="0" set="0" />`}if("uv2"in s.attributes&&(r=`${o}-texcoord2`,p+=u(s.attributes.uv2,r,["S","T"],"float"),g+=`<input semantic="TEXCOORD" source="#${r}" offset="0" set="1" />`),"color"in s.attributes){const e=`${o}-color`;p+=u(s.attributes.color,e,["X","Y","Z"],"uint8"),g+=`<input semantic="COLOR" source="#${e}" offset="0" />`}let h=null;if(s.index)h=l(s.index);else{h=new Array(c);for(let e=0,t=h.length;e<t;e++)h[e]=e}for(let e=0,t=m.length;e<t;e++){const t=m[e],r=(a=h,n=t.start,i=t.count,Array.isArray(a)?a.slice(n,n+i):new a.constructor(a.buffer,n*a.BYTES_PER_ELEMENT,i)),s=r.length/3;p+=`<triangles material="MESH_MATERIAL_${t.materialIndex}" count="${s}">`,p+=g,p+=`<p>${r.join(" ")}</p>`,p+="</triangles>"}p+="</mesh></geometry>",y.push(p),t={meshid:o,bufferGeometry:s},f.set(e,t)}var a,n,i;return t}(r.geometry),n=t.meshid,i=t.bufferGeometry;let s=null,o=[];const c=r.material||new e.MeshBasicMaterial,m=Array.isArray(c)?c:[c];o=i.groups.length>m.length?new Array(i.groups.length):new Array(m.length),s=o.fill().map(((t,r)=>function(t){let r=$.get(t);if(null==r){r=`Mat${_.length+1}`;let a="phong";!0===t.isMeshLambertMaterial?a="lambert":!0===t.isMeshBasicMaterial&&(a="constant",null!==t.map&&console.warn("ColladaExporter: Texture maps not supported with MeshBasicMaterial."));const n=t.emissive?t.emissive:new e.Color(0,0,0),i=t.color?t.color:new e.Color(0,0,0),s=t.specular?t.specular:new e.Color(1,1,1),o=t.shininess||0,c=t.reflectivity||0;let l="";!0===t.transparent&&(l+=`<transparent>${t.map?'<texture texture="diffuse-sampler"></texture>':"<float>1</float>"}</transparent>`,t.opacity<1&&(l+=`<transparency><float>${t.opacity}</float></transparency>`));const u=`<technique sid="common"><${a}><emission>${t.emissiveMap?'<texture texture="emissive-sampler" texcoord="TEXCOORD" />':`<color sid="emission">${n.r} ${n.g} ${n.b} 1</color>`}</emission>${"constant"!==a?`<diffuse>${t.map?'<texture texture="diffuse-sampler" texcoord="TEXCOORD" />':`<color sid="diffuse">${i.r} ${i.g} ${i.b} 1</color>`}</diffuse>`:""}${"constant"!==a?`<bump>${t.normalMap?'<texture texture="bump-sampler" texcoord="TEXCOORD" />':""}</bump>`:""}${"phong"===a?`<specular><color sid="specular">${s.r} ${s.g} ${s.b} 1</color></specular><shininess>${t.specularMap?'<texture texture="specular-sampler" texcoord="TEXCOORD" />':`<float sid="shininess">${o}</float>`}</shininess>`:""}<reflective><color>${i.r} ${i.g} ${i.b} 1</color></reflective><reflectivity><float>${c}</float></reflectivity>${l}</${a}></technique>`,m=`<effect id="${r}-effect"><profile_COMMON>${t.map?`<newparam sid="diffuse-surface"><surface type="2D"><init_from>${p(t.map)}</init_from></surface></newparam><newparam sid="diffuse-sampler"><sampler2D><source>diffuse-surface</source></sampler2D></newparam>`:""}${t.specularMap?`<newparam sid="specular-surface"><surface type="2D"><init_from>${p(t.specularMap)}</init_from></surface></newparam><newparam sid="specular-sampler"><sampler2D><source>specular-surface</source></sampler2D></newparam>`:""}${t.emissiveMap?`<newparam sid="emissive-surface"><surface type="2D"><init_from>${p(t.emissiveMap)}</init_from></surface></newparam><newparam sid="emissive-sampler"><sampler2D><source>emissive-surface</source></sampler2D></newparam>`:""}${t.normalMap?`<newparam sid="bump-surface"><surface type="2D"><init_from>${p(t.normalMap)}</init_from></surface></newparam><newparam sid="bump-sampler"><sampler2D><source>bump-surface</source></sampler2D></newparam>`:""}${u}${t.side===e.DoubleSide?'<extra><technique profile="THREEJS"><double_sided sid="double_sided" type="int">1</double_sided></technique></extra>':""}</profile_COMMON></effect>`,f=`<material id="${r}"${t.name?` name="${t.name}"`:""}><instance_effect url="#${r}-effect" /></material>`;x.push(f),_.push(m),$.set(t,r)}return r}(m[r%m.length]))),a+=`<instance_geometry url="#${n}">`+(null!=s?`<bind_material><technique_common>${s.map(((e,t)=>`<instance_material symbol="MESH_MATERIAL_${t}" target="#${e}" ><bind_vertex_input semantic="TEXCOORD" input_semantic="TEXCOORD" input_set="0" /></instance_material>`)).join("")}</technique_common></bind_material>`:"")+"</instance_geometry>"}return r.children.forEach((e=>a+=t(e))),a+="</node>",a}(t);let w=`<?xml version="1.0" encoding="UTF-8" standalone="no" ?><COLLADA xmlns="${"1.4.1"===n?"http://www.collada.org/2005/11/COLLADASchema":"https://www.khronos.org/collada/"}" version="${n}"><asset><contributor><authoring_tool>three.js Collada Exporter</authoring_tool>${null!==a.author?`<author>${a.author}</author>`:""}</contributor><created>${(new Date).toISOString()}</created><modified>${(new Date).toISOString()}</modified><up_axis>Y_UP</up_axis></asset>`;w+=`<library_images>${h.join("")}</library_images>`,w+=`<library_effects>${_.join("")}</library_effects>`,w+=`<library_materials>${x.join("")}</library_materials>`,w+=`<library_geometries>${y.join("")}</library_geometries>`,w+=`<library_visual_scenes><visual_scene id="Scene" name="scene">${b}</visual_scene></library_visual_scenes>`,w+='<scene><instance_visual_scene url="#Scene"/></scene>',w+="</COLLADA>";const v={data:function(e){const t=/^<\//,r=/(\?>$)|(\/>$)/,a=/<[^>]+>[^<]*<\/[^<]+>/,n=(e,t)=>t>0?e+n(e,t-1):"";let i=0;return e.match(/(<[^>]+>[^<]+<\/[^<]+>)|(<[^>]+>)/g).map((e=>{a.test(e)||r.test(e)||!t.test(e)||i--;const s=`${n("  ",i)}${e}`;return a.test(e)||r.test(e)||t.test(e)||i++,s})).join("\n")}(w),textures:g};return"function"==typeof r&&requestAnimationFrame((()=>r(v))),v}},exports.ColladaExporter=t;
