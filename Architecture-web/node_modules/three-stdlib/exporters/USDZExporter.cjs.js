"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var n=require("fflate");async function e(n){if("undefined"!=typeof HTMLImageElement&&n instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&n instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&n instanceof OffscreenCanvas||"undefined"!=typeof ImageBitmap&&n instanceof ImageBitmap){const e=1024/Math.max(n.width,n.height),t=document.createElement("canvas");t.width=n.width*Math.min(1,e),t.height=n.height*Math.min(1,e);t.getContext("2d").drawImage(n,0,0,t.width,t.height);const r=await new Promise((n=>t.toBlob(n,"image/jpeg",1)));return new Uint8Array(await r.arrayBuffer())}}function t(n,e){return`(${n[e+0]}, ${n[e+1]}, ${n[e+2]}, ${n[e+3]})`}function r(n,e){if(void 0===n)return console.warn("USDZExporter: Normals missing."),Array(e).fill("(0, 0, 0)").join(", ");const t=[],r=n.array;for(let n=0;n<r.length;n+=3)t.push(`(${r[n+0].toPrecision(7)}, ${r[n+1].toPrecision(7)}, ${r[n+2].toPrecision(7)})`);return t.join(", ")}function o(n){const e="            ",t=[];return null!==n.map?t.push(`${e}color3f inputs:diffuseColor.connect = </Textures/Texture_${n.map.id}.outputs:rgb>`):t.push(`${e}color3f inputs:diffuseColor = ${s(n.color)}`),null!==n.emissiveMap?t.push(`${e}color3f inputs:emissiveColor.connect = </Textures/Texture_${n.emissiveMap.id}.outputs:rgb>`):n.emissive.getHex()>0&&t.push(`${e}color3f inputs:emissiveColor = ${s(n.emissive)}`),null!==n.normalMap&&t.push(`${e}normal3f inputs:normal.connect = </Textures/Texture_${n.normalMap.id}.outputs:rgb>`),null!==n.aoMap&&t.push(`${e}float inputs:occlusion.connect = </Textures/Texture_${n.aoMap.id}.outputs:r>`),null!==n.roughnessMap?t.push(`${e}float inputs:roughness.connect = </Textures/Texture_${n.roughnessMap.id}.outputs:g>`):t.push(`${e}float inputs:roughness = ${n.roughness}`),null!==n.metalnessMap?t.push(`${e}float inputs:metallic.connect = </Textures/Texture_${n.metalnessMap.id}.outputs:b>`):t.push(`${e}float inputs:metallic = ${n.metalness}`),`\n    def Material "Material_${n.id}"\n    {\n        token outputs:surface.connect = </Materials/Material_${n.id}/PreviewSurface.outputs:surface>\n\n        def Shader "PreviewSurface"\n        {\n            uniform token info:id = "UsdPreviewSurface"\n${t.join("\n")}\n            int inputs:useSpecularWorkflow = 0\n            token outputs:surface\n        }\n    }\n`}function i(n){return`\n    def Shader "Texture_${n.id}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${n.id}.jpg@\n        token inputs:wrapS = "repeat"\n        token inputs:wrapT = "repeat"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n    }\n`}function s(n){return`(${n.r}, ${n.g}, ${n.b})`}exports.USDZExporter=class{async parse(s){let u='#usda 1.0\n(\n    customLayerData = {\n        string creator = "Three.js USDZExporter"\n    }\n    metersPerUnit = 1\n    upAxis = "Y"\n)\n\n';const a={},l={};s.traverse((n=>{if(n.isMesh){const e=n.geometry,o=n.material;a[o.uuid]=o,null!==o.map&&(l[o.map.uuid]=o.map),null!==o.normalMap&&(l[o.normalMap.uuid]=o.normalMap),null!==o.aoMap&&(l[o.aoMap.uuid]=o.aoMap),null!==o.roughnessMap&&(l[o.roughnessMap.uuid]=o.roughnessMap),null!==o.metalnessMap&&(l[o.metalnessMap.uuid]=o.metalnessMap),null!==o.emissiveMap&&(l[o.emissiveMap.uuid]=o.emissiveMap),u+=function(n,e){const r=`Object_${n.id}`,o=function(n){const e=n.elements;return`( ${t(e,0)}, ${t(e,4)}, ${t(e,8)}, ${t(e,12)} )`}(n.matrixWorld);return`def Xform "${r}"\n{\n    matrix4d xformOp:transform = ${o}\n    uniform token[] xformOpOrder = ["xformOp:transform"]\n\n    ${e}\n}\n\n`}(n,function(n,e){const t=`Geometry_${n.id}`,o=n.attributes,i=o.position.count;"uv2"in o&&console.warn("THREE.USDZExporter: uv2 not supported yet.");return`def Mesh "${t}"\n    {\n        int[] faceVertexCounts = [${function(n){const e=null!==n.index?n.index.array.length:n.attributes.position.count;return Array(e/3).fill(3).join(", ")}(n)}]\n        int[] faceVertexIndices = [${function(n){if(null!==n.index)return n.index.array.join(", ");const e=[],t=n.attributes.position.count;for(let n=0;n<t;n++)e.push(n);return e.join(", ")}(n)}]\n        rel material:binding = </Materials/Material_${e.id}>\n        normal3f[] normals = [${r(o.normal,i)}] (\n            interpolation = "vertex"\n        )\n        point3f[] points = [${r(o.position,i)}]\n        float2[] primvars:st = [${function(n,e){if(void 0===n)return console.warn("USDZExporter: UVs missing."),Array(e).fill("(0, 0)").join(", ");const t=[],r=n.array;for(let n=0;n<r.length;n+=2)t.push(`(${r[n+0].toPrecision(7)}, ${1-r[n+1].toPrecision(7)})`);return t.join(", ")}(o.uv,i)}] (\n            interpolation = "vertex"\n        )\n        uniform token subdivisionScheme = "none"\n    }\n`}(e,o))}})),u+=function(n){const e=[];for(let t in n){const r=n[t];e.push(o(r))}return`def "Materials"\n{\n${e.join("")}\n}\n\n`}(a),u+=function(n){const e=[];for(let t in n){const r=n[t];e.push(i(r))}return`def "Textures"\n{\n${e.join("")}\n}\n\n`}(l);const p={"model.usda":n.strToU8(u)};for(let n in l){const t=l[n];p[`textures/Texture_${t.id}.jpg`]=await e(t.image)}let f=0;for(let n in p){const e=p[n];f+=34+n.length;const t=63&f;if(4!==t){const r=new Uint8Array(64-t);p[n]=[e,{extra:{12345:r}}]}f=e.length}return n.zipSync(p,{level:0})}};
