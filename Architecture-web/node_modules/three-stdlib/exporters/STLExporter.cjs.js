"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var t=require("three");const e=()=>{};e.prototype={constructor:e,parse:function(e,o){void 0===o&&(o={});const r=void 0!==o.binary&&o.binary,n=[];let s,i=0;e.traverse((t=>{if(t.isMesh){const e=t.geometry;if(!0!==e.isBufferGeometry)throw new Error("THREE.STLExporter: Geometry is not of type THREE.BufferGeometry.");const o=e.index,r=e.getAttribute("position");i+=null!==o?o.count/3:r.count/3,n.push({object3d:t,geometry:e})}}));let c=80;if(!0===r){const t=new ArrayBuffer(2*i+3*i*4*4+80+4);s=new DataView(t),s.setUint32(c,i,!0),c+=4}else s="",s+="solid exported\n";const f=new t.Vector3,l=new t.Vector3,a=new t.Vector3,u=new t.Vector3,p=new t.Vector3,y=new t.Vector3;for(let t=0,e=n.length;t<e;t++){const e=n[t].object3d,o=n[t].geometry,r=o.index,s=o.getAttribute("position");if(null!==r)for(let t=0;t<r.count;t+=3){d(r.getX(t+0),r.getX(t+1),r.getX(t+2),s,e)}else for(let t=0;t<s.count;t+=3){d(t+0,t+1,t+2,s,e)}}return!1===r&&(s+="endsolid exported\n"),s;function d(t,e,o,n,i){f.fromBufferAttribute(n,t),l.fromBufferAttribute(n,e),a.fromBufferAttribute(n,o),!0===i.isSkinnedMesh&&(i.boneTransform(t,f),i.boneTransform(e,l),i.boneTransform(o,a)),f.applyMatrix4(i.matrixWorld),l.applyMatrix4(i.matrixWorld),a.applyMatrix4(i.matrixWorld),function(t,e,o){u.subVectors(o,e),p.subVectors(t,e),u.cross(p).normalize(),y.copy(u).normalize(),!0===r?(s.setFloat32(c,y.x,!0),c+=4,s.setFloat32(c,y.y,!0),c+=4,s.setFloat32(c,y.z,!0),c+=4):(s+=`\tfacet normal ${y.x} ${y.y} ${y.z}\n`,s+="\t\touter loop\n")}(f,l,a),x(f),x(l),x(a),!0===r?(s.setUint16(c,0,!0),c+=2):(s+="\t\tendloop\n",s+="\tendfacet\n")}function x(t){!0===r?(s.setFloat32(c,t.x,!0),c+=4,s.setFloat32(c,t.y,!0),c+=4,s.setFloat32(c,t.z,!0),c+=4):s+=`\t\t\tvertex ${t.x} ${t.y} ${t.z}\n`}}},exports.STLExporter=e;
